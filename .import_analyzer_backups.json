{
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\ui\\ollama_tab.py": "\"\"\"\nOllama Hub Tab UI Component\n\nThis module provides a tab component for browsing and managing Ollama models\nin the Irintai Assistant interface.\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport threading\nimport re\nimport time\nfrom typing import Dict, Any, List, Optional, Callable\n\nclass OllamaHubTab:\n    \"\"\"\n    UI Component for Ollama Hub functionality\n    \n    Provides a tab in the Irintai interface for browsing and managing Ollama models.\n    \"\"\"\n    \n    def __init__(self, parent, plugin_instance=None):\n        \"\"\"\n        Initialize the Ollama Hub Tab\n        \n        Args:\n            parent: Parent frame/notebook\n            plugin_instance: Instance of the Ollama Hub plugin\n        \"\"\"\n        self.parent = parent\n        self.plugin = plugin_instance\n        \n        # Check if plugin is available\n        if not self.plugin:\n            raise ValueError(\"Ollama Hub plugin instance is required\")\n        \n        # Create update queue for thread-safe UI updates\n        self.update_queue = None\n        if hasattr(parent, 'update_queue'):\n            self.update_queue = parent.update_queue\n        \n        # UI state variables\n        self.ollama_url_var = tk.StringVar(value=self.plugin._config.get(\"server_url\", \"http://localhost:11434\"))\n        self.ollama_status_var = tk.StringVar(value=self.plugin._state.get(\"connection_status\", \"Not connected\"))\n        self.ollama_search_var = tk.StringVar()\n        self.ollama_category_var = tk.StringVar(value=\"All\")\n        self.ollama_selected_model_var = tk.StringVar(value=\"None\")\n        self.ollama_model_desc_var = tk.StringVar(value=\"\")\n        \n        # Model data\n        self.local_models = {}\n        self.library_models = []\n        \n        # Setup UI components\n        self.setup_ui()\n        \n        # Subscribe to plugin events\n        if hasattr(self.plugin.core, 'event_bus'):\n            subscriber_id = f\"ollama_hub_tab_{id(self)}\"\n            self.plugin.core.event_bus.subscribe(\n                f\"{self.plugin.plugin_id}.models_updated\",\n                self._on_models_updated,\n                subscriber_id\n            )\n            self.plugin.core.event_bus.subscribe(\n                f\"{self.plugin.plugin_id}.download_progress\",\n                self._on_download_progress,\n                subscriber_id\n            )\n            self.plugin.core.event_bus.subscribe(\n                f\"{self.plugin.plugin_id}.model_downloaded\",\n                self._on_model_downloaded,\n                subscriber_id\n            )\n            self.plugin.core.event_bus.subscribe(\n                f\"{self.plugin.plugin_id}.model_deleted\",\n                self._on_model_deleted,\n                subscriber_id\n            )\n    \n    def setup_ui(self):\n        \"\"\"\n        Set up the UI components for the Ollama Hub tab\n        \"\"\"\n        # Create main container frame with padding\n        self.frame = ttk.Frame(self.parent, padding=(10, 10, 10, 10))\n        self.frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Create connection section\n        connection_frame = ttk.LabelFrame(self.frame, text=\"Ollama Connection\")\n        connection_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Create connection controls\n        conn_grid = ttk.Frame(connection_frame)\n        conn_grid.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Server URL\n        ttk.Label(conn_grid, text=\"Server URL:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        url_entry = ttk.Entry(conn_grid, textvariable=self.ollama_url_var, width=30)\n        url_entry.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # Connection status\n        ttk.Label(conn_grid, text=\"Status:\").grid(row=0, column=2, sticky=tk.W, padx=(20, 5), pady=5)\n        status_label = ttk.Label(conn_grid, textvariable=self.ollama_status_var)\n        status_label.grid(row=0, column=3, sticky=tk.W, padx=5, pady=5)\n        \n        # Connect button\n        connect_button = ttk.Button(\n            conn_grid, \n            text=\"Connect\", \n            command=self._on_connect_button_clicked\n        )\n        connect_button.grid(row=0, column=4, sticky=tk.W, padx=5, pady=5)\n        \n        # Create available models section with list and search\n        models_frame = ttk.LabelFrame(self.frame, text=\"Available Models\")\n        models_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Create search and filter options\n        filter_frame = ttk.Frame(models_frame)\n        filter_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Label(filter_frame, text=\"Search:\").pack(side=tk.LEFT, padx=5)\n        search_entry = ttk.Entry(filter_frame, textvariable=self.ollama_search_var, width=25)\n        search_entry.pack(side=tk.LEFT, padx=5)\n        search_entry.bind(\"<KeyRelease>\", self.filter_models)\n        \n        # Category filter\n        ttk.Label(filter_frame, text=\"Category:\").pack(side=tk.LEFT, padx=(20, 5))\n        categories = [\"All\", \"Small\", \"Medium\", \"Large\", \"Multimodal\", \"Code\", \"Vision\"]\n        category_combo = ttk.Combobox(\n            filter_frame, \n            textvariable=self.ollama_category_var,\n            values=categories,\n            state=\"readonly\",\n            width=15\n        )\n        category_combo.pack(side=tk.LEFT, padx=5)\n        category_combo.bind(\"<<ComboboxSelected>>\", self.filter_models)\n        \n        # Refresh button\n        ttk.Button(\n            filter_frame,\n            text=\"Refresh List\",\n            command=self._on_refresh_button_clicked\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        # Model list with columns for name, size, tags, parameters\n        columns = (\"Name\", \"Size\", \"Parameters\", \"Tags\")\n        self.model_tree = ttk.Treeview(\n            models_frame,\n            columns=columns,\n            show=\"headings\",\n            selectmode=\"browse\",\n            height=10\n        )\n        \n        # Configure columns\n        self.model_tree.heading(\"Name\", text=\"Model Name\")\n        self.model_tree.heading(\"Size\", text=\"Size\")\n        self.model_tree.heading(\"Parameters\", text=\"Parameters\")\n        self.model_tree.heading(\"Tags\", text=\"Tags\")\n        \n        self.model_tree.column(\"Name\", width=200, anchor=tk.W)\n        self.model_tree.column(\"Size\", width=80, anchor=tk.CENTER)\n        self.model_tree.column(\"Parameters\", width=100, anchor=tk.CENTER)\n        self.model_tree.column(\"Tags\", width=200, anchor=tk.W)\n        \n        # Add scrollbar\n        model_list_frame = ttk.Frame(models_frame)\n        model_list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n        \n        scrollbar = ttk.Scrollbar(model_list_frame, orient=tk.VERTICAL, command=self.model_tree.yview)\n        self.model_tree.configure(yscrollcommand=scrollbar.set)\n        \n        # Pack tree and scrollbar\n        self.model_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        # Bind selection event\n        self.model_tree.bind(\"<<TreeviewSelect>>\", self.on_model_selected)\n        \n        # Model detail section\n        detail_frame = ttk.LabelFrame(self.frame, text=\"Model Details\")\n        detail_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Create a frame for model details\n        model_detail_grid = ttk.Frame(detail_frame)\n        model_detail_grid.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Selected model info\n        ttk.Label(model_detail_grid, text=\"Selected:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)\n        ttk.Label(model_detail_grid, textvariable=self.ollama_selected_model_var, font=(\"\", 10, \"bold\")).grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(model_detail_grid, text=\"Description:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)\n        ttk.Label(model_detail_grid, textvariable=self.ollama_model_desc_var, wraplength=400).grid(row=1, column=1, columnspan=3, sticky=tk.W, padx=5, pady=2)\n        \n        # Progress bar for downloads\n        ttk.Label(model_detail_grid, text=\"Progress:\").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)\n        self.progress_var = tk.DoubleVar(value=0)\n        self.progress_bar = ttk.Progressbar(\n            model_detail_grid,\n            variable=self.progress_var,\n            maximum=100,\n            length=400\n        )\n        self.progress_bar.grid(row=2, column=1, columnspan=3, sticky=tk.EW, padx=5, pady=2)\n        \n        # Model actions\n        action_frame = ttk.Frame(self.frame)\n        action_frame.pack(fill=tk.X, padx=5, pady=(10, 5))\n        \n        # Download button\n        self.download_btn = ttk.Button(\n            action_frame,\n            text=\"Download Model\",\n            command=self._on_download_button_clicked\n        )\n        self.download_btn.pack(side=tk.LEFT, padx=5)\n        self.download_btn.state(['disabled'])\n        \n        # Delete model button\n        self.delete_btn = ttk.Button(\n            action_frame,\n            text=\"Delete Model\",\n            command=self._on_delete_button_clicked\n        )\n        self.delete_btn.pack(side=tk.LEFT, padx=5)\n        self.delete_btn.state(['disabled'])\n        \n        # Use model button\n        self.use_btn = ttk.Button(\n            action_frame,\n            text=\"Use Selected Model\",\n            command=self._on_use_button_clicked,\n            style=\"Accent.TButton\" if hasattr(ttk, \"Accent.TButton\") else \"\"\n        )\n        self.use_btn.pack(side=tk.RIGHT, padx=5)\n        self.use_btn.state(['disabled'])\n        \n        # Advanced options button\n        self.options_btn = ttk.Button(\n            action_frame,\n            text=\"Advanced Options\",\n            command=self._on_options_button_clicked\n        )\n        self.options_btn.pack(side=tk.RIGHT, padx=5)\n        self.options_btn.state(['disabled'])\n        \n        # Try to connect to Ollama automatically after a short delay\n        self.frame.after(500, self._on_connect_button_clicked)\n    \n    def _on_connect_button_clicked(self):\n        \"\"\"\n        Handle connect button click\n        \"\"\"\n        # Update server URL in plugin config\n        url = self.ollama_url_var.get().strip()\n        if not url:\n            self._show_error(\"No URL provided\")\n            return\n        \n        # Update status and config\n        self.ollama_status_var.set(\"Connecting...\")\n        self.plugin.update_configuration(server_url=url)\n        \n        # Try to connect\n        self.plugin.connect_to_ollama()\n    \n    def _on_refresh_button_clicked(self):\n        \"\"\"\n        Handle refresh button click\n        \"\"\"\n        # Fetch models from the plugin\n        self.plugin.fetch_ollama_models()\n    \n    def _on_download_button_clicked(self):\n        \"\"\"\n        Handle download button click\n        \"\"\"\n        model_name = self.ollama_selected_model_var.get()\n        if model_name == \"None\":\n            return\n            \n        # Reset progress\n        self.progress_var.set(0)\n        \n        # Disable download button during download\n        self.download_btn.state(['disabled'])\n        \n        # Start download\n        self.plugin.download_ollama_model(model_name)\n    \n    def _on_delete_button_clicked(self):\n        \"\"\"\n        Handle delete button click\n        \"\"\"\n        model_name = self.ollama_selected_model_var.get()\n        if model_name == \"None\":\n            return\n        \n        # Confirm deletion\n        if not messagebox.askyesno(\n            \"Confirm Deletion\",\n            f\"Are you sure you want to delete model {model_name}?\"\n        ):\n            return\n            \n        # Disable delete button during deletion\n        self.delete_btn.state(['disabled'])\n        \n        # Start deletion\n        self.plugin.delete_ollama_model(model_name)\n    \n    def _on_use_button_clicked(self):\n        \"\"\"\n        Handle use button click\n        \"\"\"\n        model_name = self.ollama_selected_model_var.get()\n        if model_name == \"None\":\n            return\n        \n        # Check if model_manager exists in the core system\n        if hasattr(self.plugin.core, 'model_manager'):\n            model_manager = self.plugin.core.model_manager\n            \n            # Check if model_manager has select_model method\n            if hasattr(model_manager, 'select_model'):\n                # Call select_model method to use the selected model\n                model_manager.select_model(f\"ollama:{model_name}\")\n                messagebox.showinfo(\n                    \"Model Selected\",\n                    f\"Model {model_name} has been selected for use.\"\n                )\n            else:\n                self._show_error(\"Model manager does not support model selection\")\n        else:\n            self._show_error(\"Model manager not available in the core system\")\n    \n    def _on_options_button_clicked(self):\n        \"\"\"\n        Handle advanced options button click\n        \"\"\"\n        model_name = self.ollama_selected_model_var.get()\n        if model_name == \"None\":\n            return\n            \n        # Create options dialog\n        options_dialog = tk.Toplevel(self.parent)\n        options_dialog.title(f\"Advanced Options for {model_name}\")\n        options_dialog.geometry(\"400x300\")\n        options_dialog.transient(self.parent)\n        options_dialog.grab_set()\n        \n        # Create options form\n        options_frame = ttk.Frame(options_dialog, padding=(20, 20))\n        options_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Temperature\n        ttk.Label(options_frame, text=\"Temperature:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        temp_var = tk.DoubleVar(value=0.8)\n        temp_scale = ttk.Scale(\n            options_frame,\n            from_=0.0,\n            to=1.0,\n            orient=tk.HORIZONTAL,\n            variable=temp_var,\n            length=200\n        )\n        temp_scale.grid(row=0, column=1, sticky=tk.EW, padx=5, pady=5)\n        ttk.Label(options_frame, textvariable=temp_var).grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)\n        \n        # Context size\n        ttk.Label(options_frame, text=\"Context Size:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)\n        context_var = tk.IntVar(value=4096)\n        context_entry = ttk.Entry(options_frame, textvariable=context_var, width=10)\n        context_entry.grid(row=1, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # Threads\n        ttk.Label(options_frame, text=\"Threads:\").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)\n        threads_var = tk.IntVar(value=4)\n        threads_entry = ttk.Entry(options_frame, textvariable=threads_var, width=10)\n        threads_entry.grid(row=2, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # GPU Layers\n        ttk.Label(options_frame, text=\"GPU Layers:\").grid(row=3, column=0, sticky=tk.W, padx=5, pady=5)\n        gpu_var = tk.StringVar(value=\"auto\")\n        gpu_entry = ttk.Entry(options_frame, textvariable=gpu_var, width=10)\n        gpu_entry.grid(row=3, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # Seed\n        ttk.Label(options_frame, text=\"Seed:\").grid(row=4, column=0, sticky=tk.W, padx=5, pady=5)\n        seed_var = tk.IntVar(value=0)\n        seed_entry = ttk.Entry(options_frame, textvariable=seed_var, width=10)\n        seed_entry.grid(row=4, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # Buttons\n        button_frame = ttk.Frame(options_dialog)\n        button_frame.pack(fill=tk.X, padx=20, pady=20)\n        \n        ttk.Button(\n            button_frame, \n            text=\"Apply\",\n            command=lambda: self._apply_model_options(\n                model_name,\n                {\n                    \"temperature\": temp_var.get(),\n                    \"context\": context_var.get(),\n                    \"threads\": threads_var.get(),\n                    \"gpu\": gpu_var.get(),\n                    \"seed\": seed_var.get()\n                },\n                options_dialog\n            )\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Cancel\",\n            command=options_dialog.destroy\n        ).pack(side=tk.RIGHT, padx=5)\n    \n    def _apply_model_options(self, model_name, options, dialog):\n        \"\"\"\n        Apply advanced model options\n        \n        Args:\n            model_name: Name of the model\n            options: Dictionary of model options\n            dialog: Options dialog to close after applying\n        \"\"\"\n        # Check if model_manager exists in the core system\n        if hasattr(self.plugin.core, 'model_manager'):\n            model_manager = self.plugin.core.model_manager\n            \n            # Check if model_manager has configure_model method\n            if hasattr(model_manager, 'configure_model'):\n                # Call configure_model method to apply options\n                model_manager.configure_model(f\"ollama:{model_name}\", options)\n                messagebox.showinfo(\n                    \"Options Applied\",\n                    f\"Advanced options have been applied to {model_name}.\"\n                )\n                dialog.destroy()\n            else:\n                self._show_error(\"Model manager does not support model configuration\")\n        else:\n            self._show_error(\"Model manager not available in the core system\")\n    \n    def on_model_selected(self, event=None):\n        \"\"\"\n        Handle selection of a model in the tree view\n        \n        Args:\n            event: Event object (optional)\n        \"\"\"\n        selected_items = self.model_tree.selection()\n        if not selected_items:\n            return\n\n        item = selected_items[0]\n        values = self.model_tree.item(item, \"values\")\n        tags = self.model_tree.item(item, \"tags\")\n\n        # Get model name without the icon prefix\n        model_name = values[0].replace(\"\ud83d\udcc2 \", \"\") if values[0].startswith(\"\ud83d\udcc2 \") else values[0]\n        is_local = \"local\" in tags\n        \n        # Clean up model name if it has a download icon\n        if model_name.startswith(\"\ud83d\udce5\"):\n            model_name = model_name[1:]\n\n        # Update selected model\n        self.ollama_selected_model_var.set(model_name)\n\n        # Update description based on model name\n        if \"code\" in model_name.lower() or \"coder\" in model_name.lower():\n            self.ollama_model_desc_var.set(\"A model fine-tuned for coding tasks and technical assistance.\")\n        elif \"chat\" in model_name.lower():\n            self.ollama_model_desc_var.set(\"A conversational model designed for helpful dialogue.\")\n        else:\n            self.ollama_model_desc_var.set(\"A general purpose language model.\")\n\n        # Update buttons based on model status\n        if is_local:\n            self.download_btn.state(['disabled'])\n            self.delete_btn.state(['!disabled'])\n            self.use_btn.state(['!disabled'])\n            self.options_btn.state(['!disabled'])\n        else:\n            self.download_btn.state(['!disabled'])\n            self.delete_btn.state(['disabled'])\n            self.use_btn.state(['disabled'])\n            self.options_btn.state(['disabled'])\n    \n    def filter_models(self, event=None):\n        \"\"\"\n        Filter models based on search and category\n        \n        Args:\n            event: Event object (optional)\n        \"\"\"\n        search_term = self.ollama_search_var.get().lower()\n        category = self.ollama_category_var.get()\n\n        # Show all items\n        for item in self.model_tree.get_children():\n            self.model_tree.item(item, open=True)\n\n            # Get values and tags\n            values = self.model_tree.item(item, 'values')\n            tags = self.model_tree.item(item, 'tags')\n            \n            model_name = values[0].replace(\"\ud83d\udcc2 \", \"\").lower() if values[0].startswith(\"\ud83d\udcc2 \") else values[0].lower()\n            model_tags = values[3].lower()\n            is_local = \"local\" in tags\n\n            # Check if model matches search and category\n            matches_search = search_term in model_name or search_term in model_tags\n            matches_category = (\n                category == \"All\" or\n                (category == \"Small\" and \"3b\" in model_name or \"7b\" in model_name) or\n                (category == \"Medium\" and \"13b\" in model_name or \"15b\" in model_name) or\n                (category == \"Large\" and \"30b\" in model_name or \"70b\" in model_name) or\n                (category == \"Code\" and (\"code\" in model_name or \"coder\" in model_name)) or\n                (category == \"Vision\" and (\"vision\" in model_name or \"vl\" in model_name)) or\n                (category == \"Multimodal\" and (\"vision\" in model_name or \"multi\" in model_name))\n            )\n\n            # If search term is empty, just filter by category\n            if not search_term:\n                matches_search = True\n\n            # Show/hide based on matches\n            if matches_search and matches_category:\n                self.model_tree.item(item, tags=tags)  # Keep visible\n            else:\n                self.model_tree.detach(item)  # Hide\n    \n    def _on_models_updated(self, event_name, data, event_info=None):\n        \"\"\"\n        Handle models updated event from plugin\n        \n        Args:\n            event_name: Event name\n            data: Event data\n            event_info: Additional event info (optional)\n        \"\"\"\n        # Update model data\n        self.local_models = data.get(\"local_models\", {})\n        self.library_models = data.get(\"library_models\", [])\n        \n        # Update UI on the main thread\n        if self.update_queue:\n            self.update_queue.put(lambda: self._update_models_ui())\n        else:\n            self._update_models_ui()\n    \n    def _update_models_ui(self):\n        \"\"\"\n        Update the UI with model data\n        \"\"\"\n        # Clear the tree\n        for item in self.model_tree.get_children():\n            self.model_tree.delete(item)\n        \n        # Track how many models we display\n        local_count = 0\n        remote_count = 0\n        \n        # First add local models\n        for name, model in self.local_models.items():\n            local_count += 1\n            # Extract model details\n            size = model.get('size', 'Unknown')\n            if isinstance(size, int):\n                # Convert size to human-readable format\n                if size < 1024 * 1024:  # < 1MB\n                    size_str = f\"{size / 1024:.1f} KB\"\n                elif size < 1024 * 1024 * 1024:  # < 1GB\n                    size_str = f\"{size / (1024 * 1024):.1f} MB\"\n                else:  # GB+\n                    size_str = f\"{size / (1024 * 1024 * 1024):.1f} GB\"\n            else:\n                size_str = str(size)\n                \n            # Make a guess at parameters based on model name\n            param_match = re.search(r'(\\d+)b', name, re.IGNORECASE)\n            parameters = f\"{param_match.group(1)}B\" if param_match else \"Unknown\"\n            \n            tags = model.get('tags', [])\n            tag_str = \", \".join(tags) if tags else \"\"\n            \n            # Add to tree with local indicator\n            self.model_tree.insert(\n                \"\", tk.END, \n                values=(f\"\ud83d\udcc2 {name}\", size_str, parameters, tag_str),\n                tags=[\"local\"]\n            )\n        \n        # Then add library models that aren't already local\n        for model in self.library_models:\n            if not model['is_local']:\n                remote_count += 1\n\n                # Get size information\n                size_str = model.get('size', 'Remote')\n\n                # Get parameter information\n                parameters = model.get('parameters', 'Unknown')\n\n                # Format tags\n                tags = model.get('tags', [])\n                # If no tags but we can infer from name\n                if not tags:\n                    if 'code' in model['name'].lower() or 'coder' in model['name'].lower():\n                        tags.append('code')\n                    if 'vision' in model['name'].lower() or 'vl' in model['name'].lower():\n                        tags.append('vision')\n                    if 'instruct' in model['name'].lower():\n                        tags.append('instruct')\n\n                tag_str = \", \".join(tags) if tags else \"\"\n\n                # Add visual indicator for remote models\n                self.model_tree.insert(\n                    \"\", tk.END,\n                    values=(f\"\ud83d\udce5{model['name']}\", size_str, parameters, tag_str),\n                    tags=[\"remote\"] + (['recommended'] if 'recommended' in model and model['recommended'] else [])\n                )\n\n        # Apply visual styling based on tags\n        for item in self.model_tree.get_children():\n            tags = self.model_tree.item(item, 'tags')\n            if 'recommended' in tags:\n                # Use a different style for recommended models\n                self.model_tree.item(item, tags=tags + ['highlighted'])\n                \n        # Update status in the plugin\n        self.ollama_status_var.set(self.plugin._state.get(\"connection_status\", \"Unknown\"))\n    \n    def _on_download_progress(self, event_name, data, event_info=None):\n        \"\"\"\n        Handle download progress event from plugin\n        \n        Args:\n            event_name: Event name\n            data: Event data\n            event_info: Additional event info (optional)\n        \"\"\"\n        # Update progress on the main thread\n        if self.update_queue:\n            self.update_queue.put(lambda: self._update_download_progress(\n                data.get(\"percentage\", 0)\n            ))\n        else:\n            self._update_download_progress(data.get(\"percentage\", 0))\n    \n    def _update_download_progress(self, percentage):\n        \"\"\"\n        Update the download progress bar\n        \n        Args:\n            percentage: Download progress percentage\n        \"\"\"\n        self.progress_var.set(percentage)\n    \n    def _on_model_downloaded(self, event_name, data, event_info=None):\n        \"\"\"\n        Handle model downloaded event from plugin\n        \n        Args:\n            event_name: Event name\n            data: Event data\n            event_info: Additional event info (optional)\n        \"\"\"\n        # Update UI on the main thread\n        if self.update_queue:\n            self.update_queue.put(lambda: self._handle_download_completed(\n                data.get(\"model\", \"\"),\n                data.get(\"success\", False),\n                data.get(\"error\", \"\")\n            ))\n        else:\n            self._handle_download_completed(\n                data.get(\"model\", \"\"),\n                data.get(\"success\", False),\n                data.get(\"error\", \"\")\n            )\n    \n    def _handle_download_completed(self, model_name, success, error_message):\n        \"\"\"\n        Handle completion of model download\n        \n        Args:\n            model_name: Name of the model\n            success: Whether download was successful\n            error_message: Error message if unsuccessful\n        \"\"\"\n        # Reset progress\n        self.progress_var.set(0)\n        \n        # Re-enable download button\n        self.download_btn.state(['!disabled'])\n        \n        # Show message\n        if success:\n            messagebox.showinfo(\n                \"Download Complete\",\n                f\"Model {model_name} has been downloaded successfully.\"\n            )\n        else:\n            self._show_error(f\"Failed to download model {model_name}: {error_message}\")\n    \n    def _on_model_deleted(self, event_name, data, event_info=None):\n        \"\"\"\n        Handle model deleted event from plugin\n        \n        Args:\n            event_name: Event name\n            data: Event data\n            event_info: Additional event info (optional)\n        \"\"\"\n        # Update UI on the main thread\n        if self.update_queue:\n            self.update_queue.put(lambda: self._handle_deletion_completed(\n                data.get(\"model\", \"\"),\n                data.get(\"success\", False),\n                data.get(\"error\", \"\")\n            ))\n        else:\n            self._handle_deletion_completed(\n                data.get(\"model\", \"\"),\n                data.get(\"success\", False),\n                data.get(\"error\", \"\")\n            )\n    \n    def _handle_deletion_completed(self, model_name, success, error_message):\n        \"\"\"\n        Handle completion of model deletion\n        \n        Args:\n            model_name: Name of the model\n            success: Whether deletion was successful\n            error_message: Error message if unsuccessful\n        \"\"\"\n        # Re-enable delete button\n        self.delete_btn.state(['!disabled'])\n        \n        # Show message\n        if success:\n            messagebox.showinfo(\n                \"Deletion Complete\",\n                f\"Model {model_name} has been deleted successfully.\"\n            )\n        else:\n            self._show_error(f\"Failed to delete model {model_name}: {error_message}\")\n    \n    def _show_error(self, message):\n        \"\"\"\n        Show an error message\n        \n        Args:\n            message: Error message to show\n        \"\"\"\n        messagebox.showerror(\"Error\", message)\n",
  "D:\\AI\\IrintAI Assistant\\core\\plugin_sdk.py": "\"\"\"\nPlugin SDK for IrintAI Assistant\nProvides helpers and utilities for plugin development\n\"\"\"\nfrom typing import Dict, Any, Callable, List, Optional, Union\nimport os\nimport json\nimport importlib\nimport inspect\n\n\nclass PluginSDK:\n    \"\"\"SDK for IrintAI Assistant plugin development\"\"\"\n    \n    def __init__(self, plugin_id: str, core_system: Any):\n        \"\"\"\n        Initialize the Plugin SDK\n        \n        Args:\n            plugin_id: Unique plugin identifier\n            core_system: Core system instance\n        \"\"\"\n        self.plugin_id = plugin_id\n        self.core_system = core_system\n        self.logger = getattr(core_system, 'logger', None)\n        \n        # Cache for service lookups\n        self._service_cache = {}\n        \n        # Initialize sandboxed file operations\n        self.file_ops = None\n        if hasattr(core_system, 'file_ops'):\n            from file_operations.file_ops import PluginSandboxedFileOps\n            self.file_ops = PluginSandboxedFileOps(\n                core_system.file_ops, \n                plugin_id, \n                base_dir=os.path.dirname(os.path.dirname(os.path.abspath(__file__))),\n                logger=self.log\n            )\n        \n    def log(self, message: str, level: str = \"INFO\") -> None:\n        if self.logger and hasattr(self.logger, 'log'):\n            self.logger.log(f\"[Plugin: {self.plugin_id}] {message}\", level)\n        else:\n            print(f\"[Plugin: {self.plugin_id}] [{level}] {message}\")\n            \n    def get_service(self, service_name: str) -> Optional[Any]:\n        \"\"\"\n        Get a service from the core system\n        \n        Args:\n            service_name: Name of the service to retrieve\n            \n        Returns:\n            Service instance or None if not found\n        \"\"\"\n        # Check cache first\n        if service_name in self._service_cache:\n            return self._service_cache[service_name]\n            \n        # Try to get service from plugin manager\n        if hasattr(self.core_system, 'plugin_manager'):\n            service = self.core_system.plugin_manager.get_service(service_name)\n            if service:\n                self._service_cache[service_name] = service\n                return service\n                \n        # Try direct access from core system\n        if hasattr(self.core_system, service_name):\n            service = getattr(self.core_system, service_name)\n            self._service_cache[service_name] = service\n            return service\n            \n        return None\n        \n    def register_event_handler(self, event_name: str, handler: Callable) -> bool:\n        \"\"\"\n        Register an event handler\n        \n        Args:\n            event_name: Name of the event to handle\n            handler: Callback function for the event\n            \n        Returns:\n            True if registration was successful, False otherwise\n        \"\"\"\n        if not hasattr(self.core_system, 'plugin_manager'):\n            self.log(\"Plugin manager not available, can't register event handler\", \"WARNING\")\n            return False\n            \n        return self.core_system.plugin_manager.register_event_handler(\n            self.plugin_id, event_name, handler\n        )\n        \n    def emit_event(self, event_name: str, *args, **kwargs) -> None:\n        \"\"\"\n        Emit an event for other plugins or the core system\n        \n        Args:\n            event_name: Name of the event to emit\n            *args: Positional arguments for the event\n            **kwargs: Keyword arguments for the event\n        \"\"\"\n        if not hasattr(self.core_system, 'plugin_manager'):\n            self.log(\"Plugin manager not available, can't emit event\", \"WARNING\")\n            return\n            \n        self.core_system.plugin_manager.emit_event(\n            f\"{self.plugin_id}.{event_name}\", *args, **kwargs\n        )\n        \n    def get_plugin_data_dir(self) -> str:\n        \"\"\"\n        Get the plugin data directory path\n        \n        Returns:\n            Path to the plugin data directory\n        \"\"\"\n        # Get base plugin data directory from config\n        config_manager = self.get_service('config_manager')\n        if config_manager:\n            base_dir = config_manager.get('plugin_data_dir', 'plugin_data')\n        else:\n            base_dir = 'plugin_data'\n            \n        # Create plugin-specific directory\n        plugin_dir = os.path.join(base_dir, self.plugin_id)\n        os.makedirs(plugin_dir, exist_ok=True)\n        \n        return plugin_dir\n        \n    def save_data(self, data: Dict[str, Any], filename: str = 'plugin_data.json') -> bool:\n        \"\"\"\n        Save plugin data to a JSON file\n        \n        Args:\n            data: Dictionary of data to save\n            filename: Filename to save to\n            \n        Returns:\n            True if save was successful, False otherwise\n        \"\"\"\n        try:\n            plugin_dir = self.get_plugin_data_dir()\n            filepath = os.path.join(plugin_dir, filename)\n            \n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2, ensure_ascii=False)\n                \n            return True\n        except Exception as e:\n            self.log(f\"Failed to save plugin data: {e}\", \"ERROR\")\n            return False\n            \n    def load_data(self, filename: str = 'plugin_data.json', default: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"\n        Load plugin data from a JSON file\n        \n        Args:\n            filename: Filename to load from\n            default: Default data to return if file doesn't exist\n            \n        Returns:\n            Dictionary of loaded data\n        \"\"\"\n        try:\n            plugin_dir = self.get_plugin_data_dir()\n            filepath = os.path.join(plugin_dir, filename)\n            \n            if not os.path.exists(filepath):\n                return default or {}\n                \n            with open(filepath, 'r', encoding='utf-8') as f:\n                return json.load(f)\n                \n        except Exception as e:\n            self.log(f\"Failed to load plugin data: {e}\", \"ERROR\")\n            return default or {}\n            \n    def get_config(self, key: str = None, default: Any = None) -> Any:\n        \"\"\"\n        Get plugin configuration\n        \n        Args:\n            key: Specific config key to retrieve\n            default: Default value to return if key doesn't exist\n            \n        Returns:\n            Plugin configuration value\n        \"\"\"\n        config_manager = self.get_service('config_manager')\n        if not config_manager:\n            return default\n            \n        # Get plugin-specific config\n        plugin_config = config_manager.get(f\"plugins.{self.plugin_id}\", {})\n        \n        # Return specific key or full config\n        if key is not None:\n            return plugin_config.get(key, default)\n        return plugin_config\n            \n    def set_config(self, key: str, value: Any) -> bool:\n        \"\"\"\n        Set plugin configuration\n        \n        Args:\n            key: Config key to set\n            value: Config value\n            \n        Returns:\n            True if setting was successful, False otherwise\n        \"\"\"\n        config_manager = self.get_service('config_manager')\n        if not config_manager:\n            return False\n            \n        # Set plugin-specific config\n        plugin_config_key = f\"plugins.{self.plugin_id}.{key}\"\n        config_manager.set(plugin_config_key, value)\n        \n        # Save the config\n        return config_manager.save_config()\n        \n    def register_model_hook(self, hook_type: str, callback: Callable) -> bool:\n        \"\"\"\n        Register a hook for model processing\n        \n        Args:\n            hook_type: Type of hook (pre_process, post_process, etc.)\n            callback: Hook callback function\n            \n        Returns:\n            True if registration was successful, False otherwise\n        \"\"\"\n        chat_engine = self.get_service('chat_engine')\n        if not chat_engine or not hasattr(chat_engine, 'register_hook'):\n            self.log(f\"Failed to register model hook: chat engine not available\", \"WARNING\")\n            return False\n            \n        try:\n            chat_engine.register_hook(f\"{self.plugin_id}.{hook_type}\", hook_type, callback)\n            return True\n        except Exception as e:\n            self.log(f\"Failed to register model hook: {e}\", \"ERROR\")\n            return False\n            \n    def get_resource_usage(self) -> Dict[str, Any]:\n        \"\"\"\n        Get current resource usage information\n        \n        Returns:\n            Dictionary of resource usage metrics\n        \"\"\"\n        system_monitor = self.get_service('system_monitor')\n        if not system_monitor:\n            return {}\n            \n        return system_monitor.get_system_stats()\n        \n    def get_active_plugins(self) -> List[str]:\n        \"\"\"\n        Get list of active plugins\n        \n        Returns:\n            List of active plugin IDs\n        \"\"\"\n        if hasattr(self.core_system, 'plugin_manager'):\n            active_plugins = self.core_system.plugin_manager.get_active_plugins()\n            return list(active_plugins.keys())\n        return []\n        \n    def call_plugin_method(self, plugin_id: str, method_name: str, *args, **kwargs) -> Optional[Any]:\n        \"\"\"\n        Call a method on another plugin\n        \n        Args:\n            plugin_id: ID of the plugin to call\n            method_name: Name of the method to call\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Return value from the plugin method or None if failed\n        \"\"\"\n        if not hasattr(self.core_system, 'plugin_manager'):\n            self.log(\"Plugin manager not available, can't call plugin method\", \"WARNING\")\n            return None\n            \n        # Get the plugin instance\n        plugin = self.core_system.plugin_manager.get_plugin_instance(plugin_id)\n        if not plugin:\n            self.log(f\"Plugin {plugin_id} not found\", \"WARNING\")\n            return None\n            \n        # Check if method exists\n        if not hasattr(plugin, method_name) or not callable(getattr(plugin, method_name)):\n            self.log(f\"Method {method_name} not found in plugin {plugin_id}\", \"WARNING\")\n            return None\n            \n        # Call the method\n        try:\n            method = getattr(plugin, method_name)\n            return method(*args, **kwargs)\n        except Exception as e:\n            self.log(f\"Error calling {plugin_id}.{method_name}: {e}\", \"ERROR\")\n            return None\n            \n    def create_ui_component(self, parent, component_type: str, **kwargs) -> Any:\n        \"\"\"\n        Create a UI component\n        \n        Args:\n            parent: Parent widget\n            component_type: Type of component (Frame, Label, etc.)\n            **kwargs: Component options\n            \n        Returns:\n            Created UI component\n        \"\"\"\n        import tkinter as tk\n        from tkinter import ttk\n        \n        # Map component types to their constructors\n        component_map = {\n            # Tkinter components\n            'Frame': tk.Frame,\n            'Label': tk.Label,\n            'Button': tk.Button,\n            'Entry': tk.Entry,\n            'Text': tk.Text,\n            'Checkbutton': tk.Checkbutton,\n            'Radiobutton': tk.Radiobutton,\n            'Scale': tk.Scale,\n            'Listbox': tk.Listbox,\n            'Scrollbar': tk.Scrollbar,\n            'Menu': tk.Menu,\n            'Menubutton': tk.Menubutton,\n            'Canvas': tk.Canvas,\n            \n            # TTK components\n            'TFrame': ttk.Frame,\n            'TLabel': ttk.Label,\n            'TButton': ttk.Button,\n            'TEntry': ttk.Entry,\n            'TCheckbutton': ttk.Checkbutton,\n            'TRadiobutton': ttk.Radiobutton,\n            'TScale': ttk.Scale,\n            'Combobox': ttk.Combobox,\n            'Notebook': ttk.Notebook,\n            'Treeview': ttk.Treeview,\n            'Scrollbar': ttk.Scrollbar,\n            'Progressbar': ttk.Progressbar,\n            'Separator': ttk.Separator,\n            'Sizegrip': ttk.Sizegrip\n        }\n        \n        # Get the component constructor\n        constructor = component_map.get(component_type)\n        if not constructor:\n            self.log(f\"Unknown component type: {component_type}\", \"WARNING\")\n            return None\n            \n        # Create and return the component\n        try:\n            return constructor(parent, **kwargs)\n        except Exception as e:\n            self.log(f\"Error creating component {component_type}: {e}\", \"ERROR\")\n            return None\n        \n    def register_metric(self, metric_id: str, get_value_func: Callable[[], Any],\n                      name: str, description: str, format_type: str = \"numeric\",\n                      unit: str = \"\") -> bool:\n        \"\"\"\n        Register a custom metric with the resource monitoring system\n        \n        Args:\n            metric_id: Identifier for the metric\n            get_value_func: Function that returns the current metric value\n            name: Display name for the metric\n            description: Description of the metric\n            format_type: Format type (percentage, numeric, text)\n            unit: Unit for numeric metrics\n            \n        Returns:\n            True if registration was successful\n        \"\"\"\n        system_monitor = self.get_service('system_monitor')\n        if not system_monitor:\n            self.log(\"System monitor not available\", \"WARNING\")\n            return False\n            \n        metadata = {\n            \"name\": name,\n            \"description\": description,\n            \"format\": format_type\n        }\n        \n        if format_type == \"numeric\" and unit:\n            metadata[\"unit\"] = unit\n            \n        return system_monitor.register_plugin_metric(\n            self.plugin_id, metric_id, get_value_func, metadata\n        )\n        \n    def unregister_metric(self, metric_id: str) -> bool:\n        \"\"\"\n        Unregister a custom metric\n        \n        Args:\n            metric_id: Identifier for the metric\n            \n        Returns:\n            True if unregistration was successful\n        \"\"\"\n        system_monitor = self.get_service('system_monitor')\n        if not system_monitor:\n            return False\n            \n        return system_monitor.unregister_plugin_metric(self.plugin_id, metric_id)\n        \n    def register_process(self, process_id: int, name: str = None) -> bool:\n        \"\"\"\n        Register a process for monitoring\n        \n        Args:\n            process_id: Process ID\n            name: Optional process name\n            \n        Returns:\n            True if registration was successful\n        \"\"\"\n        system_monitor = self.get_service('system_monitor')\n        if not system_monitor:\n            self.log(\"System monitor not available\", \"WARNING\")\n            return False\n            \n        return system_monitor.register_monitored_process(self.plugin_id, process_id, name)\n        \n    def unregister_process(self, process_id: int) -> bool:\n        \"\"\"\n        Unregister a monitored process\n        \n        Args:\n            process_id: Process ID\n            \n        Returns:\n            True if unregistration was successful\n        \"\"\"\n        system_monitor = self.get_service('system_monitor')\n        if not system_monitor:\n            return False\n            \n        return system_monitor.unregister_monitored_process(self.plugin_id, process_id)\n        \n    def get_system_metrics(self) -> Dict[str, Any]:\n        \"\"\"\n        Get current system metrics\n        \n        Returns:\n            Dictionary of system metrics\n        \"\"\"\n        system_monitor = self.get_service('system_monitor')\n        if not system_monitor:\n            return {}\n            \n        return system_monitor.get_system_info()\n\n\n# Helper function to create plugin class template\ndef create_plugin_template(plugin_name: str, description: str, author: str) -> str:\n    \"\"\"\n    Create a plugin class template\n    \n    Args:\n        plugin_name: Name of the plugin\n        description: Plugin description\n        author: Plugin author\n        \n    Returns:\n        Template string for the plugin class\n    \"\"\"\n    plugin_id = plugin_name.lower().replace(' ', '_')\n    \n    template = f'''\"\"\"\n{plugin_name} plugin for IrintAI Assistant\n\nA plugin that {description.lower()}\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk\nfrom typing import Dict, Any, Callable, List, Optional\n\nclass IrintaiPlugin:\n    def __init__(self, plugin_id, core_system):\n        self.plugin_id = plugin_id\n        self.core_system = core_system\n        self.log = core_system.logger.log if hasattr(core_system, \"logger\") else print\n        \n    def activate(self):\n        \"\"\"Activate the plugin\"\"\"\n        self.log(f\"{plugin_name} Plugin activated\")\n        return True\n        \n    def deactivate(self):\n        \"\"\"Deactivate the plugin\"\"\"\n        self.log(f\"{plugin_name} Plugin deactivated\")\n        return True\n        \n    def get_actions(self):\n        \"\"\"\n        Get plugin actions for the UI menu\n        \n        Returns:\n            Dictionary of action names and callbacks\n        \"\"\"\n        return {{\n            \"Example Action\": self.example_action\n        }}\n        \n    def example_action(self):\n        \"\"\"Example plugin action\"\"\"\n        self.log(f\"Example action from {plugin_name}\")\n\n\n# Plugin metadata\nplugin_info = {{\n    \"name\": \"{plugin_name}\",\n    \"description\": \"{description}\",\n    \"version\": \"1.0.0\",\n    \"author\": \"{author}\",\n    \"url\": \"https://example.com/plugins/{plugin_id}\",\n    \"plugin_class\": IrintaiPlugin,\n    \"compatibility\": \"0.5.0\",\n    \"tags\": [\"example\", \"template\"]\n}}\n'''\n    return template\n\nif __name__ != \"__main__\":\n    __all__ = [\"IrintaiPlugin\"]  # Export the plugin class for external use\n",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\plugin_diagnostic.py": "\"\"\"\nPlugin Diagnostic Module for IrintAI Assistant\n\nThis module provides diagnostics for the plugin system including:\n- Plugin directory structure\n- Plugin manifest validation\n- Plugin dependencies\n- Plugin loading and initialization\n\"\"\"\nimport os\nimport sys\nimport json\nimport importlib.util\nimport time\nfrom typing import Dict, Any, List, Tuple\n\n# Add project root to sys.path to allow importing core modules\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nif project_root not in sys.path:\n    sys.path.insert(0, project_root)\n\ntry:\n    from core.config_manager import ConfigManager\n    from core.plugin_manager import PluginManager\nexcept ImportError as e:\n    print(f\"Error importing required modules: {e}\")\n    print(\"Please ensure the script is run from the project root or the PYTHONPATH is set correctly.\")\n\nclass PluginDiagnostic:\n    \"\"\"Diagnostic tool for plugin system checks\"\"\"\n    \n    def __init__(self, config_path='data/config.json'):\n        \"\"\"Initialize the plugin diagnostic module\"\"\"\n        self.config_path = config_path\n        self.results = {}\n        \n        # Try to initialize config manager\n        try:\n            self.config_manager = ConfigManager(config_path)\n            self.config_loaded = True\n            \n            # Get plugin directory\n            self.plugin_dir = self.config_manager.get(\"plugins\", {}).get(\"plugin_directory\", \"plugins\")\n            if not os.path.isabs(self.plugin_dir):\n                self.plugin_dir = os.path.join(project_root, self.plugin_dir)\n                \n            # Get enabled plugins\n            self.enabled_plugins = self.config_manager.get(\"plugins\", {}).get(\"enabled_plugins\", [])\n            \n        except Exception as e:\n            self.config_loaded = False\n            self.plugin_dir = os.path.join(project_root, \"plugins\")\n            self.enabled_plugins = []\n            print(f\"Error loading configuration: {e}\")\n        \n        # Try to initialize plugin manager but don't activate plugins\n        try:\n            self.plugin_manager = PluginManager(self.config_manager)\n            self.plugin_manager_loaded = True\n        except Exception:\n            self.plugin_manager_loaded = False\n        \n    def log(self, message):\n        \"\"\"Simple print-based logging for diagnostics\"\"\"\n        print(f\"[PLUGIN DIAG] {message}\")\n    \n    def check_plugin_directory(self):\n        \"\"\"Check if the plugin directory exists and is accessible\"\"\"\n        self.log(f\"Checking plugin directory: {self.plugin_dir}\")\n        \n        if os.path.exists(self.plugin_dir):\n            if os.path.isdir(self.plugin_dir):\n                if os.access(self.plugin_dir, os.R_OK):\n                    self.results['plugin_directory'] = {\n                        'status': 'Success',\n                        'message': f\"Plugin directory exists and is readable: {self.plugin_dir}\"\n                    }\n                    self.log(\"Plugin directory exists and is readable\")\n                    return True\n                else:\n                    self.results['plugin_directory'] = {\n                        'status': 'Failure',\n                        'message': f\"Plugin directory is not readable: {self.plugin_dir}\"\n                    }\n                    self.log(\"Plugin directory is not readable\")\n                    return False\n            else:\n                self.results['plugin_directory'] = {\n                    'status': 'Failure',\n                    'message': f\"Plugin directory path exists but is not a directory: {self.plugin_dir}\"\n                }\n                self.log(\"Plugin directory path is not a directory\")\n                return False\n        else:\n            self.results['plugin_directory'] = {\n                'status': 'Failure',\n                'message': f\"Plugin directory does not exist: {self.plugin_dir}\"\n            }\n            self.log(\"Plugin directory does not exist\")\n            return False\n    \n    def discover_plugins(self):\n        \"\"\"Discover available plugins in the plugin directory\"\"\"\n        if not self.check_plugin_directory():\n            self.results['plugin_discovery'] = {\n                'status': 'Skipped',\n                'message': 'Plugin directory not accessible'\n            }\n            self.log(\"Skipping plugin discovery - directory not accessible\")\n            return False, []\n            \n        self.log(\"Discovering plugins...\")\n        \n        discovered_plugins = []\n        \n        # Explore subdirectories in plugin dir\n        try:\n            for item in os.listdir(self.plugin_dir):\n                plugin_path = os.path.join(self.plugin_dir, item)\n                \n                # Check if it's a directory\n                if os.path.isdir(plugin_path):\n                    # Check if it has a plugin.json or manifest.json file\n                    manifest_path = None\n                    for manifest_name in [\"plugin.json\", \"manifest.json\"]:\n                        potential_path = os.path.join(plugin_path, manifest_name)\n                        if os.path.exists(potential_path) and os.path.isfile(potential_path):\n                            manifest_path = potential_path\n                            break\n                            \n                    if manifest_path:\n                        # Plugin found\n                        discovered_plugins.append({\n                            'name': item,\n                            'path': plugin_path,\n                            'manifest_path': manifest_path\n                        })\n            \n            if discovered_plugins:\n                self.results['plugin_discovery'] = {\n                    'status': 'Success',\n                    'message': f\"Discovered {len(discovered_plugins)} plugins\",\n                    'plugins': [p['name'] for p in discovered_plugins]\n                }\n                self.log(f\"Discovered {len(discovered_plugins)} plugins\")\n                return True, discovered_plugins\n            else:\n                self.results['plugin_discovery'] = {\n                    'status': 'Warning',\n                    'message': f\"No plugins found in directory: {self.plugin_dir}\"\n                }\n                self.log(\"No plugins found\")\n                return True, []\n        except Exception as e:\n            self.results['plugin_discovery'] = {\n                'status': 'Failure',\n                'message': f\"Error discovering plugins: {e}\"\n            }\n            self.log(f\"Error discovering plugins: {e}\")\n            return False, []\n    \n    def check_plugin_manifests(self):\n        \"\"\"Check plugin manifest files for validity\"\"\"\n        success, discovered_plugins = self.discover_plugins()\n        if not success or not discovered_plugins:\n            self.results['plugin_manifests'] = {\n                'status': 'Skipped',\n                'message': 'Plugin discovery failed or no plugins found'\n            }\n            self.log(\"Skipping manifest check - no plugins discovered\")\n            return False\n            \n        self.log(\"Checking plugin manifests...\")\n        \n        manifest_results = {}\n        invalid_count = 0\n        \n        for plugin in discovered_plugins:\n            plugin_name = plugin['name']\n            manifest_path = plugin['manifest_path']\n            \n            try:\n                # Read and parse manifest\n                with open(manifest_path, 'r') as f:\n                    manifest = json.load(f)\n                    \n                # Check required fields\n                required_fields = [\"name\", \"version\", \"description\", \"main\"]\n                missing_fields = [field for field in required_fields if field not in manifest]\n                \n                if missing_fields:\n                    invalid_count += 1\n                    manifest_results[plugin_name] = {\n                        'status': 'Failure',\n                        'message': f\"Missing required fields in manifest: {', '.join(missing_fields)}\"\n                    }\n                else:\n                    # Additional validation\n                    issues = []\n                    \n                    # Check if main module exists\n                    main_module = manifest.get(\"main\")\n                    if main_module:\n                        main_path = os.path.join(plugin['path'], main_module)\n                        if not os.path.exists(main_path):\n                            issues.append(f\"Main module file not found: {main_module}\")\n                    \n                    # Check dependencies if present\n                    if \"dependencies\" in manifest:\n                        dependencies = manifest[\"dependencies\"]\n                        if not isinstance(dependencies, list) and not isinstance(dependencies, dict):\n                            issues.append(\"Dependencies must be a list or dictionary\")\n                            \n                    if issues:\n                        invalid_count += 1\n                        manifest_results[plugin_name] = {\n                            'status': 'Warning',\n                            'message': f\"Manifest validation issues: {', '.join(issues)}\"\n                        }\n                    else:\n                        manifest_results[plugin_name] = {\n                            'status': 'Success',\n                            'message': \"Manifest is valid\"\n                        }\n            except json.JSONDecodeError as e:\n                invalid_count += 1\n                manifest_results[plugin_name] = {\n                    'status': 'Failure',\n                    'message': f\"Invalid JSON in manifest: {e}\"\n                }\n            except Exception as e:\n                invalid_count += 1\n                manifest_results[plugin_name] = {\n                    'status': 'Failure',\n                    'message': f\"Error checking manifest: {e}\"\n                }\n        \n        # Determine overall status\n        if invalid_count == 0:\n            status = 'Success'\n            message = f\"All {len(discovered_plugins)} plugin manifests are valid\"\n        elif invalid_count == len(discovered_plugins):\n            status = 'Failure'\n            message = f\"All {len(discovered_plugins)} plugin manifests are invalid\"\n        else:\n            status = 'Warning'\n            message = f\"{invalid_count} of {len(discovered_plugins)} plugin manifests have issues\"\n        \n        self.results['plugin_manifests'] = {\n            'status': status,\n            'message': message,\n            'details': manifest_results\n        }\n        self.log(f\"Plugin manifest check: {status} ({invalid_count} issues found)\")\n        return status != 'Failure'\n    \n    def check_plugin_dependencies(self):\n        \"\"\"Check plugin dependencies for conflicts or missing packages\"\"\"\n        if not self.plugin_manager_loaded:\n            self.results['plugin_dependencies'] = {\n                'status': 'Skipped',\n                'message': 'Plugin manager not initialized'\n            }\n            self.log(\"Skipping dependency check - plugin manager not initialized\")\n            return False\n            \n        self.log(\"Checking plugin dependencies...\")\n\n        success, discovered_plugins = self.discover_plugins()\n        if not success or not discovered_plugins:\n            self.results['plugin_dependencies'] = {\n                'status': 'Skipped',\n                'message': 'Plugin discovery failed or no plugins found'\n            }\n            self.log(\"Skipping dependency check - no plugins discovered\")\n            return False\n        \n        dependency_issues = {}\n        \n        for plugin in discovered_plugins:\n            plugin_name = plugin['name']\n            manifest_path = plugin['manifest_path']\n            \n            try:\n                # Read and parse manifest\n                with open(manifest_path, 'r') as f:\n                    manifest = json.load(f)\n                \n                # Check dependencies if present\n                if \"dependencies\" in manifest:\n                    dependencies = manifest[\"dependencies\"]\n                    issues = []\n                    \n                    # Check Python package dependencies\n                    if isinstance(dependencies, dict) and \"python\" in dependencies:\n                        python_deps = dependencies[\"python\"]\n                        for package in python_deps:\n                            try:\n                                # Try to import the package\n                                importlib.import_module(package.split('>=')[0].split('==')[0].strip())\n                            except ImportError:\n                                issues.append(f\"Missing Python package: {package}\")\n                    \n                    # Check plugin dependencies\n                    if isinstance(dependencies, list) or (isinstance(dependencies, dict) and \"plugins\" in dependencies):\n                        plugin_deps = dependencies if isinstance(dependencies, list) else dependencies[\"plugins\"]\n                        discovered_names = [p['name'] for p in discovered_plugins]\n                        \n                        for dep in plugin_deps:\n                            if dep not in discovered_names:\n                                issues.append(f\"Missing plugin dependency: {dep}\")\n                    \n                    if issues:\n                        dependency_issues[plugin_name] = {\n                            'status': 'Warning',\n                            'message': f\"Dependency issues: {', '.join(issues)}\"\n                        }\n            except Exception as e:\n                dependency_issues[plugin_name] = {\n                    'status': 'Failure',\n                    'message': f\"Error checking dependencies: {e}\"\n                }\n        \n        # Determine overall status\n        if not dependency_issues:\n            self.results['plugin_dependencies'] = {\n                'status': 'Success',\n                'message': f\"All plugin dependencies are satisfied\"\n            }\n            self.log(\"All plugin dependencies are satisfied\")\n            return True\n        else:\n            self.results['plugin_dependencies'] = {\n                'status': 'Warning',\n                'message': f\"{len(dependency_issues)} plugins have dependency issues\",\n                'details': dependency_issues\n            }\n            self.log(f\"Found dependency issues in {len(dependency_issues)} plugins\")\n            return False\n    \n    def check_plugin_initialization(self):\n        \"\"\"Check if plugins can be initialized without errors\"\"\"\n        if not self.plugin_manager_loaded:\n            self.results['plugin_initialization'] = {\n                'status': 'Skipped',\n                'message': 'Plugin manager not initialized'\n            }\n            self.log(\"Skipping initialization check - plugin manager not initialized\")\n            return False\n            \n        self.log(\"Checking plugin initialization...\")\n        \n        # We'll test initialization for enabled plugins only for safety\n        if not self.enabled_plugins:\n            self.results['plugin_initialization'] = {\n                'status': 'Skipped',\n                'message': 'No plugins are enabled in configuration'\n            }\n            self.log(\"No plugins enabled - skipping initialization test\")\n            return True\n        \n        # Instead of actually loading plugins which could have side effects,\n        # we'll just verify that the plugin's main module can be imported\n        init_results = {}\n        init_failures = 0\n        \n        success, discovered_plugins = self.discover_plugins()\n        enabled_plugin_info = [p for p in discovered_plugins if p['name'] in self.enabled_plugins]\n        \n        for plugin in enabled_plugin_info:\n            plugin_name = plugin['name']\n            plugin_path = plugin['path']\n            manifest_path = plugin['manifest_path']\n            \n            try:\n                # Read manifest to get main module\n                with open(manifest_path, 'r') as f:\n                    manifest = json.load(f)\n                \n                main_module = manifest.get(\"main\")\n                if not main_module:\n                    init_results[plugin_name] = {\n                        'status': 'Failure',\n                        'message': \"No main module specified in manifest\"\n                    }\n                    init_failures += 1\n                    continue\n                    \n                # Check if main module exists\n                main_path = os.path.join(plugin_path, main_module)\n                if not os.path.exists(main_path):\n                    init_results[plugin_name] = {\n                        'status': 'Failure',\n                        'message': f\"Main module file not found: {main_module}\"\n                    }\n                    init_failures += 1\n                    continue\n                \n                # Try to import the module (without executing it)\n                spec = importlib.util.spec_from_file_location(f\"{plugin_name}.main\", main_path)\n                if not spec:\n                    init_results[plugin_name] = {\n                        'status': 'Failure',\n                        'message': f\"Could not create module spec from {main_path}\"\n                    }\n                    init_failures += 1\n                    continue\n                    \n                module = importlib.util.module_from_spec(spec)\n                # We don't execute the module to avoid side effects\n                # spec.loader.exec_module(module)\n                \n                init_results[plugin_name] = {\n                    'status': 'Success',\n                    'message': f\"Plugin module can be imported\"\n                }\n                \n            except Exception as e:\n                init_results[plugin_name] = {\n                    'status': 'Failure',\n                    'message': f\"Error during initialization check: {e}\"\n                }\n                init_failures += 1\n        \n        # Determine overall status\n        if not enabled_plugin_info:\n            self.results['plugin_initialization'] = {\n                'status': 'Warning',\n                'message': 'Enabled plugins not found in plugin directory'\n            }\n            self.log(\"Enabled plugins not found\")\n            return False\n        elif init_failures == 0:\n            self.results['plugin_initialization'] = {\n                'status': 'Success',\n                'message': f\"All {len(enabled_plugin_info)} enabled plugins passed initialization check\"\n            }\n            self.log(\"All enabled plugins passed initialization check\")\n            return True\n        elif init_failures == len(enabled_plugin_info):\n            self.results['plugin_initialization'] = {\n                'status': 'Failure',\n                'message': f\"All {len(enabled_plugin_info)} enabled plugins failed initialization check\",\n                'details': init_results\n            }\n            self.log(\"All enabled plugins failed initialization check\")\n            return False\n        else:\n            self.results['plugin_initialization'] = {\n                'status': 'Warning',\n                'message': f\"{init_failures} of {len(enabled_plugin_info)} enabled plugins failed initialization check\",\n                'details': init_results\n            }\n            self.log(f\"{init_failures} plugins failed initialization check\")\n            return False\n    \n    def check_plugin_configuration(self):\n        \"\"\"Check if plugins have proper configuration settings\"\"\"\n        if not self.config_loaded:\n            self.results['plugin_configuration'] = {\n                'status': 'Skipped',\n                'message': 'Configuration manager not initialized'\n            }\n            self.log(\"Skipping configuration check - config not loaded\")\n            return False\n        \n        self.log(\"Checking plugin configuration...\")\n        \n        # Check if plugins section exists in config\n        plugins_config = self.config_manager.get(\"plugins\", {})\n        if not plugins_config:\n            self.results['plugin_configuration'] = {\n                'status': 'Warning',\n                'message': 'Plugins section missing from configuration'\n            }\n            self.log(\"Plugins section missing from configuration\")\n            return False\n            \n        # Check for plugin_directory setting\n        if \"plugin_directory\" not in plugins_config:\n            self.results['plugin_configuration'] = {\n                'status': 'Warning',\n                'message': 'Plugin directory not specified in configuration'\n            }\n            self.log(\"Plugin directory not specified in configuration\")\n            return False\n            \n        # Check if plugin_settings section exists for enabled plugins\n        plugin_settings = plugins_config.get(\"plugin_settings\", {})\n        missing_settings = []\n        \n        for plugin_name in self.enabled_plugins:\n            if plugin_name not in plugin_settings:\n                missing_settings.append(plugin_name)\n        \n        if missing_settings:\n            self.results['plugin_configuration'] = {\n                'status': 'Warning',\n                'message': f\"Configuration missing for plugins: {', '.join(missing_settings)}\"\n            }\n            self.log(f\"Configuration missing for {len(missing_settings)} plugins\")\n            return False\n        else:\n            self.results['plugin_configuration'] = {\n                'status': 'Success',\n                'message': 'All enabled plugins have configuration settings'\n            }\n            self.log(\"All enabled plugins have configuration settings\")\n            return True\n    \n    def run_all_checks(self):\n        \"\"\"Run all plugin diagnostic checks\"\"\"\n        self.log(\"Starting plugin diagnostics...\")\n        start_time = time.time()\n        \n        # Run checks\n        self.check_plugin_directory()\n        self.check_plugin_manifests()\n        self.check_plugin_dependencies()\n        self.check_plugin_initialization()\n        self.check_plugin_configuration()\n        \n        elapsed_time = time.time() - start_time\n        self.log(f\"Plugin diagnostics completed in {elapsed_time:.2f} seconds\")\n        return self.results\n",
  "D:\\AI\\IrintAI Assistant\\core\\__init__.py": "from core.model_manager import ModelManager\nfrom core.chat_engine import ChatEngine\nfrom core.memory_system import MemorySystem\nfrom core.config_manager import ConfigManager\nfrom core.plugin_manager import PluginManager\nfrom core.plugin_sdk import PluginSDK\n\n__all__ = [\n    'ModelManager',\n    'ChatEngine',\n    'MemorySystem',\n    'ConfigManager',\n    'PluginManager',\n    'PluginSDK']",
  "D:\\AI\\IrintAI Assistant\\plugins\\personality_plugin\\core\\helpers.py": "\"\"\"\nHelper functions for the Personality Plugin\n\"\"\"\nimport json\nimport os\nimport time\nfrom typing import Dict, Any, List, Optional\n\ndef load_default_profiles() -> Dict[str, Any]:\n    \"\"\"\n    Load default personality profiles from resources\n    \n    Returns:\n        Dictionary of default profiles\n    \"\"\"\n    # Try to load from resources file\n    resource_path = os.path.join(\n        os.path.dirname(__file__),\n        \"..\",\n        \"resources\",\n        \"default_profiles.json\"\n    )\n    \n    if os.path.exists(resource_path):\n        try:\n            with open(resource_path, 'r', encoding='utf-8') as f:\n                return json.load(f)\n        except Exception:\n            pass\n    \n    # Fallback to hardcoded defaults\n    return {\n        \"Standard\": {\n            \"name\": \"Standard\",\n            \"description\": \"Default balanced and neutral communication style\",\n            \"tags\": [\"neutral\", \"balanced\", \"professional\"],\n            \"author\": \"Irintai\",\n            \"version\": \"1.0.0\",\n            \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"prefix\": \"\",\n            \"suffix\": \"\",\n            \"style_modifiers\": {\n                \"formality\": 0.5,\n                \"creativity\": 0.5,\n                \"complexity\": 0.5,\n                \"empathy\": 0.5,\n                \"directness\": 0.5\n            },\n            \"formatting\": {\n                \"emphasize_key_points\": False,\n                \"use_markdown\": True,\n                \"paragraph_structure\": \"standard\"\n            }\n        },\n        # [Include other default profiles]\n    }\n\ndef get_profile_metadata(profile: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Extract metadata from a profile\n    \n    Args:\n        profile: Profile data\n        \n    Returns:\n        Dictionary with profile metadata\n    \"\"\"\n    return {\n        \"name\": profile.get(\"name\", \"Unknown\"),\n        \"description\": profile.get(\"description\", \"\"),\n        \"tags\": profile.get(\"tags\", []),\n        \"author\": profile.get(\"author\", \"Unknown\"),\n        \"version\": profile.get(\"version\", \"1.0.0\"),\n        \"created\": profile.get(\"created\", \"\")\n    }\n\ndef validate_profile(profile: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Validate a profile and ensure it has all required fields\n    \n    Args:\n        profile: Profile data to validate\n        \n    Returns:\n        Dictionary with validation results\n    \"\"\"\n    result = {\"valid\": True, \"errors\": [], \"warnings\": []}\n    \n    # Required fields\n    required_fields = [\"name\", \"description\"]\n    for field in required_fields:\n        if field not in profile:\n            result[\"valid\"] = False\n            result[\"errors\"].append(f\"Missing required field: {field}\")\n    \n    # Check style modifiers\n    style_modifiers = profile.get(\"style_modifiers\", {})\n    if not isinstance(style_modifiers, dict):\n        result[\"valid\"] = False\n        result[\"errors\"].append(\"style_modifiers must be a dictionary\")\n    else:\n        # Validate modifier values are between 0 and 1\n        for mod_name, mod_value in style_modifiers.items():\n            if not isinstance(mod_value, (int, float)) or mod_value < 0 or mod_value > 1:\n                result[\"warnings\"].append(f\"Style modifier '{mod_name}' should be between 0 and 1\")\n    \n    # Check for formatting settings\n    if \"formatting\" in profile and not isinstance(profile[\"formatting\"], dict):\n        result[\"warnings\"].append(\"formatting should be a dictionary\")\n    \n    return result\n\ndef merge_profiles(base_profile: Dict[str, Any], overlay_profile: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Merge two profiles, with overlay values taking precedence\n    \n    Args:\n        base_profile: Base profile to start with\n        overlay_profile: Profile whose values will override the base\n        \n    Returns:\n        New merged profile\n    \"\"\"\n    # Create a deep copy of the base profile\n    merged = base_profile.copy()\n    \n    # Merge top-level fields, excluding nested dictionaries\n    for key, value in overlay_profile.items():\n        if key not in merged or not isinstance(value, dict):\n            merged[key] = value\n    \n    # Merge style modifiers\n    base_modifiers = merged.get(\"style_modifiers\", {})\n    overlay_modifiers = overlay_profile.get(\"style_modifiers\", {})\n    merged[\"style_modifiers\"] = {**base_modifiers, **overlay_modifiers}\n    \n    # Merge formatting settings\n    base_formatting = merged.get(\"formatting\", {})\n    overlay_formatting = overlay_profile.get(\"formatting\", {})\n    merged[\"formatting\"] = {**base_formatting, **overlay_formatting}\n    \n    # Update metadata\n    merged[\"name\"] = overlay_profile.get(\"name\", merged.get(\"name\", \"Merged Profile\"))\n    merged[\"description\"] = overlay_profile.get(\"description\", merged.get(\"description\", \"\"))\n    \n    # Add merge metadata\n    merged[\"merged_from\"] = [\n        base_profile.get(\"name\", \"Unknown\"),\n        overlay_profile.get(\"name\", \"Unknown\")\n    ]\n    merged[\"version\"] = overlay_profile.get(\"version\", \"1.0.0\")\n    merged[\"created\"] = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n    \n    return merged\n\ndef calculate_style_vector(profile: Dict[str, Any]) -> List[float]:\n    \"\"\"\n    Calculate a numerical vector representation of a profile's style\n    \n    Args:\n        profile: Personality profile\n        \n    Returns:\n        List of normalized values representing the style\n    \"\"\"\n    # Standard style dimensions in a consistent order\n    dimensions = [\n        \"formality\", \"creativity\", \"complexity\", \n        \"empathy\", \"directness\", \"humor\", \n        \"enthusiasm\", \"conciseness\"\n    ]\n    \n    # Get style modifiers or empty dict if not present\n    style_modifiers = profile.get(\"style_modifiers\", {})\n    \n    # Create vector with default value of 0.5 for missing dimensions\n    vector = [style_modifiers.get(dim, 0.5) for dim in dimensions]\n    \n    return vector\n\ndef apply_style_transforms(text: str, profile: Dict[str, Any]) -> str:\n    \"\"\"\n    Apply style transformations to text based on profile settings\n    \n    Args:\n        text: Input text to transform\n        profile: Personality profile with transformation rules\n        \n    Returns:\n        Transformed text\n    \"\"\"\n    if not text or not profile:\n        return text\n        \n    result = text\n    \n    # Apply prefix/suffix\n    prefix = profile.get(\"prefix\", \"\")\n    suffix = profile.get(\"suffix\", \"\")\n    \n    if prefix:\n        result = prefix + result\n    if suffix:\n        result = result + suffix\n    \n    # Apply text replacements\n    replacements = profile.get(\"text_replacements\", {})\n    for original, replacement in replacements.items():\n        result = result.replace(original, replacement)\n    \n    # Apply formatting\n    formatting = profile.get(\"formatting\", {})\n    \n    # Emphasize key points if enabled\n    if formatting.get(\"emphasize_key_points\", False):\n        # Simple heuristic: look for sentences with important-sounding phrases\n        import re\n        for phrase in [\"important\", \"key\", \"critical\", \"essential\", \"crucial\"]:\n            pattern = re.compile(f\"([^.!?]*{phrase}[^.!?]*[.!?])\", re.IGNORECASE)\n            result = pattern.sub(r\"**\\1**\", result)\n    \n    # Convert to markdown if enabled and not already markdown\n    if formatting.get(\"use_markdown\", True) and \"```\" not in result and \"**\" not in result:\n        # Simple conversion: add some basic markdown formatting\n        # This is simplified and would need more sophisticated logic in a real implementation\n        import re\n        \n        # Add headers for sections that appear to be headings\n        result = re.sub(r\"(?m)^([A-Z][A-Za-z\\s]+):\\s*$\", r\"## \\1\", result)\n        \n        # Add bullet points for lists (lines starting with - or *)\n        result = re.sub(r\"(?m)^(\\s*)[\u2022-]\\s+\", r\"\\1* \", result)\n        \n    return result\n\ndef find_similar_profiles(query: str, profiles: Dict[str, Any], \n                          max_results: int = 3) -> List[str]:\n    \"\"\"\n    Find profiles similar to a query string\n    \n    Args:\n        query: Search query\n        profiles: Dictionary of available profiles\n        max_results: Maximum number of results to return\n        \n    Returns:\n        List of profile names sorted by relevance\n    \"\"\"\n    if not query or not profiles:\n        return []\n        \n    # Calculate relevance scores for each profile\n    scores = []\n    query = query.lower()\n    \n    for name, profile in profiles.items():\n        score = 0\n        \n        # Check name match\n        if query in name.lower():\n            score += 10\n        \n        # Check description match\n        description = profile.get(\"description\", \"\").lower()\n        if query in description:\n            score += 5\n        \n        # Check tag matches\n        for tag in profile.get(\"tags\", []):\n            if query in tag.lower():\n                score += 3\n        \n        # Only include profiles with non-zero scores\n        if score > 0:\n            scores.append((name, score))\n    \n    # Sort by score (descending) and take top results\n    scores.sort(key=lambda x: x[1], reverse=True)\n    return [name for name, score in scores[:max_results]]\n\ndef export_profile_to_file(profile: Dict[str, Any], file_path: str) -> bool:\n    \"\"\"\n    Export a profile to a JSON file\n    \n    Args:\n        profile: Profile data to export\n        file_path: Path to save the file\n        \n    Returns:\n        True if successful, False otherwise\n    \"\"\"\n    try:\n        # Create directory if it doesn't exist\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        \n        # Save to file with pretty formatting\n        with open(file_path, 'w', encoding='utf-8') as f:\n            json.dump(profile, f, indent=2)\n            \n        return True\n    except Exception as e:\n        print(f\"Error exporting profile: {e}\")\n        return False\n\ndef import_profile_from_file(file_path: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Import a profile from a JSON file\n    \n    Args:\n        file_path: Path to the profile file\n        \n    Returns:\n        Profile data or None if import failed\n    \"\"\"\n    if not os.path.exists(file_path):\n        return None\n        \n    try:\n        with open(file_path, 'r', encoding='utf-8') as f:\n            profile = json.load(f)\n            \n        # Validate the imported profile\n        validation = validate_profile(profile)\n        if not validation[\"valid\"]:\n            print(f\"Invalid profile: {', '.join(validation['errors'])}\")\n            return None\n            \n        return profile\n    except Exception as e:\n        print(f\"Error importing profile: {e}\")\n        return None\n\ndef create_empty_profile(name: str = \"New Profile\") -> Dict[str, Any]:\n    \"\"\"\n    Create a new empty profile template\n    \n    Args:\n        name: Name for the new profile\n        \n    Returns:\n        Dictionary with empty profile structure\n    \"\"\"\n    return {\n        \"name\": name,\n        \"description\": \"Custom personality profile\",\n        \"tags\": [\"custom\"],\n        \"author\": \"User\",\n        \"version\": \"1.0.0\",\n        \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        \"prefix\": \"\",\n        \"suffix\": \"\",\n        \"style_modifiers\": {\n            \"formality\": 0.5,\n            \"creativity\": 0.5,\n            \"complexity\": 0.5,\n            \"empathy\": 0.5,\n            \"directness\": 0.5,\n            \"humor\": 0.5,\n            \"enthusiasm\": 0.5,\n            \"conciseness\": 0.5\n        },\n        \"formatting\": {\n            \"emphasize_key_points\": False,\n            \"use_markdown\": True,\n            \"paragraph_structure\": \"standard\"\n        },\n        \"text_replacements\": {}\n    }",
  "D:\\AI\\IrintAI Assistant\\core\\model_manager.py": "\"\"\"\nModel Manager - Handles all interactions with Ollama models\n\"\"\"\nimport os\nimport json\nimport subprocess\nimport threading\nimport re\nimport time\nfrom typing import Dict, List, Optional, Callable, Tuple, Any\nimport shutil   # Add this if not already imported\n\n# ------------------------------------------------------------------------------\n# At module top you should have something like:\n#\n# RECOMMENDED_MODELS = {\n#     \"llama2\": { \"context\": \"4K\" },\n#     \"gpt4all\": { \"context\": \"8K\" },\n#     ...\n# }\n# MODEL_STATUS = {\n#     \"INSTALLED\": \"installed\",\n#     \"NOT_INSTALLED\": \"not_installed\",\n#     \"OUT_OF_DATE\": \"out_of_date\"\n# }\n# ------------------------------------------------------------------------------\n\n# Regular expression to match ANSI escape sequences\nANSI_ESCAPE_PATTERN = re.compile(r'(\\x1B\\[[0-?]*[ -/]*[@-~]|\\x1B[@-_]|[\\x00-\\x08\\x0B-\\x1F\\x7F])')\n\n# Model status constants\nMODEL_STATUS = {\n    \"NOT_INSTALLED\": \"Not Installed\",\n    \"INSTALLING\": \"Installing...\",\n    \"INSTALLED\": \"Installed\",\n    \"LOADING\": \"Loading...\",\n    \"RUNNING\": \"Running\",\n    \"PROCESSING\": \"Processing...\",\n    \"GENERATING\": \"Generating...\",\n    \"UNINSTALLING\": \"Uninstalling...\",\n    \"ERROR\": \"Error\"\n}\n\n# Recommended models with metadata\nRECOMMENDED_MODELS = {\n    \"deepseek-coder:6.7b\": {\"context\": \"4K\", \"note\": \"Great for code\"},\n    \"starcoder2:7b\": {\"context\": \"16K\", \"note\": \"Strong coder model\"},\n    \"mistral:instruct\": {\"context\": \"8K\", \"note\": \"Balanced assistant\"},\n    \"zephyr:beta\": {\"context\": \"8K\", \"note\": \"Conversational chat\"},\n    \"nous-hermes-llama2-13b\": {\"context\": \"4K\", \"note\": \"Deep thinker, needs 8-bit\"},\n    \"codellama:13b-python\": {\"context\": \"4K\u201316K\", \"note\": \"Strong dev model (8-bit)\"},\n}\n\nclass ModelManager:\n    \"\"\"Manages Ollama models: installation, running, and status tracking\"\"\"\n    \n    def __init__(self, model_path: str, logger: Callable, use_8bit: bool = False, config=None):\n        \"\"\"\n        Initialize the model manager\n        \n        Args:\n            model_path: Path to store Ollama models\n            logger: Logging function\n            use_8bit: Whether to use 8-bit quantization\n            config: Optional configuration manager\n        \"\"\"        \n        self.model_path = model_path\n        self.log = logger\n        self.use_8bit = use_8bit\n        self.config = config\n        self.model_statuses = {}  # Track model status\n        self.current_model = None\n        self.model_process = None\n        self.on_status_changed = None  # Callback for status changes\n        self.current_parameters = {}  # Store current model parameters\n        # Default context size (can be overridden by config)\n        self.context_size = config.get(\"model.context_size\", 4096) if config else 4096\n        \n        # Initialize environment\n        self._update_environment()\n        # Populate available models dynamically\n        self.available_models = [{'name': model} for model in self.detect_models()]\n        \n    def _strip_ansi_codes(self, text: str) -> str:\n        \"\"\"\n        Remove ANSI escape sequences from text\n        \n        Args:\n            text: Input text that may contain ANSI escape sequences\n            \n        Returns:\n            Clean text with escape sequences removed\n        \"\"\"\n        if not text:\n            return \"\"\n        return ANSI_ESCAPE_PATTERN.sub('', text)\n        \n    def _update_environment(self) -> None:\n        \"\"\"Update environment variables for model path\"\"\"\n        try:\n            # Ensure the parent directory path is extracted correctly\n            ollama_home = os.path.dirname(self.model_path)\n            \n            # Set environment variables\n            os.environ[\"OLLAMA_HOME\"] = ollama_home\n            os.environ[\"OLLAMA_MODELS\"] = self.model_path\n            \n            self.log(f\"[Environment] OLLAMA_HOME={ollama_home}, OLLAMA_MODELS={self.model_path}\")\n        except Exception as e:\n            self.log(f\"[Error] Failed to update environment variables: {e}\")\n    \n    def update_model_path(self, new_path: str) -> None:\n        \"\"\"\n        Update the model path and environment variables\n        \n        Args:\n            new_path: New path for model storage\n        \"\"\"\n        if new_path != self.model_path:\n            self.model_path = new_path\n            self._update_environment()\n            \n    def set_callback(self, callback: Callable) -> None:\n        \"\"\"\n        Set callback for status changes\n        \n        Args:\n            callback: Function to call when model status changes\n        \"\"\"\n        self.on_status_changed = callback\n            \n    def _update_model_status(self, model_name: str, status: str) -> None:\n        \"\"\"\n        Update the status of a model\n        \n        Args:\n            model_name: Name of the model\n            status: New status string\n        \"\"\"\n        try:\n            # Update status\n            self.model_statuses[model_name] = status\n            \n            # Call status change callback if set\n            if self.on_status_changed and model_name == self.current_model:\n                self.on_status_changed(model_name, status)\n            \n            # Log the status change\n            self.log(f\"[Model Status] {model_name}: {status}\")\n        except Exception as e:\n            self.log(f\"[Error] Failed to update model status: {e}\")\n            \n    def detect_models(self) -> List[str]:\n        \"\"\"\n        Detect installed models\n        Returns:\n            List of installed model names\n        \"\"\"\n        self.log(\"[Checking] Looking for installed models...\")\n        # Early exit if Ollama is not installed or not in PATH\n        if shutil.which(\"ollama\") is None:\n            self.log(\"[Error] Ollama executable not found. Please install Ollama and ensure it is in your PATH.\")\n            # Mark all recommended models as not installed\n            for model in RECOMMENDED_MODELS:\n                self.model_statuses[model] = MODEL_STATUS[\"NOT_INSTALLED\"]\n            return []\n\n        available_models = []\n        \n        # Retry mechanism\n        max_retries = 3\n        retry_count = 0\n        success = False\n        \n        while retry_count < max_retries and not success:\n            try:\n                # Call ollama list with proper environment\n                env = os.environ.copy()\n                result = subprocess.run(\n                    [\"ollama\", \"list\"],\n                    capture_output=True,\n                    text=True,\n                    encoding='utf-8',\n                    errors='replace',\n                    timeout=10,\n                    env=env\n                )\n                \n                if result.returncode == 0:\n                    for line in result.stdout.strip().splitlines():\n                        if line and not line.startswith(\"NAME\"):  # Skip header\n                            parts = line.split()\n                            if parts:\n                                name = parts[0]\n                                available_models.append(name)\n                                # Mark this model as installed\n                                self.model_statuses[name] = MODEL_STATUS[\"INSTALLED\"]\n                                \n                    self.log(f\"[Found] {len(available_models)} installed models\")\n                    success = True\n                else:\n                    error_msg = result.stderr.strip()\n                    self.log(f\"[Error] ollama list returned: {error_msg}\")\n                    \n                    # Check if Ollama service is not running\n                    if \"connection refused\" in error_msg.lower():\n                        self.log(\"[Warning] Ollama service appears to be offline. Starting retry...\")\n                        time.sleep(2)  # Wait before retry\n                    \n                    retry_count += 1\n            except Exception as e:\n                self.log(f\"[Model Check Error] {e}\")\n                retry_count += 1\n                time.sleep(2)  # Wait before retry\n        \n        # Add recommended models to the status dict\n        for model in RECOMMENDED_MODELS:\n            if model not in self.model_statuses:\n                self.model_statuses[model] = MODEL_STATUS[\"NOT_INSTALLED\"]\n        \n        return available_models\n    \n    def fetch_available_models(self) -> List[Dict]:\n        \"\"\"\n        Fetch remote model list from Ollama\n        Returns:\n            List of model dicts with metadata\n        \"\"\"\n        self.log(\"[Fetching] Getting model list from Ollama repository...\")\n        # Initialize list to collect models\n        models_list: List[Dict] = []\n        # Early exit if Ollama is not installed or not in PATH\n        if shutil.which(\"ollama\") is None:\n            self.log(\"[Error] Ollama executable not found. Please install Ollama and ensure it is in your PATH.\")\n            # Return only recommended models\n            for name, meta in RECOMMENDED_MODELS.items():\n                models_list.append({\n                    \"name\": name,\n                    \"size\": meta.get(\"context\", \"Unknown\"),\n                    \"installed\": False,\n                    \"recommended\": True\n                })\n            return models_list\n\n        try:\n            # First get locally installed models\n            try:\n                result = subprocess.run(\n                    [\"ollama\", \"list\"],\n                    capture_output=True,\n                    text=True,\n                    encoding='utf-8',\n                    errors='replace',\n                    timeout=5,\n                    env=os.environ.copy()\n                )\n                \n                if result.returncode == 0:\n                    # Skip header\n                    for line in result.stdout.strip().splitlines()[1:]:\n                        if line.strip():\n                            parts = line.split()\n                            if parts:\n                                name = parts[0]\n                                size = parts[1] if len(parts) > 1 else \"Unknown\"\n                                models_list.append({\n                                    \"name\": name,\n                                    \"size\": size,\n                                    \"installed\": True\n                                })\n                else:\n                    self.log(f\"[Error] ollama list command failed: {result.stderr}\")\n            except Exception as e:\n                self.log(f\"[Error] Failed to get installed models: {e}\")\n              # Try to get Ollama version using \"--version\" flag (for Ollama 0.6.5+)\n            supports_all_flag = False\n            version_text = \"0.6.5\"  # Default to your known version\n            \n            try:\n                # First try the newer \"--version\" flag (Ollama 0.6.5+)\n                version_result = subprocess.run(\n                    [\"ollama\", \"--version\"],\n                    capture_output=True,\n                    text=True,\n                    encoding='utf-8',\n                    errors='replace',\n                    timeout=5\n                )\n                \n                if version_result.returncode == 0 and version_result.stdout.strip():\n                    version_text = version_result.stdout.strip()\n                    self.log(f\"[Ollama Version] {version_text} (using --version flag)\")\n                    supports_all_flag = True\n                else:\n                    # Fall back to \"version\" command (some versions)\n                    version_result = subprocess.run(\n                        [\"ollama\", \"version\"],\n                        capture_output=True,\n                        text=True,\n                        encoding='utf-8',\n                        errors='replace',\n                        timeout=5\n                    )\n                    \n                    if version_result.returncode == 0:\n                        version_text = version_result.stdout.strip()\n                        self.log(f\"[Ollama Version] {version_text} (using version command)\")\n                        supports_all_flag = True\n                    else:\n                        self.log(f\"[Ollama Version] Assuming version 0.6.5 (version check failed)\")\n            except Exception as e:\n                self.log(f\"[Warning] Could not determine Ollama version: {e}\")\n            \n            # Use commands appropriate for Ollama 0.6.5+\n            commands_to_try = [\n                [\"ollama\", \"list\", \"remote\"]  # This works in 0.6.5\n            ]\n            \n            success = False\n            \n            for cmd in commands_to_try:\n                if success:\n                    break\n                    \n                try:\n                    self.log(f\"[Fetching] Trying: {' '.join(cmd)}\")\n                    repo_result = subprocess.run(\n                        cmd,\n                        capture_output=True,\n                        text=True,\n                        encoding='utf-8',\n                        errors='replace',\n                        timeout=10,\n                        env=os.environ.copy()\n                    )\n                    \n                    if repo_result.returncode == 0:\n                        # Skip header\n                        for line in repo_result.stdout.strip().splitlines()[1:]:\n                            if line.strip():\n                                parts = line.split()\n                                if parts and len(parts) >= 2:\n                                    name = parts[0]\n                                    \n                                    # Check if already in our list (installed)\n                                    already_installed = any(m[\"name\"] == name for m in models_list)\n                                    \n                                    if not already_installed:\n                                        models_list.append({\n                                            \"name\": name,\n                                            \"size\": \"Remote\",\n                                            \"installed\": False\n                                        })\n                        success = True\n                    else:\n                        self.log(f\"[Warning] Command failed: {' '.join(cmd)}: {repo_result.stderr}\")\n                except Exception as e:\n                    self.log(f\"[Warning] Error with command {' '.join(cmd)}: {e}\")\n            \n            if not success:\n                self.log(\"[Warning] Could not fetch remote models with any command\")\n                    \n            # Add recommended models if not in the list\n            for model_name in RECOMMENDED_MODELS:\n                if not any(m[\"name\"] == model_name for m in models_list):\n                    models_list.append({\n                        \"name\": model_name,\n                        \"size\": \"Unknown\",\n                        \"installed\": False,\n                        \"recommended\": True\n                    })\n            \n            return models_list\n            \n        except Exception as e:\n            self.log(f\"[Error] Failed to fetch models: {e}\")\n            return []\n\n    def install_model(self, model: str, progress_callback: Optional[Callable] = None) -> None:\n        \"\"\"\n        Install a model\n        \n        Args:\n            model: Name of the model to install\n            progress_callback: Optional callback for installation progress\n        \"\"\"\n        self.log(f\"[Installing] Starting installation of {model}\")\n        \n        # Update model status\n        self._update_model_status(model, MODEL_STATUS[\"INSTALLING\"])\n        \n        # Start a thread for installation\n        threading.Thread(\n            target=self._install_model_thread,\n            args=(model, progress_callback),\n            daemon=True\n        ).start()\n    \n    def _install_model_thread(self, model: str, progress_callback: Optional[Callable]) -> None:\n        \"\"\"\n        Handle model installation with robust error handling\n        \n        Args:\n            model: Name of the model to install\n            progress_callback: Optional callback for installation progress\n        \"\"\"\n        try:\n            # Use subprocess with universal_newlines=True and encoding set\n            env = os.environ.copy()\n            \n            # Start process with explicit encoding\n            process = subprocess.Popen(\n                [\"ollama\", \"pull\", model],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                universal_newlines=True,\n                encoding='utf-8',\n                errors='replace',\n                bufsize=1,\n                env=env\n            )\n            \n            # Process output with more robust error handling\n            for line in iter(process.stdout.readline, ''):\n                if line.strip():\n                    # Update log safely\n                    safe_line = line.strip().encode('ascii', 'replace').decode('ascii')\n                    self.log(f\"[Install] {safe_line}\")\n                    \n                    # Check for progress \n                    if \"%\" in safe_line and progress_callback:\n                        try:\n                            percent_match = re.search(r'(\\d+(\\.\\d+)?)%', safe_line)\n                            if percent_match:\n                                percent = float(percent_match.group(1))\n                                progress_callback(percent)\n                        except:\n                            pass\n            \n            # Wait for completion\n            return_code = process.wait()\n            \n            # Update status based on result\n            if return_code == 0:\n                self.log(f\"[Installed] {model} successfully installed\")\n                self._update_model_status(model, MODEL_STATUS[\"INSTALLED\"])\n            else:\n                self.log(f\"[Error] Failed to install {model}\")\n                self._update_model_status(model, MODEL_STATUS[\"ERROR\"])\n            \n        except Exception as e:\n            self.log(f\"[Error] Installation failed: {e}\")\n            self._update_model_status(model, MODEL_STATUS[\"ERROR\"])\n    \n    def uninstall_model(self, model: str) -> None:\n        \"\"\"\n        Uninstall a model\n        \n        Args:\n            model: Name of the model to uninstall\n        \"\"\"\n        self.log(f\"[Uninstalling] Starting uninstallation of {model}\")\n        \n        # Update model status\n        self._update_model_status(model, MODEL_STATUS[\"UNINSTALLING\"])\n    \n# Define a proper send_prompt implementation\n    def send_prompt(self, prompt: str, formatter: Callable = None) -> Tuple[bool, str]:\n        \"\"\"\n        Send a prompt to the model and get a response\n        Compatible with Ollama 0.6.5\n        \n        Args:\n            prompt: The prompt to send to the model\n            formatter: Optional function to format the prompt\n            \n        Returns:\n            Tuple of (success, response)\n        \"\"\"\n        try:\n            # Check if we have a current model and if it's running\n            if not self.current_model:\n                self.log(\"[Error] No model is selected\")\n                return False, \"No model is selected. Please start a model first.\"\n            \n            if not self.model_process or self.model_process.poll() is not None:\n                self.log(\"[Error] Model is not running\")\n                return False, \"Model is not running. Please start a model first.\"\n            \n            # Format prompt if formatter is provided\n            formatted_prompt = formatter(prompt) if formatter else prompt\n            \n            # Update status\n            self._update_model_status(self.current_model, \"Generating...\")\n            \n            # Log that we're sending the prompt\n            self.log(f\"[Prompt] Sending prompt to model ({len(formatted_prompt)} chars)\")\n            \n            # This is the key fix: communicate directly with the running model process\n            try:\n                # Write prompt to stdin and flush\n                self.model_process.stdin.write(formatted_prompt + \"\\n\")\n                self.model_process.stdin.flush()\n                \n                # Capture response - Ollama will output the response followed by a prompt marker\n                response = \"\"\n                waiting_for_response = True\n                timeout = time.time() + 60  # 60 second timeout\n                \n                # Read output until we get a response\n                while waiting_for_response and time.time() < timeout:\n                    # Check if process is still alive\n                    if self.model_process.poll() is not None:\n                        self.log(\"[Error] Model process terminated while generating response\")\n                        return False, \"Model process terminated unexpectedly\"\n                        \n                    # Try to read a line of output\n                    line = self.model_process.stdout.readline()\n                    if not line:  # No output available yet\n                        time.sleep(0.1)\n                        continue\n                        \n                    line = line.strip()\n                    if not line:  # Empty line\n                        continue\n                        \n                    # If the line contains the prompt marker, we're done\n                    if \">\" in line or \"\u258c\" in line:\n                        waiting_for_response = False\n                        break\n                        \n                    # Otherwise, add the line to our response\n                    response += line + \"\\n\"\n                    \n                # Check for timeout\n                if waiting_for_response:\n                    self.log(\"[Error] Timed out waiting for response\")\n                    return False, \"Timed out waiting for model response\"\n                    \n                # Update status back to running\n                self._update_model_status(self.current_model, \"Running\")\n                \n                # Log success\n                self.log(f\"[Generate] Successfully received response ({len(response)} chars)\")\n                \n                return True, response.strip()\n                \n            except BrokenPipeError:\n                self.log(\"[Error] Connection to model lost (broken pipe)\")\n                return False, \"Connection to model process lost. Please restart the model.\"\n                \n        except Exception as e:\n            self.log(f\"[Error] Failed to generate response: {e}\")\n            return False, f\"Error: {str(e)}\"\n    \n    def _uninstall_model_thread(self, model: str) -> None:\n        \"\"\"\n        Handle model uninstallation in a separate thread\n        \n        Args:\n            model: Name of the model to uninstall\n        \"\"\"\n        try:\n            # Use subprocess to run ollama rm\n            env = os.environ.copy()\n            env[\"PYTHONIOENCODING\"] = \"utf-8\"\n            threading.Thread(\n            target=self._uninstall_model_thread,\n            args=(model,),\n            daemon=True).start()\n            \n            # Run the command with real-time output\n            process = subprocess.Popen(\n                [\"ollama\", \"rm\", model],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                text=True,\n                bufsize=1,\n                env=env\n            )\n            \n            # Process output in real-time\n            for line in iter(process.stdout.readline, ''):\n                if line.strip():\n                    # Update log\n                    self.log(f\"[Uninstall] {line.strip()}\")\n            \n            # Wait for process to complete\n            return_code = process.wait()\n            \n            # Update status based on result\n            if return_code == 0:\n                self.log(f\"[Uninstalled] {model} successfully uninstalled\")\n                self._update_model_status(model, MODEL_STATUS[\"NOT_INSTALLED\"])\n            else:\n                self.log(f\"[Error] Failed to uninstall {model}\")\n                self._update_model_status(model, MODEL_STATUS[\"ERROR\"])\n            \n        except Exception as e:\n            self.log(f\"[Error] Uninstallation failed: {e}\")\n            self._update_model_status(model, MODEL_STATUS[\"ERROR\"])\n            \n    def verify_model_status(self, model_name: str) -> bool:\n        \"\"\"\n        Verify if a model is installed\n        \n        Args:\n            model_name: Name of the model to check\n            \n        Returns:\n            True if model is installed, False otherwise\n        \"\"\"\n        try:\n            # Check if model exists in filesystem first\n            model_path = os.path.join(self.model_path, model_name)\n            if os.path.exists(model_path) and os.path.isdir(model_path):\n                self._update_model_status(model_name, MODEL_STATUS[\"INSTALLED\"])\n                return True\n            \n            # If not in filesystem, try checking via ollama list\n            result = subprocess.run(\n                [\"ollama\", \"list\"],\n                capture_output=True,\n                text=True,\n                encoding='utf-8',\n                errors='replace',\n                timeout=5,\n                env=os.environ.copy()\n            )\n            \n            if result.returncode == 0:\n                lines = result.stdout.strip().splitlines()\n                for line in lines:\n                    if model_name in line:\n                        self._update_model_status(model_name, MODEL_STATUS[\"INSTALLED\"])\n                        return True\n            \n            # Model doesn't exist\n            self._update_model_status(model_name, MODEL_STATUS[\"NOT_INSTALLED\"])\n            return False\n            \n        except Exception as e:\n            self.log(f\"[Error] Failed to verify model status: {e}\")\n            self._update_model_status(model_name, \"Error checking\")\n            return False\n            \n    def start_model(self, model_name: str, callback: Optional[Callable] = None, model_config: Optional[dict] = None) -> bool:\n        \"\"\"\n        Start running a model\n\n        Args:\n            model_name: Name of the model to start\n            callback: Optional callback for model output\n            model_config: Optional configuration for the model\n\n        Returns:\n            True if model started successfully, False otherwise\n        \"\"\"\n        # Check if a model is already running\n        if self.model_process and self.model_process.poll() is None:\n            self.log(\"[Warning] A model is already running. Please stop it first.\")\n            return False\n\n        # Check if model is installed\n        status = self.model_statuses.get(model_name, MODEL_STATUS[\"NOT_INSTALLED\"])\n\n        if status == MODEL_STATUS[\"NOT_INSTALLED\"]:\n            # Need to install model first\n            self.log(f\"[Error] Model {model_name} needs to be installed first.\")\n            return False\n                \n        # Update status\n        self._update_model_status(model_name, MODEL_STATUS[\"LOADING\"])\n        self.current_model = model_name\n        \n        self.log(f\"[Starting Model] {model_name}{' (8-bit mode)' if self.use_8bit else ''}\")\n        try:\n            # Build the command\n            cmd = [\"ollama\", \"run\", model_name]\n              # Apply model-specific configurations if provided\n            if model_config:\n                # Check for valid Ollama run parameters and filter out any invalid ones\n                valid_ollama_params = [\"temperature\", \"context\", \"threads\", \"gpu\", \"seed\"]\n                \n                # First log all parameters for debugging\n                self.log(f\"[Model Config] Received parameters: {list(model_config.keys())}\")\n                \n                # Only use parameters that are valid for Ollama command line\n                for key, value in model_config.items():\n                    if key in valid_ollama_params:\n                        # Add valid parameter to command\n                        cmd.extend([f\"--{key}\", str(value)])\n                        self.log(f\"[Model Config] Using parameter: {key}={value}\")\n                    else:\n                        self.log(f\"[Warning] Skipping unsupported Ollama parameter: {key}\")\n\n            # Check if 8-bit mode is requested and handle it safely\n            if self.use_8bit:\n                # First check if Ollama version supports the --quantization flag\n                try:\n                    # Get Ollama version\n                    version_result = subprocess.run(\n                        [\"ollama\", \"version\"],\n                        capture_output=True,\n                        text=True,\n                        encoding='utf-8',\n                        errors='replace',\n                        timeout=5\n                    )\n                    \n                    if version_result.returncode == 0:\n                        version_text = version_result.stdout.strip()\n                        self.log(f\"[Ollama Version] {version_text}\")\n                        \n                        # Check if version supports 8-bit quantization\n                        if \"0.1.\" in version_text or any(f\"{i}.\" in version_text for i in range(1, 20)):\n                            # Newer versions support this flag\n                            cmd.append(\"--quantization=8bit\")\n                        else:\n                            self.log(\"[Warning] 8-bit mode requested but your Ollama version may not support it.\")\n                            # Try with f16 instead as a fallback for some versions\n                            cmd.append(\"--f16\")\n                    else:\n                        self.log(\"[Warning] Could not determine Ollama version, skipping quantization flag\")\n                except Exception as e:\n                    self.log(f\"[Error] Failed to check quantization support: {e}\")\n\n            # Create a thread to handle model execution\n            threading.Thread(\n                target=self._run_model_process,\n                args=(cmd, model_name, callback),\n                daemon=True\n            ).start()\n            \n            return True\n        except Exception as e:\n            self.log(f\"[Error] Failed to start model {model_name}: {e}\")\n            self._update_model_status(model_name, \"Error starting\")\n            return False\n        \n    def _run_model_process(self, cmd: List[str], model_name: str, callback: Optional[Callable]) -> None:\n        \"\"\"\n        Run the model process in a separate thread\n        \n        Args:\n            cmd: Command to run\n            model_name: Name of the model being run\n            callback: Optional callback for model output and status changes\n        \"\"\"\n        try:\n            # Create a fresh environment copy\n            env = os.environ.copy()\n            \n            # Start the process\n            self.model_process = subprocess.Popen(\n                cmd,\n                stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                text=True,\n                bufsize=1,\n                env=env\n            )\n            \n            # Update status to show model is running\n            self.log(f\"[Started Model] {model_name}\")\n            self._update_model_status(model_name, MODEL_STATUS[\"RUNNING\"])\n            \n            # Notify callback if provided\n            if callback:\n                callback(\"started\", model_name)\n              # Process output in real-time\n            # Keep a local reference to avoid NoneType errors if model_process is cleared by another thread\n            local_process = self.model_process\n            \n            try:                \n                for line in iter(local_process.stdout.readline, ''):\n                    # Check if the process was terminated\n                    if local_process.poll() is not None:\n                        self.log(\"[Info] Process terminated while reading output\")\n                        break\n                        \n                    if line.strip():\n                        # Clean ANSI escape sequences from output\n                        clean_line = self._strip_ansi_codes(line.strip())\n                        \n                        # Log the clean output\n                        self.log(clean_line)\n                        \n                        # Notify callback if provided\n                        if callback:\n                            callback(\"output\", clean_line)\n            except Exception as read_error:\n                self.log(f\"[Warning] Error while reading process output: {read_error}\")\n            \n            # Check if the process exited unexpectedly (exit code != 0)\n            exit_code = local_process.poll()\n            if exit_code is not None and exit_code != 0:\n                self.log(f\"[Warning] Model process exited unexpectedly with code {exit_code}. Attempting restart.\")\n            \n            # Clear the current process reference\n            self.model_process = None\n            \n            # Attempt to restart up to 3 times\n            for attempt in range(1, 4):\n                self.log(f\"[Auto-Recovery] Attempt {attempt} to restart model {model_name}\")\n                time.sleep(2)  # Give some time before restarting\n                \n                try:\n                    # Create a new process\n                    self.model_process = subprocess.Popen(\n                        cmd,\n                        stdin=subprocess.PIPE,\n                        stdout=subprocess.PIPE,\n                        stderr=subprocess.STDOUT,\n                        text=True,\n                        bufsize=1,\n                        env=env\n                    )\n                    \n                    # Update status\n                    self._update_model_status(model_name, MODEL_STATUS[\"RUNNING\"])\n                    \n                    if callback:\n                        callback(\"restarted\", model_name)\n                        \n                    # Process output from the restarted model\n                    for line in iter(self.model_process.stdout.readline, ''):\n                        if line.strip():\n                            # Log the output\n                            self.log(line.strip())\n                            \n                            # Notify callback if provided\n                            if callback:\n                                callback(\"output\", line.strip())\n                                \n                    # If we get here, the model has stopped again\n                    break\n                    \n                except Exception as restart_error:\n                    self.log(f\"[Error] Restart attempt {attempt} failed: {restart_error}\")\n                    \n                    if attempt == 3:\n                        self.log(\"[Error] Maximum restart attempts reached. Model service appears unstable.\")\n                        # Update the status to error after all attempts fail\n                        self._update_model_status(model_name, MODEL_STATUS[\"ERROR\"])\n                        \n                        # Notify callback if provided\n                        if callback:\n                            callback(\"error\", \"Model service appears unstable after multiple restart attempts\")\n            else:\n                # Normal exit scenario\n                self.log(\"[Model Stopped]\")\n                self._update_model_status(model_name, MODEL_STATUS[\"INSTALLED\"])\n                self.model_process = None\n                \n                # Notify callback if provided\n                if callback:\n                    callback(\"stopped\", model_name)\n            \n        except Exception as e:\n            # Handle errors\n            self.log(f\"[Model Error] {e}\")\n            self._update_model_status(model_name, MODEL_STATUS[\"ERROR\"])\n            self.model_process = None\n            \n            # Notify callback if provided\n            if callback:\n                callback(\"error\", str(e))    \n    \n    def stop_model(self) -> bool:\n        \"\"\"\n        Stop the running model process\n        \n        Returns:\n            True if model stopped successfully, False otherwise\n        \"\"\"\n        # First check if there's any model running\n        if not self.model_process:\n            self.log(\"[Warning] No model is currently running\")\n            return False\n            \n        # Store local references to avoid race conditions\n        model_process = self.model_process\n        current_model = self.current_model\n        \n        # Clear the reference immediately to prevent double-stop attempts\n        self.model_process = None\n        \n        try:\n            # Check if process is still running\n            if model_process.poll() is not None:\n                self.log(\"[Warning] Model process has already exited\")\n                if current_model:\n                    self._update_model_status(current_model, MODEL_STATUS[\"INSTALLED\"])\n                return True\n            \n            # Give the process a chance to close gracefully\n            self.log(\"[Stopping Model] Sending termination signal...\")\n            model_process.terminate()\n            \n            # Update status\n            if current_model:\n                self._update_model_status(current_model, MODEL_STATUS[\"INSTALLED\"])\n            \n            # Wait for up to 5 seconds for clean shutdown\n            start_time = time.time()\n            while model_process.poll() is None and time.time() - start_time < 5:\n                time.sleep(0.1)\n            \n            # If still running, force kill\n            if model_process.poll() is None:\n                self.log(\"[Stopping Model] Force killing process...\")\n                try:\n                    model_process.kill()\n                except Exception as kill_error:\n                    self.log(f\"[Warning] Error during force kill: {kill_error}\")\n                    \n            if current_model:\n                self.log(f\"[Stopped Model] {current_model}\")\n            else:\n                self.log(\"[Stopped Model] Unknown model\")\n                \n            return True\n            \n        except Exception as e:\n            self.log(f\"[Error Stopping Model] {e}\")\n            return False\n            \n    def send_prompt(self, prompt: str, format_function: Callable, timeout: int = 60) -> Tuple[bool, str]:\n        \"\"\"\n        Send a prompt to the running model\n        \n        Args:\n            prompt: Prompt to send\n            format_function: Function to format the prompt for the model\n            timeout: Timeout in seconds\n            \n        Returns:\n            Tuple containing success flag and response text\n        \"\"\"\n        if not self.model_process or self.model_process.poll() is not None:\n            if self.model_process is not None:\n                exit_code = self.model_process.poll()\n                self.log(f\"[Warning] Model process exited with code {exit_code} before sending prompt\")\n            else:\n                self.log(\"[Warning] Model is not running. Please start a model first.\")\n            # Notify caller to start the model\n            return False, \"Model is not running. Please start a model first.\"\n        \n        # Update status to generating\n        model_name = self.current_model\n        self._update_model_status(model_name, MODEL_STATUS[\"GENERATING\"])\n        \n        try:\n            # Format the prompt\n            formatted = format_function(prompt)\n            \n            # Format the input properly\n            input_text = formatted + \"\\n\"\n            \n            # Log start of interaction\n            self.log(f\"[Prompt] Sending prompt to {model_name} (length: {len(input_text)})\")\n            \n            # Write to stdin and flush immediately\n            self.model_process.stdin.write(input_text)\n            self.model_process.stdin.flush()\n            \n            # Check if process is still alive after sending prompt\n            if self.model_process.poll() is not None:\n                exit_code = self.model_process.poll()\n                self.log(f\"[Warning] Model process terminated with code {exit_code} right after sending prompt\")\n                return False, f\"Model process terminated (exit code: {exit_code})\"\n            \n            # Collect the response\n            response = \"\"\n            start_time = time.time()\n            \n            # Read from stdout with a timeout\n            while time.time() - start_time < timeout:\n                # Check if the process is still running\n                if self.model_process.poll() is not None:\n                    exit_code = self.model_process.poll()\n                    self.log(f\"[Warning] Model process terminated with code {exit_code} during response generation\")\n                    break\n                \n                # Read available output\n                line = self.model_process.stdout.readline()\n                if not line:\n                    time.sleep(0.1)\n                    continue\n                \n                # Add to response and display in real-time\n                cleaned_line = line.strip()\n                if cleaned_line:\n                    response += cleaned_line + \"\\n\"\n                    # Log the output\n                    self.log(cleaned_line)\n                \n                # If we detect the model is waiting for the next input\n                if \"> \" in line or \"\u258c\" in line:\n                    self.log(\"[Prompt] Detected model completion marker\")\n                    break\n            \n            # Check for timeout\n            if time.time() - start_time >= timeout:\n                self.log(f\"[Warning] Response generation timed out after {timeout} seconds\")\n                \n            # Update status when done generating\n            self._update_model_status(model_name, MODEL_STATUS[\"RUNNING\"])\n            \n            # Return success and response\n            return True, response.strip()\n            \n        except Exception as e:\n            self.log(f\"[Execution Error] {e}\")\n            self._update_model_status(model_name, MODEL_STATUS[\"ERROR\"])\n            return False, f\"Error: {str(e)}\"\n    \n    def get_system_info(self) -> Dict:\n        \"\"\"\n        Get system information related to model usage\n        \n        Returns:\n            Dictionary with system information\n        \"\"\"\n        info = {\n            \"models_path\": self.model_path,\n            \"path_exists\": os.path.exists(self.model_path),\n            \"use_8bit\": self.use_8bit,\n            \"installed_models\": []\n        }\n        \n        # Get installed models\n        installed = [model for model, status in self.model_statuses.items() \n                   if status == MODEL_STATUS[\"INSTALLED\"]]\n        info[\"installed_models\"] = installed\n        info[\"installed_count\"] = len(installed)\n        \n        # Get drive free space\n        try:\n            drive = os.path.splitdrive(self.model_path)[0] + \"\\\\\"\n            if not drive:\n                drive = \"C:\\\\\"  # Default to C: if no drive letter found\n                \n            import shutil\n            usage = shutil.disk_usage(drive)\n            info[\"drive\"] = drive\n            info[\"free_space_gb\"] = round(usage.free / (1024**3), 2)  # Convert to GB\n        except Exception as e:\n            self.log(f\"[Error] Could not check disk space: {e}\")\n            info[\"free_space_gb\"] = -1\n        \n        return info\n    \n    def get_current_model_format(self) -> str:\n        \"\"\"\n        Get the format of the currently running model\n        \n        Returns:\n            String identifier of the model format (chatml, llama, etc.)\n        \"\"\"\n        if not self.current_model:\n            return \"default\"\n            \n        # Check model name to guess format\n        model_name = self.current_model.lower()\n        \n        # Determine format based on model name\n        if any(name in model_name for name in [\"gpt\", \"claude\", \"chatgpt\", \"deepseek\"]):\n            return \"chatml\"\n        elif any(name in model_name for name in [\"llama\", \"mistral\", \"mixtral\", \"alpaca\"]):\n            return \"llama\"\n        elif any(name in model_name for name in [\"starcoder\", \"codellama\"]):\n            return \"coder\"\n        \n        # Default to a simple format for other models\n        return \"default\"\n\n    def get_model_details(self, model_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Get detailed information about a specific model\n        \n        Args:\n            model_name: Name of the model\n            \n        Returns:\n            Dictionary of model details\n        \"\"\"\n        details = {\n            \"name\": model_name,\n            \"status\": self.model_statuses.get(model_name, MODEL_STATUS[\"NOT_INSTALLED\"]),\n            \"is_current\": model_name == self.current_model,\n        }\n        \n        # Add recommended model info if available\n        if model_name in RECOMMENDED_MODELS:\n            details.update(RECOMMENDED_MODELS[model_name])\n        \n        # Try to get model size from filesystem\n        try:\n            model_dir = os.path.join(self.model_path, model_name)\n            if os.path.exists(model_dir):\n                # Calculate directory size\n                total_size = 0\n                for dirpath, dirnames, filenames in os.walk(model_dir):\n                    for f in filenames:\n                        fp = os.path.join(dirpath, f)\n                        total_size += os.path.getsize(fp)\n                \n                # Convert to GB\n                details[\"size_gb\"] = round(total_size / (1024**3), 2)\n        except Exception as e:\n            self.log(f\"[Warning] Could not get model size: {e}\")\n        \n        return details\n\n    def get_model_parameters(self, model_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Get available parameters for a model\n        \n        Args:\n            model_name: Name of the model\n            \n        Returns:\n            Dictionary of parameters\n        \"\"\"\n        params = {\n            \"temperature\": 0.7,\n            \"top_p\": 0.9,\n            \"top_k\": 40,\n            \"repeat_penalty\": 1.1,\n        }\n        \n        # Adjust default parameters based on model type\n        if \"code\" in model_name.lower() or \"coder\" in model_name.lower():\n            # Better defaults for code generation\n            params[\"temperature\"] = 0.3\n            params[\"repeat_penalty\"] = 1.2\n        elif any(creative in model_name.lower() for creative in [\"creative\", \"novel\", \"story\"]):\n            # More creative defaults\n            params[\"temperature\"] = 0.9\n            params[\"top_p\"] = 0.95\n        \n        return params\n\n    def set_model_parameters(self, params: Dict[str, Any]) -> bool:\n        \"\"\"\n        Set parameters for the current model\n        \n        Args:\n            params: Dictionary of parameter key-value pairs\n            \n        Returns:\n            True if parameters were set successfully, False otherwise\n        \"\"\"\n        if not self.current_model:\n            self.log(\"[Error] No model is currently running\")\n            return False\n        \n        try:\n            # Log the parameter update\n            valid_params = {}\n            for key, value in params.items():\n                # Validate parameter values\n                if key == \"temperature\":\n                    valid_params[key] = max(0.0, min(2.0, float(value)))\n                elif key in [\"top_p\", \"top_k\", \"repeat_penalty\"]:\n                    valid_params[key] = max(0.0, float(value))\n                else:\n                    # Skip unknown parameters\n                    self.log(f\"[Warning] Unknown parameter: {key}\")\n                    continue\n                    \n                self.log(f\"[Parameters] {key} = {valid_params[key]}\")\n            \n            # Store parameters for future reference\n            self.current_parameters = valid_params\n            return True\n        except Exception as e:\n            self.log(f\"[Error] Failed to set parameters: {e}\")\n            return False\n\n    def export_model_config(self, path: str) -> bool:\n        \"\"\"\n        Export model configurations to a file\n        \n        Args:\n            path: Path to save configuration file\n            \n        Returns:\n            True if exported successfully, False otherwise\n        \"\"\"\n        try:\n            # Collect configuration data\n            config = {\n                \"model_path\": self.model_path,\n                \"use_8bit\": self.use_8bit,\n                \"current_model\": self.current_model,\n                \"models\": {},\n            }\n            \n            # Add information about each known model\n            for model_name, status in self.model_statuses.items():\n                config[\"models\"][model_name] = {\n                    \"status\": status,\n                    \"recommended\": model_name in RECOMMENDED_MODELS,\n                }\n                \n                # Add recommended model metadata if available\n                if model_name in RECOMMENDED_MODELS:\n                    config[\"models\"][model_name].update(RECOMMENDED_MODELS[model_name])\n            \n            # Create directory if it doesn't exist\n            os.makedirs(os.path.dirname(path), exist_ok=True)\n            \n            # Save to file\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(config, f, indent=2)\n                \n            self.log(f\"[Config] Exported model configuration to {path}\")\n            return True\n            \n        except Exception as e:\n            self.log(f\"[Error] Failed to export model configuration: {e}\")\n            return False\n\n    def import_model_config(self, path: str) -> bool:\n        \"\"\"\n        Import model configurations from a file\n        \n        Args:\n            path: Path to configuration file\n            \n        Returns:\n            True if imported successfully, False otherwise\n        \"\"\"\n        if not os.path.exists(path):\n            self.log(f\"[Error] Configuration file not found: {path}\")\n            return False\n            \n        try:\n            # Load from file\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                config = json.load(f)\n                \n            # Update model path if specified\n            if \"model_path\" in config and config[\"model_path\"] != self.model_path:\n                self.update_model_path(config[\"model_path\"])\n                \n            # Update 8-bit setting\n            if \"use_8bit\" in config:\n                self.use_8bit = config[\"use_8bit\"]\n                \n            # Refresh model status information if provided\n            if \"models\" in config:\n                for model_name, model_info in config[\"models\"].items():\n                    if \"status\" in model_info:\n                        status = model_info[\"status\"]\n                        # Only update if the status indicates the model is installed\n                        if status == MODEL_STATUS[\"INSTALLED\"]:\n                            # Verify model is actually installed\n                            if self.verify_model_status(model_name):\n                                self._update_model_status(model_name, status)\n            \n            self.log(f\"[Config] Imported model configuration from {path}\")\n            return True\n            \n        except Exception as e:\n            self.log(f\"[Error] Failed to import model configuration: {e}\")\n            return False\n        \n    def chat_stream(self, prompt: str, format_function: Callable, \n                   callback: Callable[[str, str], None]) -> bool:\n        \"\"\"\n        Send a prompt to the model and stream back the response\n        \n        Args:\n            prompt: Prompt to send\n            format_function: Function to format the prompt for the model\n            callback: Function to call with chunks of the response\n            \n        Returns:\n            True if chat completed successfully, False otherwise\n        \"\"\"\n        if not self.model_process or self.model_process.poll() is not None:\n            self.log(\"[Error] Model is not running\")\n            callback(\"error\", \"Model is not running\")\n            return False\n        \n        # Update status to generating\n        model_name = self.current_model\n        self._update_model_status(model_name, MODEL_STATUS[\"GENERATING\"])\n        \n        try:\n            # Format the prompt\n            formatted = format_function(prompt)\n            \n            # Format the input properly\n            input_text = formatted + \"\\n\"\n            \n            # Write to stdin and flush immediately\n            self.model_process.stdin.write(input_text)\n            self.model_process.stdin.flush()\n            \n            # Create a thread for reading the response\n            def read_response():\n                response_buffer = \"\"\n                \n                try:\n                    while True:\n                        if self.model_process.poll() is not None:\n                            # Process ended unexpectedly\n                            callback(\"error\", \"Model process terminated unexpectedly\")\n                            break\n                            \n                        line = self.model_process.stdout.readline()\n                        if not line:\n                            time.sleep(0.1)\n                            continue\n                            \n                        # Clean the line\n                        chunk = line.strip()\n                        if not chunk:\n                            continue\n                            \n                        # Check if response is complete\n                        if \"> \" in chunk or \"\u258c\" in chunk:\n                            # Send final complete flag\n                            callback(\"complete\", response_buffer.strip())\n                            break\n                            \n                        # Add to buffer and send the chunk\n                        response_buffer += chunk + \"\\n\"\n                        callback(\"chunk\", chunk)\n                        \n                    # Update status when done\n                    self._update_model_status(model_name, MODEL_STATUS[\"RUNNING\"])\n                    \n                except Exception as e:\n                    self.log(f\"[Stream Error] {e}\")\n                    callback(\"error\", str(e))\n                    self._update_model_status(model_name, MODEL_STATUS[\"ERROR\"])\n            \n            # Start the response thread\n            threading.Thread(target=read_response, daemon=True).start()\n            return True\n            \n        except Exception as e:\n            self.log(f\"[Chat Error] {e}\")\n            self._update_model_status(model_name, MODEL_STATUS[\"ERROR\"])\n            callback(\"error\", str(e))\n            return False\n        \n    def get_model_config(self, model_name):\n        \"\"\"\n        Get configuration details for a specific model\n        \n        Args:\n            model_name (str): Name of the model\n            \n        Returns:\n            dict: Model configuration or None if model not found\n        \"\"\"\n        # Check if model exists in available models\n        for model in self.available_models:\n            if model['name'] == model_name:\n                return model\n                \n        # If model not found in available models, check if it's a custom model\n        custom_models = self.config.get(\"models.custom_models\", [])\n        for model in custom_models:\n            if model['name'] == model_name:\n                return model\n        \n        # Model not found\n        self.logger(f\"[ModelManager] Model config not found for: {model_name}\")\n        return None\n    \n    def list_models(self, remote=False):\n        \"\"\"\n        List installed Ollama models or remote models\n        \n        Args:\n            remote: Whether to list remote models (True) or local models (False)\n            \n        Returns:\n            Tuple of (success, data) where data is a dict with models list or error\n        \"\"\"\n        self.log(f\"[Models] Listing {'remote' if remote else 'local'} Ollama models\")\n        \n        try:\n            # Check if Ollama is installed\n            if shutil.which(\"ollama\") is None:\n                return False, {\"error\": \"Ollama executable not found\"}\n                \n            # Command to list models\n            cmd = [\"ollama\", \"list\"]\n            if remote:\n                cmd.append(\"remote\")\n                \n            # Run the command\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                encoding='utf-8',\n                errors='replace',\n                timeout=10,\n                env=os.environ.copy()\n            )\n            \n            if result.returncode != 0:\n                return False, {\"error\": f\"Command failed: {result.stderr}\"}\n                \n            # Parse the output to extract model names\n            output = self._strip_ansi_codes(result.stdout)\n            lines = output.strip().split('\\n')\n            models = []\n            \n            # Skip header line if present\n            start_idx = 1 if len(lines) > 0 and ('NAME' in lines[0] or 'MODEL' in lines[0]) else 0\n            \n            # Parse each line to extract model info\n            for line in lines[start_idx:]:\n                if line.strip():\n                    # First column is name, try to extract tags too\n                    parts = line.split()\n                    if not parts:\n                        continue\n                        \n                    name = parts[0]\n                    models.append({\n                        \"name\": name,\n                        \"status\": \"installed\" if not remote else \"available\",\n                    })\n            \n            return True, {\"models\": models}\n            \n        except Exception as e:\n            self.log(f\"[Error] Failed to list models: {e}\")\n            return False, {\"error\": str(e)}",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\pdf_cuda_diagnostic.py": "\"\"\"\nIrintAI Assistant - PDF and CUDA Diagnostic Tool\nThis module provides diagnostic functions to check PDF integration and PyTorch CUDA support\n\"\"\"\nimport os\nimport sys\nimport importlib\nimport subprocess\nfrom pathlib import Path\n\ndef print_header(text):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'=' * 80}\")\n    print(f\" {text}\")\n    print(f\"{'=' * 80}\")\n\ndef check_pdf_integration():\n    \"\"\"Check PDF integration components and dependencies\"\"\"\n    print_header(\"PDF INTEGRATION CHECK\")\n    \n    results = {}\n    \n    try:\n        # Check if PyMuPDF is installed\n        try:\n            import fitz\n            results[\"pymupdf\"] = {\n                \"status\": \"Success\",\n                \"message\": f\"PyMuPDF (fitz) is installed: version {fitz.version}\"\n            }\n            print(f\"\u2713 PyMuPDF (fitz) is installed: version {fitz.version}\")\n        except ImportError:\n            results[\"pymupdf\"] = {\n                \"status\": \"Failure\",\n                \"message\": \"PyMuPDF (fitz) is not installed\"\n            }\n            print(\"\u2717 PyMuPDF (fitz) is not installed\")\n        \n        # Check PDF operations module\n        sys.path.insert(0, os.getcwd())\n        try:\n            from utils.pdf_operations import extract_text_from_pdf\n            \n            # Try to extract text from a sample PDF if available\n            sample_path = Path(\"data/samples/sample.pdf\")\n            if sample_path.exists():\n                try:\n                    text = extract_text_from_pdf(str(sample_path))\n                    text_length = len(text)\n                    results[\"pdf_operations\"] = {\n                        \"status\": \"Success\",\n                        \"message\": f\"PDF operations module works: extracted {text_length} characters\"\n                    }\n                    print(f\"\u2713 PDF operations module works: extracted {text_length} characters\")\n                except Exception as e:\n                    results[\"pdf_operations\"] = {\n                        \"status\": \"Warning\",\n                        \"message\": f\"PDF operations module imported but extraction failed: {e}\"\n                    }\n                    print(f\"\u26a0 PDF operations module imported but extraction failed: {e}\")\n            else:\n                results[\"pdf_operations\"] = {\n                    \"status\": \"Warning\",\n                    \"message\": \"PDF operations module imported but no sample PDF to test\"\n                }\n                print(\"\u26a0 PDF operations module imported but no sample PDF to test\")\n        except ImportError as e:\n            results[\"pdf_operations\"] = {\n                \"status\": \"Failure\",\n                \"message\": f\"PDF operations module not found: {e}\"\n            }\n            print(f\"\u2717 PDF operations module not found: {e}\")\n        \n        # Check memory PDF integration\n        try:\n            from core.memory_system import PDFMemoryIntegration\n            results[\"pdf_memory\"] = {\n                \"status\": \"Success\",\n                \"message\": \"PDF memory integration module found\"\n            }\n            print(\"\u2713 PDF memory integration module found\")\n        except ImportError as e:\n            results[\"pdf_memory\"] = {\n                \"status\": \"Warning\",\n                \"message\": f\"PDF memory integration not found: {e}\"\n            }\n            print(f\"\u26a0 PDF memory integration not found: {e}\")\n        \n        # Check for OCR capabilities\n        try:\n            from PIL import Image\n            import pytesseract\n            \n            # Check if tesseract command is available\n            try:\n                version = pytesseract.get_tesseract_version()\n                results[\"ocr\"] = {\n                    \"status\": \"Success\",\n                    \"message\": f\"OCR support available (Tesseract v{version})\"\n                }\n                print(f\"\u2713 OCR support available (Tesseract v{version})\")\n            except pytesseract.TesseractNotFoundError:\n                results[\"ocr\"] = {\n                    \"status\": \"Warning\",\n                    \"message\": \"pytesseract installed but Tesseract binary not found\"\n                }\n                print(\"\u26a0 pytesseract installed but Tesseract binary not found\")\n        except ImportError:\n            results[\"ocr\"] = {\n                \"status\": \"Warning\",\n                \"message\": \"OCR libraries not installed (pytesseract/PIL)\"\n            }\n            print(\"\u26a0 OCR libraries not installed (pytesseract/PIL)\")\n        \n        return results\n    except Exception as e:\n        error_message = f\"PDF integration check failed: {e}\"\n        print(f\"\u2717 {error_message}\")\n        return {\"status\": \"Failure\", \"message\": error_message}\n\n\ndef check_torch_cuda():\n    \"\"\"Check PyTorch CUDA support\"\"\"\n    print_header(\"PYTORCH CUDA CHECK\")\n    \n    results = {}\n    \n    try:\n        # Check if PyTorch is installed\n        try:\n            import torch\n            torch_version = torch.__version__\n            results[\"torch\"] = {\n                \"status\": \"Success\", \n                \"message\": f\"PyTorch is installed: version {torch_version}\"\n            }\n            print(f\"\u2713 PyTorch is installed: version {torch_version}\")\n            \n            # Check CUDA availability\n            cuda_available = torch.cuda.is_available()\n            if cuda_available:\n                device_count = torch.cuda.device_count()\n                cuda_version = torch.version.cuda\n                device_name = torch.cuda.get_device_name(0) if device_count > 0 else \"Unknown\"\n                \n                results[\"cuda\"] = {\n                    \"status\": \"Success\",\n                    \"message\": f\"CUDA is available (v{cuda_version}), {device_count} device(s): {device_name}\"\n                }\n                print(f\"\u2713 CUDA is available (v{cuda_version})\")\n                print(f\"  - Devices: {device_count}\")\n                print(f\"  - GPU: {device_name}\")\n                \n                # Test tensor operations on CUDA\n                try:\n                    x = torch.rand(5, 3).cuda()\n                    y = torch.rand(5, 3).cuda()\n                    z = x + y\n                    results[\"cuda_test\"] = {\n                        \"status\": \"Success\",\n                        \"message\": \"CUDA tensor operations work correctly\"\n                    }\n                    print(\"\u2713 CUDA tensor operations work correctly\")\n                except Exception as e:\n                    results[\"cuda_test\"] = {\n                        \"status\": \"Warning\",\n                        \"message\": f\"CUDA tensor operations failed: {e}\"\n                    }\n                    print(f\"\u26a0 CUDA tensor operations failed: {e}\")\n            else:\n                results[\"cuda\"] = {\n                    \"status\": \"Warning\",\n                    \"message\": \"CUDA is not available\"\n                }\n                print(\"\u26a0 CUDA is not available\")\n                \n                # Check for CPU-only operation\n                try:\n                    x = torch.rand(5, 3)\n                    y = torch.rand(5, 3)\n                    z = x + y\n                    results[\"cpu_test\"] = {\n                        \"status\": \"Success\",\n                        \"message\": \"CPU tensor operations work correctly\"\n                    }\n                    print(\"\u2713 CPU tensor operations work correctly\")\n                except Exception as e:\n                    results[\"cpu_test\"] = {\n                        \"status\": \"Failure\",\n                        \"message\": f\"CPU tensor operations failed: {e}\"\n                    }\n                    print(f\"\u2717 CPU tensor operations failed: {e}\")\n        \n        except ImportError:\n            results[\"torch\"] = {\n                \"status\": \"Failure\",\n                \"message\": \"PyTorch is not installed\"\n            }\n            print(\"\u2717 PyTorch is not installed\")\n            \n        # Check for NVIDIA driver info if on suitable platform\n        if sys.platform.startswith('win') or sys.platform.startswith('linux'):\n            try:\n                if sys.platform.startswith('win'):\n                    proc = subprocess.run([\"nvidia-smi\"], capture_output=True, text=True)\n                else:\n                    proc = subprocess.run([\"nvidia-smi\"], capture_output=True, text=True)\n                \n                if proc.returncode == 0:\n                    driver_info = proc.stdout.split('\\n')[2:6]\n                    results[\"nvidia_driver\"] = {\n                        \"status\": \"Success\",\n                        \"message\": \"NVIDIA driver installed\",\n                        \"details\": '\\n'.join(driver_info).strip()\n                    }\n                    print(\"\u2713 NVIDIA driver installed\")\n                    print(f\"  - {driver_info[0].strip()}\")\n                else:\n                    results[\"nvidia_driver\"] = {\n                        \"status\": \"Warning\",\n                        \"message\": \"NVIDIA driver info command failed\"\n                    }\n                    print(\"\u26a0 NVIDIA driver info command failed\")\n            except FileNotFoundError:\n                results[\"nvidia_driver\"] = {\n                    \"status\": \"Warning\",\n                    \"message\": \"nvidia-smi not found, NVIDIA driver may not be installed\"\n                }\n                print(\"\u26a0 nvidia-smi not found, NVIDIA driver may not be installed\")\n        \n        return results\n    except Exception as e:\n        error_message = f\"PyTorch CUDA check failed: {e}\"\n        print(f\"\u2717 {error_message}\")\n        return {\"status\": \"Failure\", \"message\": error_message}\n\nif __name__ == \"__main__\":\n    check_pdf_integration()\n    print(\"\\n\")\n    check_torch_cuda()\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\personality_plugin\\tests\\test_plugin.py": "import unittest\nimport os\nimport json\nimport tkinter as tk\nfrom unittest.mock import MagicMock, patch\n\n# Import the plugin\nimport sys\nsys.path.append('../../')  # Add parent directory to path\nfrom __init__ import IrintaiPlugin\n\nclass TestPersonalityPlugin(unittest.TestCase):\n    \"\"\"Test cases for the Personality Plugin\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test environment\"\"\"\n        # Create mock core system\n        self.core_system = MagicMock()\n        self.core_system.chat_engine = MagicMock()\n        self.core_system.memory_system = MagicMock()\n        \n        # Create test config path\n        self.test_config_path = \"test_config.json\"\n        \n        # Create mock logger\n        self.log_messages = []\n        def test_logger(message, level=\"INFO\"):\n            self.log_messages.append((level, message))\n        \n        # Initialize plugin\n        self.plugin = IrintaiPlugin(\n            self.core_system,\n            config_path=self.test_config_path,\n            logger=test_logger\n        )\n    \n    def tearDown(self):\n        \"\"\"Clean up after tests\"\"\"\n        # Remove test config file\n        if os.path.exists(self.test_config_path):\n            os.remove(self.test_config_path)\n    \n    def test_initialization(self):\n        \"\"\"Test plugin initialization\"\"\"\n        # Check initial state\n        self.assertEqual(self.plugin._state[\"status\"], self.plugin.STATUS[\"ACTIVE\"])\n        self.assertIsNotNone(self.plugin._config)\n        self.assertIn(\"profiles\", self.plugin._config)\n        \n        # Check default profiles\n        profiles = self.plugin._config[\"profiles\"]\n        self.assertIn(\"Standard\", profiles)\n        self.assertIn(\"Teacher\", profiles)\n        self.assertIn(\"Philosopher\", profiles)\n        self.assertIn(\"Empath\", profiles)\n        self.assertIn(\"Altruxan\", profiles)\n    \n    def test_get_available_profiles(self):\n        \"\"\"Test getting available profiles\"\"\"\n        profiles = self.plugin.get_available_profiles()\n        self.assertIsInstance(profiles, list)\n        self.assertTrue(len(profiles) > 0)\n        \n        # Check profile structure\n        profile = profiles[0]\n        self.assertIn(\"name\", profile)\n        self.assertIn(\"description\", profile)\n        self.assertIn(\"tags\", profile)\n        self.assertIn(\"author\", profile)\n    \n    def test_set_active_profile(self):\n        \"\"\"Test setting active profile\"\"\"\n        # Set active profile\n        success = self.plugin.set_active_profile(\"Teacher\")\n        self.assertTrue(success)\n        \n        # Check active profile\n        self.assertEqual(self.plugin._state[\"active_profile\"], \"Teacher\")\n        self.assertEqual(self.plugin._config[\"active_profile\"], \"Teacher\")\n        \n        # Check memory storage\n        self.core_system.memory_system.add_to_index.assert_called_once()\n    \n    def test_profile_creation(self):\n        \"\"\"Test creating a new profile\"\"\"\n        # Create profile data\n        profile_data = {\n            \"name\": \"Test Profile\",\n            \"description\": \"Test description\",\n            \"tags\": [\"test\", \"profile\"],\n            \"author\": \"Tester\"\n        }\n        \n        # Create profile\n        success = self.plugin.create_profile(profile_data)\n        self.assertTrue(success)\n        \n        # Check profile was added\n        profiles = self.plugin._config[\"profiles\"]\n        self.assertIn(\"Test Profile\", profiles)\n        \n        # Check profile data\n        profile = profiles[\"Test Profile\"]\n        self.assertEqual(profile[\"description\"], \"Test description\")\n        self.assertEqual(profile[\"tags\"], [\"test\", \"profile\"])\n        self.assertEqual(profile[\"author\"], \"Tester\")\n    \n    def test_profile_update(self):\n        \"\"\"Test updating a profile\"\"\"\n        # First create a profile\n        profile_data = {\n            \"name\": \"Update Test\",\n            \"description\": \"Initial description\"\n        }\n        self.plugin.create_profile(profile_data)\n        \n        # Update profile\n        update_data = {\n            \"description\": \"Updated description\",\n            \"tags\": [\"updated\"]\n        }\n        success = self.plugin.update_profile(\"Update Test\", update_data)\n        self.assertTrue(success)\n        \n        # Check profile was updated\n        profile = self.plugin._config[\"profiles\"][\"Update Test\"]\n        self.assertEqual(profile[\"description\"], \"Updated description\")\n        self.assertEqual(profile[\"tags\"], [\"updated\"])\n    \n    def test_profile_deletion(self):\n        \"\"\"Test deleting a profile\"\"\"\n        # Create a profile\n        profile_data = {\n            \"name\": \"Delete Test\",\n            \"description\": \"To be deleted\"\n        }\n        self.plugin.create_profile(profile_data)\n        \n        # Delete profile\n        success = self.plugin.delete_profile(\"Delete Test\")\n        self.assertTrue(success)\n        \n        # Check profile was deleted\n        self.assertNotIn(\"Delete Test\", self.plugin._config[\"profiles\"])\n    \n    def test_message_modification(self):\n        \"\"\"Test message modification based on active profile\"\"\"\n        # Set active profile\n        self.plugin.set_active_profile(\"Teacher\")\n        \n        # Test message modification\n        original_message = \"This is a test message.\"\n        modified_message = self.plugin.modify_message(original_message)\n        \n        # Check prefix was added\n        self.assertTrue(modified_message.startswith(\"I'll help you understand this.\"))\n        \n        # Check suffix was added\n        self.assertTrue(modified_message.endswith(\"Does that clarify things for you?\"))\n    \n    def test_altruxan_style(self):\n        \"\"\"Test Altruxan-specific styling\"\"\"\n        # Set active profile\n        self.plugin.set_active_profile(\"Altruxan\")\n        \n        # Mock random choice to return a specific phrase\n        with patch('random.random', return_value=0.2):  # Ensure we apply the style\n            with patch('random.choice', return_value=\"We are not broken. We are recursive.\"):\n                original_message = \"This is a test message with multiple\\n\\nparagraphs.\"\n                modified_message = self.plugin.modify_message(original_message)\n                \n                # Check Altruxan phrase was added\n                self.assertIn(\"*We are not broken. We are recursive.*\", modified_message)\n    \n    def test_export_import(self):\n        \"\"\"Test exporting and importing profiles\"\"\"\n        # Export a profile\n        json_str = self.plugin.export_profile(\"Philosopher\")\n        self.assertIsNotNone(json_str)\n        \n        # Delete the profile\n        self.plugin.delete_profile(\"Philosopher\")\n        self.assertNotIn(\"Philosopher\", self.plugin._config[\"profiles\"])\n        \n        # Import the profile\n        success = self.plugin.import_profile(json_str)\n        self.assertTrue(success)\n        \n        # Check profile was imported\n        self.assertIn(\"Philosopher\", self.plugin._config[\"profiles\"])\n\nif __name__ == \"__main__\":\n    unittest.main()",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\ui\\ollama_hub_tab_manager.py": "\"\"\"\nOllama Hub tab refresh utility for the main window\n\nThis module provides functions to add or refresh the Ollama Hub tab in the main window\nafter the plugin has been activated.\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk\n\ndef add_ollama_hub_tab_to_main_window(main_window):\n    \"\"\"\n    Add or refresh the Ollama Hub tab in the main window\n    \n    This function should be called after the Ollama Hub plugin has been activated.\n    It will check if the plugin is active and add the tab if it's not already present.\n    \n    Args:\n        main_window: The MainWindow instance\n        \n    Returns:\n        True if the tab was added/refreshed, False otherwise\n    \"\"\"\n    try:\n        # Make sure we have all required components\n        if not hasattr(main_window, 'notebook') or not hasattr(main_window, 'plugin_manager'):\n            main_window.logger.log(\"[UI] Cannot add Ollama Hub tab: missing required components\")\n            return False\n            \n        # Check if the tab already exists\n        for i in range(main_window.notebook.index(\"end\")):\n            if main_window.notebook.tab(i, \"text\") == \"Ollama Hub\":\n                main_window.logger.log(\"[UI] Ollama Hub tab already exists\")\n                return True\n        \n        # Check if the ollama_hub plugin is active\n        active_plugins = main_window.plugin_manager.get_active_plugins()\n        if 'ollama_hub' not in active_plugins:\n            main_window.logger.log(\"[UI] Ollama Hub plugin not active, skipping tab creation\")\n            return False\n            \n        # Get the plugin instance\n        ollama_plugin = active_plugins.get('ollama_hub')\n        \n        # Import the module from the plugins directory\n        from plugins.ollama_hub.ui.ollama_tab import OllamaHubTab\n        \n        # Create a frame for the tab\n        ollama_tab_frame = ttk.Frame(main_window.notebook)\n        \n        # Create an instance of OllamaHubTab\n        tab_instance = OllamaHubTab(ollama_tab_frame, plugin_instance=ollama_plugin)\n        \n        # Add the tab to the notebook\n        main_window.notebook.add(ollama_tab_frame, text=\"Ollama Hub\")\n        \n        # Store reference for later access\n        main_window.ollama_hub_tab = tab_instance\n        \n        main_window.logger.log(\"[UI] Successfully added Ollama Hub tab\")\n        return True\n    except Exception as e:\n        import traceback\n        main_window.logger.log(f\"[UI] Error adding Ollama Hub tab: {e}\", \"ERROR\")\n        main_window.logger.log(traceback.format_exc(), \"DEBUG\")\n        return False\n\ndef refresh_ollama_hub_tab(main_window):\n    \"\"\"\n    Refresh the Ollama Hub tab in the main window\n    \n    This function will remove the existing tab if it exists and add a new one.\n    \n    Args:\n        main_window: The MainWindow instance\n        \n    Returns:\n        True if the tab was refreshed, False otherwise\n    \"\"\"\n    try:\n        # Remove existing tab if present\n        for i in range(main_window.notebook.index(\"end\")):\n            if main_window.notebook.tab(i, \"text\") == \"Ollama Hub\":\n                main_window.notebook.forget(i)\n                break\n                \n        # Add the tab again\n        return add_ollama_hub_tab_to_main_window(main_window)\n    except Exception as e:\n        main_window.logger.log(f\"[UI] Error refreshing Ollama Hub tab: {e}\", \"ERROR\")\n        return False\n",
  "D:\\AI\\IrintAI Assistant\\ui\\main_window.py": "\"\"\"\nMain application window for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport os\nimport sys\nimport time\nimport threading\n\n# Import core modules\nfrom core import ModelManager, ChatEngine, MemorySystem, ConfigManager\n\n# Import utility modules\nfrom utils import IrintaiLogger, SystemMonitor, FileOps\nfrom plugins.ollama_hub.core.ollama_hub_integrator import integrate_ollama_hub_ui\n\n# Import UI components\nfrom ui.panels.chat_panel import ChatPanel\nfrom ui.panels.model_panel import ModelPanel\nfrom ui.panels.memory_panel import MemoryPanel\nfrom ui.panels.resource_monitor_panel import ResourceMonitorPanel\nfrom ui.panels.plugin_panel import PluginPanel\nfrom ui.panels.config_panel import ConfigPanel\nfrom log_viewer import LogViewer\nfrom core.plugin_manager import PluginManager\nfrom plugins.plugin_config_panel import PluginConfigPanel\nfrom ui.dashboard import Dashboard\n\n# Import the new unified settings panel\nfrom ui.panels.unified_settings_panel import UnifiedSettingsPanel\n\nclass MainWindow:\n    \"\"\"Main application window for the Irintai assistant\"\"\"\n    \n    def __init__(self, root: tk.Tk, core_app=None):\n        \"\"\"\n        Initialize the main window\n        \n        Args:\n            root: Tkinter root window\n            core_app: Dictionary containing core application components\n        \"\"\"\n        self.root = root\n        self.root.title(\"Irintai - Local AI Assistant\")\n        self.root.minsize(800, 600)\n        \n        # Store core_app reference\n        self.core_app = core_app or {}\n        \n        # Try to set the application icon\n        try:\n            if os.path.exists(\"resources/icons/irintai_icon.ico\"):\n                self.root.iconbitmap(\"resources/icons/irintai_icon.ico\")\n        except Exception:\n            pass  # Ignore icon errors\n        \n        # Initialize logger (use from core_app if available)\n        self.initialize_logger()\n        \n        # Initialize core components using core_app\n        self.initialize_core_components()\n        \n        # Initialize UI components\n        self.initialize_ui()\n        \n        # Initialize plugins after UI is ready\n        self.initialize_plugins()\n        \n        # Update plugin menu\n        self.update_plugin_menu()\n        \n        # Set up cleanup on exit\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n        \n        # Schedule periodic updates\n        self.schedule_updates()\n        \n        # Log startup message\n        self.logger.log(\"[System] Irintai Assistant started\")\n        \n    def initialize_logger(self):\n        \"\"\"Initialize the logger\"\"\"\n        if \"logger\" in self.core_app:\n            self.logger = self.core_app[\"logger\"]\n        else:\n            self.logger = IrintaiLogger(\n                log_dir=\"data/logs\",\n                latest_log_file=\"irintai_debug.log\"\n            )\n        \n    def initialize_core_components(self):\n        \"\"\"Initialize core application components\"\"\"\n        # Use components from core_app if available, otherwise create new ones\n        \n        # Configuration manager\n        if \"config_manager\" in self.core_app:\n            self.config_manager = self.core_app[\"config_manager\"]\n        else:\n            self.config_manager = ConfigManager(\n                config_path=\"data/config.json\",\n                logger=self.logger.log\n            )\n        \n        # File operations utility\n        self.file_ops = FileOps(logger=self.logger.log)\n        \n        # System monitor\n        self.system_monitor = SystemMonitor(logger=self.logger.log)\n        \n        # Get configuration values\n        self.model_path = self.config_manager.get(\"model_path\", \"data/models\")\n        self.use_8bit = self.config_manager.get(\"use_8bit\", False)\n        \n        # Model manager\n        if \"model_manager\" in self.core_app:\n            self.model_manager = self.core_app[\"model_manager\"]\n        else:\n            self.model_manager = ModelManager(\n                model_path=self.model_path,\n                logger=self.logger.log,\n                use_8bit=self.use_8bit\n            )\n        \n        # Memory system\n        if \"memory_system\" in self.core_app:\n            self.memory_system = self.core_app[\"memory_system\"]\n        else:\n            self.memory_system = MemorySystem(\n                index_path=\"data/vector_store/vector_store.json\",\n                logger=self.logger.log\n            )\n        \n        # Chat engine\n        if \"chat_engine\" in self.core_app:\n            self.chat_engine = self.core_app[\"chat_engine\"]\n        else:\n            self.chat_engine = ChatEngine(\n                model_manager=self.model_manager,\n                memory_system=self.memory_system,\n                session_file=\"data/chat_history.json\",\n                logger=self.logger.log\n            )\n        \n        # Plugin manager\n        if \"plugin_manager\" in self.core_app:\n            self.plugin_manager = self.core_app[\"plugin_manager\"]\n        else:\n            self.plugin_manager = PluginManager(\n                plugin_dir=\"plugins\",\n                config_dir=\"data/plugins\",\n                logger=self.logger.log,\n                core_system=self\n            )\n        \n        # Set memory mode from config\n        self.chat_engine.set_memory_mode(\n            self.config_manager.get(\"memory_mode\", \"Off\")\n        )\n        \n        # Set system prompt from config\n        self.chat_engine.set_system_prompt(\n            self.config_manager.get(\"system_prompt\", \n                \"You are Irintai, a helpful and knowledgeable assistant.\")\n        )\n        \n    def initialize_ui(self):\n        \"\"\"Initialize the user interface components\"\"\"\n        # Create main frame\n        self.main_frame = ttk.Frame(self.root)\n        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Create top toolbar\n        self.create_toolbar()\n        \n        # Create notebook for tabbed interface\n        self.notebook = ttk.Notebook(self.main_frame)\n        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Create chat panel\n        self.chat_panel = ChatPanel(\n            self.notebook,\n            self.chat_engine,\n            self.logger.log,\n            self.config_manager\n        )\n        self.notebook.add(self.chat_panel.frame, text=\"Chat\")\n        \n        # Create model panel\n        self.model_panel = ModelPanel(\n            self.notebook,\n            self.model_manager,\n            self.logger.log,\n            self.on_model_selected\n        )\n        self.notebook.add(self.model_panel.frame, text=\"Models\")\n          # Create memory panel\n        self.memory_panel = MemoryPanel(\n            self.notebook,\n            self.memory_system,\n            self.file_ops,\n            self.logger.log,\n            self.chat_engine,\n            settings_manager=self.core_app[\"settings_manager\"]  # Pass settings_manager\n        )\n        self.notebook.add(self.memory_panel.frame, text=\"Memory\")\n          # Create resource monitor panel\n        self.resource_monitor = ResourceMonitorPanel(\n            self.notebook,\n            self.logger.log,\n            self.system_monitor  # Pass the SystemMonitor instance\n        )\n        self.notebook.add(self.resource_monitor.frame, text=\"Resources\")\n        \n        # Create unified settings panel that consolidates all settings in one place\n        self.settings_panel = UnifiedSettingsPanel(\n            self.notebook,\n            self.core_app[\"settings_manager\"],\n            self.core_app,\n            logger=self.logger.log\n        )\n        self.notebook.add(self.settings_panel.frame, text=\"Settings\")# Create plugin panel with integrated settings tab\n        self.plugin_panel = PluginPanel(\n            self.notebook,\n            self.plugin_manager,\n            config_manager=self.config_manager,\n            logger=self.logger.log\n        )\n        self.notebook.add(self.plugin_panel.frame, text=\"Plugins\")\n        \n        # Create Ollama Hub tab if the plugin is active\n        integrate_ollama_hub_ui(self.notebook, self.plugin_manager, self.logger.log)\n        \n        # Plugin Settings are now integrated in the plugin panel's tabs\n        \n        # Create status bar\n        self.create_status_bar()\n        \n    def create_toolbar(self):\n        \"\"\"Create the top toolbar\"\"\"\n        toolbar = ttk.Frame(self.main_frame)\n        toolbar.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Add toolbar buttons\n        ttk.Button(\n            toolbar, \n            text=\"Load Files\", \n            command=self.load_files\n        ).pack(side=tk.LEFT, padx=(0, 5))\n        \n        ttk.Button(\n            toolbar, \n            text=\"View Logs\", \n            command=self.view_logs\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            toolbar, \n            text=\"Save Logs\", \n            command=self.save_logs\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            toolbar, \n            text=\"Model Folder\", \n            command=self.open_model_folder\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            toolbar, \n            text=\"Dashboard\", \n            command=self.show_dashboard\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Add plugins button with dropdown menu\n        self.plugins_button = ttk.Menubutton(\n            toolbar,\n            text=\"Plugins\",\n            direction=\"below\"\n        )\n        self.plugins_button.pack(side=tk.LEFT, padx=5)\n        \n        # Create the plugins menu\n        self.plugins_menu = tk.Menu(self.plugins_button, tearoff=0)\n        self.plugins_button[\"menu\"] = self.plugins_menu\n        \n        # Add items to the menu (will be populated later)\n        self.plugins_menu.add_command(label=\"Manage Plugins\", command=self.show_plugins_tab)\n        self.plugins_menu.add_command(label=\"Reload All Plugins\", command=self.reload_all_plugins)\n        self.plugins_menu.add_separator()\n        self.plugins_menu.add_command(label=\"No active plugins\", state=tk.DISABLED)\n        \n        ttk.Button(\n            toolbar, \n            text=\"Generate Reflection\", \n            command=self.generate_reflection\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Add memory mode selector to toolbar\n        ttk.Label(toolbar, text=\"Memory Mode:\").pack(side=tk.LEFT, padx=(20, 5))\n        self.memory_mode_var = tk.StringVar(value=self.chat_engine.memory_mode)\n        memory_modes = [\"Off\", \"Manual\", \"Auto\", \"Background\"]\n        memory_dropdown = ttk.Combobox(\n            toolbar, \n            textvariable=self.memory_mode_var,\n            values=memory_modes,\n            state=\"readonly\",\n            width=10\n        )\n        memory_dropdown.pack(side=tk.LEFT, padx=5)\n        memory_dropdown.bind(\"<<ComboboxSelected>>\", self.on_memory_mode_changed)\n\n    def update_plugin_menu(self):\n        \"\"\"Update the plugins dropdown menu with active plugins\"\"\"\n        # Remove existing plugin entries\n        menu_size = self.plugins_menu.index(\"end\")\n        if menu_size > 3:  # Keep the first 4 items (Manage, Reload, Separator, No plugins)\n            self.plugins_menu.delete(3, menu_size)\n        \n        # Get active plugins\n        active_plugins = self.plugin_manager.get_active_plugins()\n        \n        if not active_plugins:\n            # Show \"No active plugins\" if none are active\n            self.plugins_menu.entryconfig(3, state=tk.NORMAL)\n            return\n        \n        # Hide \"No active plugins\" entry\n        self.plugins_menu.entryconfig(3, state=tk.DISABLED)\n        \n        # Add separator and active plugins\n        if active_plugins:\n            # Add each active plugin with its actions\n            for plugin_id, plugin in active_plugins.items():\n                # Check if plugin has a get_actions method\n                if hasattr(plugin, \"get_actions\") and callable(plugin.get_actions):\n                    try:\n                        actions = plugin.get_actions()\n                        if actions and isinstance(actions, dict):\n                            # Create a submenu for this plugin\n                            plugin_menu = tk.Menu(self.plugins_menu, tearoff=0)\n                            self.plugins_menu.add_cascade(label=plugin_id, menu=plugin_menu)\n                            \n                            # Add each action to the submenu\n                            for action_name, action_func in actions.items():\n                                if callable(action_func):\n                                    plugin_menu.add_command(label=action_name, command=action_func)\n                    except Exception as e:\n                        self.logger.log(f\"[Error] Failed to get actions for plugin {plugin_id}: {e}\")\n                else:\n                    # Just add the plugin name without actions\n                    self.plugins_menu.add_command(label=plugin_id, state=tk.DISABLED)\n\n    def show_plugins_tab(self):\n        \"\"\"Show the plugins tab in the notebook\"\"\"\n        # Find the index of the plugins tab\n        for i in range(self.notebook.index(\"end\")):\n            if self.notebook.tab(i, \"text\") == \"Plugins\":\n                self.notebook.select(i)\n                break\n\n    def reload_all_plugins(self):\n        \"\"\"Reload all plugins\"\"\"\n        # Ask for confirmation\n        result = messagebox.askyesno(\n            \"Reload Plugins\",\n            \"This will reload all plugins. Any unsaved plugin data may be lost.\\n\\nContinue?\",\n            icon=messagebox.WARNING\n        )\n        \n        if not result:\n            return\n        \n        # Get list of active plugins\n        active_plugins = list(self.plugin_manager.get_active_plugins().keys())\n        \n        # Unload all plugins\n        for plugin_id in self.plugin_manager.get_all_plugins().keys():\n            self.plugin_manager.unload_plugin(plugin_id)\n        \n        # Rediscover and reload plugins\n        self.plugin_manager.discover_plugins()\n        \n        # Reload previously active plugins\n        for plugin_id in active_plugins:\n            success = self.plugin_manager.load_plugin(plugin_id)\n            if success:\n                self.plugin_manager.activate_plugin(plugin_id)\n        \n        # Update UI\n        if hasattr(self, 'plugin_panel'):\n            self.plugin_panel.refresh_plugin_list()\n        \n        # Update menu\n        self.update_plugin_menu()\n        \n    def create_status_bar(self):\n        \"\"\"Create the status bar at the bottom of the window\"\"\"\n        status_frame = ttk.Frame(self.root)\n        status_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=2)\n        \n        # Model status\n        self.model_status_var = tk.StringVar(value=\"No model running\")\n        model_status = ttk.Label(status_frame, textvariable=self.model_status_var)\n        model_status.pack(side=tk.LEFT, padx=5)\n        \n        # Performance stats\n        self.perf_status_var = tk.StringVar(value=\"CPU: --% | RAM: --% | GPU: --% | VRAM: --\")\n        perf_label = ttk.Label(status_frame, textvariable=self.perf_status_var)\n        perf_label.pack(side=tk.RIGHT, padx=5)\n        \n    def load_files(self):\n        \"\"\"Load files into memory\"\"\"\n        from tkinter import filedialog\n        \n        # Get list of supported extensions\n        extensions = self.file_ops.get_supported_extensions()\n        \n        # Create file type string for dialog\n        file_types = [(\"Supported Files\", \" \".join(f\"*{ext}\" for ext in extensions))]\n        for ext in extensions:\n            content_types = self.file_ops.get_content_types()\n            desc = content_types.get(ext, ext[1:].upper() + \" Files\")\n            file_types.append((desc, f\"*{ext}\"))\n        \n        # Open file dialog\n        files = filedialog.askopenfilenames(\n            title=\"Select files to load\",\n            filetypes=file_types\n        )\n        \n        if not files:\n            return\n            \n        # Load and index each file\n        for file_path in files:\n            # Read the file\n            success, content = self.file_ops.read_file(file_path)\n            \n            if success:\n                # Add to memory system\n                self.memory_system.add_file_to_index(file_path, content)\n                self.logger.log(f\"[Loaded] {os.path.basename(file_path)}\")\n            else:\n                self.logger.log(f\"[Error] Failed to load {file_path}\")\n                \n        # Update memory panel if it exists\n        if hasattr(self, 'memory_panel'):\n            self.memory_panel.refresh_stats()\n            \n        # Show confirmation\n        messagebox.showinfo(\n            \"Files Loaded\", \n            f\"Successfully loaded {len(files)} files into memory.\"\n        )\n        \n    def view_logs(self):\n        \"\"\"Open the log viewer\"\"\"\n        LogViewer(self.root, self.logger)\n        \n    def save_logs(self):\n        \"\"\"Save logs to a file\"\"\"\n        timestamp = time.strftime(\"%Y%m%d_%H%M%S\")\n        filename = f\"irintai_logs_{timestamp}.txt\"\n        \n        if self.logger.save_console_log(filename):\n            messagebox.showinfo(\"Logs Saved\", f\"Logs saved to {filename}\")\n        else:\n            messagebox.showerror(\"Error\", \"Failed to save logs\")\n            \n    def open_model_folder(self):\n        \"\"\"Open the model folder in the file explorer\"\"\"\n        if self.file_ops.open_folder(self.model_path):\n            self.logger.log(f\"[Opened] Model folder: {self.model_path}\")\n        else:\n            messagebox.showerror(\"Error\", f\"Could not open folder: {self.model_path}\")\n            \n    def show_dashboard(self):\n        \"\"\"Show the dashboard dialog\"\"\"\n        \n        Dashboard(\n            self.root,\n            self.chat_engine,\n            self.model_manager,\n            self.memory_system,\n            self.system_monitor,\n            self.logger.log\n        )\n        \n    def generate_reflection(self):\n        \"\"\"Generate session reflection\"\"\"\n        reflection = self.chat_engine.generate_reflection()\n        \n        if reflection:\n            messagebox.showinfo(\n                \"Reflection Generated\", \n                \"Session reflection has been saved to data/reflections/session_reflections.json\"\n            )\n            \n    def on_memory_mode_changed(self, event):\n        \"\"\"Handle memory mode changes\"\"\"\n        new_mode = self.memory_mode_var.get()\n        self.chat_engine.set_memory_mode(new_mode)\n        \n        # Save to config\n        self.config_manager.set(\"memory_mode\", new_mode)\n        self.config_manager.save_config()\n        \n    def on_model_selected(self, model_name):\n        \"\"\"\n        Handle model selection from the model panel\n        \n        Args:\n            model_name: Name of the selected model\n        \"\"\"\n        # Update the model status display\n        self.model_status_var.set(f\"Model: {model_name}\")\n        \n        # Update the chat panel\n        self.chat_panel.set_model(model_name)\n        \n    def on_config_updated(self):\n        \"\"\"Handle configuration updates\"\"\"\n        # Reload config values\n        model_path = self.config_manager.get(\"model_path\")\n        use_8bit = self.config_manager.get(\"use_8bit\")\n        \n        # Update model manager if path changed\n        if model_path != self.model_path:\n            self.model_path = model_path\n            self.model_manager.update_model_path(model_path)\n            self.model_panel.refresh_model_list()\n            \n        # Update 8-bit setting\n        self.model_manager.use_8bit = use_8bit\n        \n        # Update system prompt\n        system_prompt = self.config_manager.get(\"system_prompt\")\n        self.chat_engine.set_system_prompt(system_prompt)\n        \n        # Update memory mode\n        memory_mode = self.config_manager.get(\"memory_mode\")\n        self.chat_engine.set_memory_mode(memory_mode)\n        self.memory_mode_var.set(memory_mode)\n        \n    def update_performance_stats(self):\n        \"\"\"Update the performance statistics in the status bar\"\"\"\n        stats = self.system_monitor.get_formatted_stats()\n        self.perf_status_var.set(stats)\n        \n        # Set background color based on resource usage\n        bg_color = self.system_monitor.get_bgr_color()\n        # TODO: Update status bar background color when necessary\n        \n    def schedule_updates(self):\n        \"\"\"Schedule periodic updates\"\"\"\n        # Update performance stats every second\n        def update_stats():\n            self.update_performance_stats()\n            self.root.after(1000, update_stats)\n            \n        # Start the update cycle\n        update_stats()\n        \n    def on_closing(self):\n        \"\"\"Handle application closing\"\"\"\n        # Stop the model if running\n        if self.model_manager.model_process and self.model_manager.model_process.poll() is None:\n            self.model_manager.stop_model()\n            \n        # Save chat session\n        self.chat_engine.save_session()\n        \n        # Save configuration\n        self.config_manager.save_config()\n        \n        # Deactivate all active plugins\n        self.cleanup_plugins()\n        \n        # Log shutdown\n        self.logger.log(\"[System] Irintai Assistant shutting down\")\n        \n        # Destroy the root window\n        self.root.destroy()\n\n    def cleanup_plugins(self):\n        \"\"\"Deactivate all active plugins\"\"\"\n        self.logger.log(\"[Plugins] Deactivating all plugins\")\n        \n        try:\n            plugins_info = self.plugin_manager.get_all_plugins()\n            for plugin_name, info in plugins_info.items():\n                if info.get(\"status\") == \"Active\":\n                    self.logger.log(f\"[Plugins] Deactivating plugin: {plugin_name}\")\n                    self.plugin_manager.deactivate_plugin(plugin_name)\n                    \n            # Allow a short delay for clean deactivation\n            time.sleep(0.5)\n        except Exception as e:\n            self.logger.log(f\"[Error] Failed to cleanup plugins: {e}\", \"ERROR\")    \n            \n    def initialize_plugins(self):\n        \"\"\"Initialize plugins and register event handlers\"\"\"\n        if not hasattr(self, 'plugin_manager') or not self.plugin_manager:\n            return\n        \n        # Register event handlers for plugin activation/deactivation\n        if hasattr(self.plugin_manager, 'register_event_handler'):\n            # Register handler for plugin activation\n            self.plugin_manager.register_event_handler(\n                \"main_window\", \n                \"plugin_activated\", \n                self.on_plugin_activated\n            )\n            \n            # Register handler for plugin deactivation\n            self.plugin_manager.register_event_handler(\n                \"main_window\", \n                \"plugin_deactivated\", \n                self.on_plugin_deactivated\n            )\n            \n            # Register handlers for other plugin events\n            self.plugin_manager.register_event_handler(\n                \"main_window\", \n                \"plugin_loaded\", \n                self.on_plugin_loaded\n            )\n            \n            self.plugin_manager.register_event_handler(\n                \"main_window\", \n                \"plugin_unloaded\", \n                self.on_plugin_unloaded\n            )\n            \n            self.plugin_manager.register_event_handler(\n                \"main_window\", \n                \"plugin_error\", \n                self.on_plugin_error\n            )\n            \n            self.logger.log(\"[Plugin Events] Registered handlers for plugin events\")\n            \n    def integrate_ollama_hub(self):\n        \"\"\"Dynamically integrate the Ollama Hub UI if the plugin is active\"\"\"\n        # Check if the Ollama Hub tab already exists\n        for i in range(self.notebook.index(\"end\")):\n            if self.notebook.tab(i, \"text\") == \"Ollama Hub\":\n                self.logger.log(\"[UI] Ollama Hub tab already present; skipping add.\")\n                return False\n        \n        # Call the integration function to add the tab\n        result = integrate_ollama_hub_ui(self.notebook, self.plugin_manager, self.logger.log)\n        \n        if result:\n            self.logger.log(\"[UI] Ollama Hub tab dynamically added (integration successful)\")\n        else:\n            self.logger.log(\"[UI] Ollama Hub tab integration attempted but not added (plugin not active or integration failed)\")\n        \n        return result\n\n    def on_plugin_activated(self, plugin_id, **kwargs):\n        self.logger.log(f\"[Plugin Events] Plugin activated: {plugin_id} (event handler called)\")\n        self.update_plugin_menu()\n        if plugin_id == \"ollama_hub\":\n            self.logger.log(\"[Plugin Events] Ollama Hub plugin activated; attempting to add tab.\")\n            self.integrate_ollama_hub()\n        return True\n\n    def on_plugin_deactivated(self, plugin_id, **kwargs):\n        self.logger.log(f\"[Plugin Events] Plugin deactivated: {plugin_id} (event handler called)\")\n        self.update_plugin_menu()\n        if plugin_id == \"ollama_hub\":\n            for i in range(self.notebook.index(\"end\")):\n                if self.notebook.tab(i, \"text\") == \"Ollama Hub\":\n                    self.notebook.forget(i)\n                    self.logger.log(\"[UI] Ollama Hub tab removed (plugin deactivated)\")\n                    break\n        return True\n\n    def on_plugin_loaded(self, plugin_id, **kwargs):\n        self.logger.log(f\"[Plugin Events] Plugin loaded: {plugin_id} (event handler called)\")\n        return True\n\n    def on_plugin_unloaded(self, plugin_id, **kwargs):\n        self.logger.log(f\"[Plugin Events] Plugin unloaded: {plugin_id} (event handler called)\")\n        return True\n\n    def on_plugin_error(self, plugin_id, error_message, **kwargs):\n        self.logger.log(f\"[Plugin Error] {plugin_id}: {error_message} (event handler called)\")\n        return True",
  "D:\\AI\\IrintAI Assistant\\core\\chat_engine.py": "\"\"\"\nChat Engine - Handles conversation logic and prompt formatting\n\"\"\"\nimport time\nimport json\nimport os\nfrom typing import List, Dict, Any, Optional, Callable\n\nclass ChatEngine:\n    \"\"\"Manages chat history, prompt formatting, and conversation context\"\"\"\n    \n    def __init__(self, \n                 model_manager,\n                 memory_system=None,\n                 session_file: str = \"data/chat_history.json\",\n                 logger: Optional[Callable] = None):\n        \"\"\"\n        Initialize the chat engine\n        \n        Args:\n            model_manager: ModelManager instance\n            memory_system: Optional MemorySystem instance\n            session_file: Path to save chat history\n            logger: Optional logging function\n        \"\"\"\n        self.model_manager = model_manager\n        self.memory_system = memory_system\n        self.session_file = session_file\n        self.log = logger or print\n        \n        self.chat_history = []\n        self.system_prompt = \"You are Irintai, a helpful and knowledgeable assistant.\"\n        self.memory_mode = \"Off\"  # Off, Manual, Auto, Background\n        \n        # Create directory for session file if it doesn't exist\n        os.makedirs(os.path.dirname(session_file), exist_ok=True)\n        \n        # Load previous session if available\n        self.load_session()\n        \n    def set_system_prompt(self, prompt: str) -> None:\n        \"\"\"\n        Set the system prompt\n        \n        Args:\n            prompt: System prompt text\n        \"\"\"\n        self.system_prompt = prompt\n        self.log(f\"[System Prompt] Applied: {prompt}\")\n    def set_memory_mode(self, enabled=True, auto=False, background=False) -> None:\n        \"\"\"\n        Set the memory mode\n        \n        Args:\n            enabled: Whether memory is enabled\n            auto: Whether to automatically use memory\n            background: Whether to run memory processing in background\n        \"\"\"\n        if not enabled:\n            self.memory_mode = \"off\"\n        elif enabled and not auto:\n            self.memory_mode = \"manual\"\n        elif enabled and auto and not background:\n            self.memory_mode = \"auto\"\n        elif enabled and auto and background:\n            self.memory_mode = \"background\"\n            \n        self.log(f\"[Memory Mode] Set to: {self.memory_mode.capitalize()}\")\n        \n    def format_prompt(self, prompt: str, model_name: str) -> str:\n        \"\"\"\n        Format a prompt for the given model\n        \n        Args:\n            prompt: User prompt\n            model_name: Name of the model\n            \n        Returns:\n            Formatted prompt\n        \"\"\"\n        model = model_name.lower()\n        \n        # Create a context from the recent chat history (last few exchanges)\n        recent_history = []\n        history_limit = 5  # Number of recent exchanges to include\n        \n        # Get the recent history\n        if self.chat_history:\n            recent_history = self.chat_history[-min(len(self.chat_history), history_limit*2):]\n        \n        # Check memory mode and add relevant context if enabled\n        context = \"\"\n        if self.memory_mode in [\"Auto\", \"Background\"] and self.memory_system:\n            matches = self.memory_system.search(prompt)\n            if matches:\n                context = \"\\n\\nRelevant context from documents:\\n\"\n                for m in matches:\n                    source = m.get(\"source\", \"Unknown\")\n                    text_preview = m.get(\"text\", \"\")[:200]  # Get first 200 chars\n                    context += f\"From {source}: {text_preview}\\n\\n\"\n                \n                self.log(f\"[Memory] Added context from {len(matches)} relevant documents\")\n        \n        # Format based on the model\n        if any(k in model for k in [\"llama\", \"mistral\", \"nous\", \"mythomax\"]):\n            # Build chat context with system prompt\n            formatted_history = f\"<|system|>\\n{self.system_prompt}\\n\" if self.system_prompt else \"\"\n            \n            for msg in recent_history:\n                role = msg.get(\"role\", \"\")\n                content = msg.get(\"content\", \"\")\n                \n                if role == \"user\":\n                    formatted_history += f\"<|user|>\\n{content}\\n\"\n                elif role == \"assistant\":\n                    formatted_history += f\"<|assistant|>\\n{content}\\n\"\n            \n            # Add the current prompt\n            return context + formatted_history + f\"<|user|>\\n{prompt.strip()}\\n<|assistant|>\\n\"\n        \n        elif \"phi\" in model:\n            # Format for Phi models\n            formatted_history = f\"System: {self.system_prompt}\\n\\n\" if self.system_prompt else \"\"\n            \n            for msg in recent_history:\n                role = msg.get(\"role\", \"\")\n                content = msg.get(\"content\", \"\")\n                \n                if role == \"user\":\n                    formatted_history += f\"Human: {content}\\n\"\n                elif role == \"assistant\":\n                    formatted_history += f\"Assistant: {content}\\n\"\n            \n            # Add the current prompt\n            return context + formatted_history + f\"Human: {prompt.strip()}\\n\\nAssistant:\"\n        \n        elif \"codellama\" in model or \"deepseek\" in model:\n            # Specialized for code models\n            formatted = f\"\"\"\n            [INST] \n            {self.system_prompt}\n\n            {context if context else ''}\n            {prompt.strip()}\n            [/INST]\n            \"\"\"\n            return formatted\n        else:\n            # Generic format with conversation history\n            formatted_history = f\"System: {self.system_prompt}\\n\\n\" if self.system_prompt else \"\"\n            \n            for msg in recent_history:\n                role = msg.get(\"role\", \"\")\n                content = msg.get(\"content\", \"\")\n                \n                if role == \"user\":\n                    formatted_history += f\"User: {content}\\n\\n\"\n                elif role == \"assistant\":\n                    formatted_history += f\"Assistant: {content}\\n\\n\"\n            \n            # Add the current prompt\n            return context + formatted_history + f\"User: {prompt.strip()}\\n\\nAssistant:\"\n    \n    def add_user_message(self, content: str) -> None:\n        \"\"\"\n        Add a user message to the chat history\n        \n        Args:\n            content: Message content\n        \"\"\"\n        message = {\n            \"role\": \"user\", \n            \"content\": content,\n            \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\")\n        }\n        self.chat_history.append(message)\n        \n    def add_assistant_message(self, content: str, model: str) -> None:\n        \"\"\"\n        Add an assistant message to the chat history\n        \n        Args:\n            content: Message content\n            model: Model name\n        \"\"\"\n        message = {\n            \"role\": \"assistant\", \n            \"content\": content,\n            \"model\": model,\n            \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\")\n        }\n        self.chat_history.append(message)\n    \n    def send_message(self, content: str, on_response: Optional[Callable] = None) -> str:\n        \"\"\"\n        Send a message and get a response\n        \n        Args:\n            content: Message content\n            on_response: Optional callback for when response is ready\n            \n        Returns:\n            Response text\n        \"\"\"\n        # Add user message to history\n        self.add_user_message(content)\n        \n        # Check if model is running\n        if not self.model_manager.current_model:\n            error_msg = \"Model is not running. Please start a model first.\"\n            self.log(f\"[Error] {error_msg}\")\n            return error_msg\n        \n        try:\n            # Import the OllamaClient\n            from plugins.ollama_hub.core.ollama_client import OllamaClient\n            \n            # Create a client with our logger\n            ollama = OllamaClient(logger=self.log)\n            \n            # Format the prompt\n            model_name = self.model_manager.current_model\n            formatted_prompt = self.format_prompt(content, model_name)\n            \n            # Get model parameters if available\n            params = getattr(self.model_manager, 'current_parameters', {})\n            \n            # Log that we're sending the prompt\n            self.log(f\"[Prompt] Sending to model: {content[:100]}...\")\n            \n            # Send to model using direct Ollama API\n            success, response = ollama.generate(model_name, formatted_prompt, params)\n        except Exception as e:\n            success = False\n            response = f\"Error occurred: {str(e)}\"\n            self.log(f\"[Error] Exception while generating response: {e}\")\n        \n        if success and response:\n            # Add assistant message to history\n            self.add_assistant_message(response, model_name)\n            \n            # Save session\n            self.save_session()\n            \n            # Call callback if provided\n            if on_response:\n                on_response(response)\n                \n            return response\n        else:\n            error_msg = \"Failed to get response from model.\"\n            self.log(f\"[Error] {error_msg}\")\n            return error_msg\n            \n    def save_session(self) -> bool:\n        \"\"\"\n        Save the chat session to a file\n        \n        Returns:\n            True if session saved successfully, False otherwise\n        \"\"\"\n        try:\n            # Create directory if it doesn't exist\n            os.makedirs(os.path.dirname(self.session_file), exist_ok=True)\n            \n            with open(self.session_file, 'w', encoding='utf-8') as f:\n                json.dump(self.chat_history, f, indent=2)\n                \n            self.log(\"[Session] Session saved\")\n            return True\n        except Exception as e:\n            self.log(f\"[Session Error] Failed to save session: {e}\")\n            return False\n            \n    def load_session(self) -> bool:\n        \"\"\"\n        Load a chat session from a file\n        \n        Returns:\n            True if session loaded successfully, False otherwise\n        \"\"\"\n        if not os.path.exists(self.session_file):\n            self.log(\"[Session] No previous session found\")\n            return False\n            \n        try:\n            with open(self.session_file, 'r', encoding='utf-8') as f:\n                self.chat_history = json.load(f)\n                \n            self.log(f\"[Session] Loaded {len(self.chat_history)} messages\")\n            return True\n        except Exception as e:\n            self.log(f\"[Session Error] Failed to load session: {e}\")\n            return False\n            \n    def clear_history(self) -> None:\n        \"\"\"Clear the chat history\"\"\"\n        self.chat_history = []\n        self.log(\"[Session] Chat history cleared\")\n        \n    def get_last_model(self) -> Optional[str]:\n        \"\"\"\n        Get the last used model from chat history\n        \n        Returns:\n            Model name or None if not found\n        \"\"\"\n        if not self.chat_history:\n            return None\n            \n        # Find the last model entry\n        for entry in reversed(self.chat_history):\n            if \"model\" in entry:\n                return entry[\"model\"]\n                \n        return None\n        \n    def generate_reflection(self, reflection_path: str = \"data/reflections/session_reflections.json\") -> Dict[str, Any]:\n        \"\"\"\n        Generate a reflection on the current chat session\n        \n        Args:\n            reflection_path: Path to save the reflection\n            \n        Returns:\n            Reflection data dictionary\n        \"\"\"\n        reflection = {\n            \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"summary\": []\n        }\n        \n        # Get recent exchanges\n        recent_exchanges = self.chat_history[-min(5, len(self.chat_history)):]\n        \n        # Summarize exchanges\n        for entry in recent_exchanges:\n            if entry[\"role\"] == \"user\":\n                reflection[\"summary\"].append(f\"User asked: {entry['content']}\")\n            else:\n                content_preview = entry['content'][:150] + \"...\" if len(entry['content']) > 150 else entry['content']\n                reflection[\"summary\"].append(f\"Assistant responded: {content_preview}\")\n        \n        try:\n            # Create directory if it doesn't exist\n            os.makedirs(os.path.dirname(reflection_path), exist_ok=True)\n            \n            # Load existing reflections if any\n            existing_reflections = []\n            if os.path.exists(reflection_path):\n                try:\n                    with open(reflection_path, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                        if content.strip():\n                            # Handle trailing comma if present\n                            if content.strip().endswith(','):\n                                content = f\"[{content.strip()[:-1]}]\"\n                            else:\n                                content = f\"[{content}]\"\n                            existing_reflections = json.loads(content)\n                except:\n                    # If there's an issue with the file format, start fresh\n                    existing_reflections = []\n            \n            # Append new reflection\n            existing_reflections.append(reflection)\n            \n            # Save reflections\n            with open(reflection_path, 'w', encoding='utf-8') as f:\n                json.dump(existing_reflections, f, indent=2)\n                \n            self.log(f\"[Reflection] Saved to {reflection_path}\")\n            return reflection\n        except Exception as e:\n            self.log(f\"[Reflection Error] Failed to save reflection: {e}\")\n            return reflection",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\tests\\test_plugin.py": "\"\"\"\nBasic tests for the Ollama Hub plugin.\n\nThis module provides simple tests to verify the Ollama Hub plugin\nfunctionality is working correctly.\n\"\"\"\n\nimport unittest\nimport os\nimport sys\nimport logging\nimport json\nfrom unittest.mock import MagicMock, patch\n\n# Add parent directory to path for imports\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nclass MockCore:\n    \"\"\"Mock core system for testing\"\"\"\n    \n    def __init__(self):\n        self.event_bus = MagicMock()\n        self.config = MagicMock()\n        self.logger = logging.getLogger(\"test_logger\")\n        \n        # Setup logger to console\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.DEBUG)\n        \n    def log(self, message, level=\"INFO\"):\n        \"\"\"Log message with the specified level\"\"\"\n        log_method = getattr(self.logger, level.lower(), self.logger.info)\n        log_method(message)\n\nclass TestOllamaHubPlugin(unittest.TestCase):\n    \"\"\"Test cases for the Ollama Hub plugin\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up the test environment\"\"\"\n        from ollama_hub import IrintaiPlugin\n        \n        self.mock_core = MockCore()\n        self.plugin_id = \"ollama_hub_test\"\n        \n        # Create temporary config file path\n        self.config_path = os.path.join(os.path.dirname(__file__), \"test_config.json\")\n        \n        # Create plugin instance\n        self.plugin = IrintaiPlugin(\n            plugin_id=self.plugin_id,\n            core_system=self.mock_core,\n            config_path=self.config_path,\n            server_url=\"http://localhost:11434\"\n        )\n    \n    def tearDown(self):\n        \"\"\"Clean up after tests\"\"\"\n        # Remove test config file if it exists\n        if os.path.exists(self.config_path):\n            os.remove(self.config_path)\n    \n    def test_plugin_initialization(self):\n        \"\"\"Test that plugin initializes correctly\"\"\"\n        self.assertEqual(self.plugin.plugin_id, self.plugin_id)\n        self.assertEqual(self.plugin._state[\"status\"], self.plugin.STATUS[\"ACTIVE\"])\n        self.assertEqual(self.plugin._state[\"connection_status\"], \"Not connected\")\n    \n    def test_plugin_configuration(self):\n        \"\"\"Test plugin configuration\"\"\"\n        # Check default config\n        self.assertEqual(self.plugin._config.get(\"server_url\"), \"http://localhost:11434\")\n        self.assertEqual(self.plugin._config.get(\"auto_connect\"), True)\n        \n        # Update config and check if it persists\n        self.plugin.update_configuration(server_url=\"http://ollama.example.com:11434\")\n        self.assertEqual(self.plugin._config.get(\"server_url\"), \"http://ollama.example.com:11434\")\n        \n        # Check if config file was created\n        self.assertTrue(os.path.exists(self.config_path))\n        \n        # Read config file and check values\n        with open(self.config_path, 'r') as f:\n            config = json.load(f)\n            self.assertEqual(config.get(\"server_url\"), \"http://ollama.example.com:11434\")\n    \n    @patch('requests.get')\n    def test_connect_to_ollama(self, mock_get):\n        \"\"\"Test connecting to Ollama server\"\"\"\n        # Mock successful connection\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_get.return_value = mock_response\n        \n        # Test connection\n        self.plugin.connect_to_ollama()\n        \n        # Wait a bit for the background thread\n        import time\n        time.sleep(0.5)\n        \n        # Check if request was made correctly\n        mock_get.assert_called_once_with(\n            \"http://localhost:11434/api/tags\", \n            timeout=5\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\model_training_performance\\core\\model_training_performance.py": "\"\"\"\nModel training monitor plugin for IrintAI Assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk\nimport time\nimport threading\nimport json\nimport os\nfrom typing import Dict, Any, Callable, List, Optional\n\nclass IrintaiPlugin:\n    def __init__(self, plugin_id, core_system):\n        self.plugin_id = plugin_id\n        self.core_system = core_system\n        self.log = core_system.logger.log if hasattr(core_system, \"logger\") else print\n        \n        # Initialize plugin data\n        self.model_stats = {\n            \"tokens_per_second\": 0.0,\n            \"total_tokens\": 0,\n            \"batch_size\": 0,\n            \"model_temperature\": 0.0,\n            \"memory_allocated\": 0.0\n        }\n        \n        # Setup monitoring thread\n        self.running = False\n        self.monitor_thread = None\n        \n        # History tracking\n        self.tokens_history = []\n        self.memory_history = []\n        \n        # Create UI components\n        self.monitoring_frame = None\n        self.token_label = None\n        self.memory_label = None\n        self.batch_label = None\n        self.temperature_label = None\n        \n    def activate(self):\n        \"\"\"Activate the plugin\"\"\"\n        self.log(f\"Model Monitor Plugin activated\")\n        \n        # Start monitoring if model is running\n        if hasattr(self.core_system, \"model_manager\") and self.core_system.model_manager.is_model_running():\n            self.start_monitoring()\n            \n        # Register for model events\n        if hasattr(self.core_system, \"model_manager\"):\n            self.core_system.model_manager.register_event_handler(\n                \"model_started\", self.on_model_started\n            )\n            self.core_system.model_manager.register_event_handler(\n                \"model_stopped\", self.on_model_stopped\n            )\n        \n        return True\n        \n    def deactivate(self):\n        \"\"\"Deactivate the plugin\"\"\"\n        # Stop monitoring thread\n        self.stop_monitoring()\n        \n        # Unregister event handlers\n        if hasattr(self.core_system, \"model_manager\"):\n            self.core_system.model_manager.unregister_event_handler(\n                \"model_started\", self.on_model_started\n            )\n            self.core_system.model_manager.unregister_event_handler(\n                \"model_stopped\", self.on_model_stopped\n            )\n        \n        self.log(f\"Model Monitor Plugin deactivated\")\n        return True\n        \n    def get_resource_monitor_extensions(self):\n        \"\"\"\n        Get extensions for the resource monitor panel\n        \n        Returns:\n            Dictionary of resource monitor extensions\n        \"\"\"\n        return {\n            \"metrics\": {\n                \"tokens_per_second\": self.get_tokens_per_second,\n                \"model_memory\": self.get_model_memory_usage\n            },\n            \"collectors\": {\n                \"model_stats_collector\": self.collect_model_stats\n            },\n            \"ui_components\": [\n                self._create_monitoring_ui()\n            ]\n        }\n        \n    def _create_monitoring_ui(self):\n        \"\"\"\n        Create UI for model monitoring\n        \n        Returns:\n            UI frame component\n        \"\"\"\n        # Create the monitoring frame\n        self.monitoring_frame = ttk.LabelFrame(None, text=\"Model Performance Monitor\")\n        \n        # Add information labels\n        info_frame = ttk.Frame(self.monitoring_frame)\n        info_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Create a grid of labels\n        ttk.Label(info_frame, text=\"Tokens/sec:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)\n        self.token_label = ttk.Label(info_frame, text=\"0.0\")\n        self.token_label.grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(info_frame, text=\"Memory:\").grid(row=0, column=2, sticky=tk.W, padx=5, pady=2)\n        self.memory_label = ttk.Label(info_frame, text=\"0.0 MB\")\n        self.memory_label.grid(row=0, column=3, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(info_frame, text=\"Batch Size:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)\n        self.batch_label = ttk.Label(info_frame, text=\"0\")\n        self.batch_label.grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(info_frame, text=\"Temperature:\").grid(row=1, column=2, sticky=tk.W, padx=5, pady=2)\n        self.temperature_label = ttk.Label(info_frame, text=\"0.0\")\n        self.temperature_label.grid(row=1, column=3, sticky=tk.W, padx=5, pady=2)\n        \n        # Add controls\n        controls_frame = ttk.Frame(self.monitoring_frame)\n        controls_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Add toggle button\n        self.monitor_button = ttk.Button(\n            controls_frame,\n            text=\"Start Monitoring\" if not self.running else \"Stop Monitoring\",\n            command=self.toggle_monitoring\n        )\n        self.monitor_button.pack(side=tk.LEFT, padx=5)\n        \n        # Add reset button\n        ttk.Button(\n            controls_frame,\n            text=\"Reset Stats\",\n            command=self.reset_stats\n        ).pack(side=tk.LEFT, padx=5)\n        \n        return self.monitoring_frame\n        \n    def toggle_monitoring(self):\n        \"\"\"Toggle model monitoring on/off\"\"\"\n        if self.running:\n            self.stop_monitoring()\n        else:\n            self.start_monitoring()\n    \n    def start_monitoring(self):\n        \"\"\"Start the model monitoring thread\"\"\"\n        if self.running:\n            return\n            \n        self.running = True\n        self.monitor_thread = threading.Thread(target=self._monitor_thread_func, daemon=True)\n        self.monitor_thread.start()\n        \n        if hasattr(self, 'monitor_button'):\n            self.monitor_button.config(text=\"Stop Monitoring\")\n        \n        self.log(\"Model monitoring started\")\n    \n    def stop_monitoring(self):\n        \"\"\"Stop the model monitoring thread\"\"\"\n        self.running = False\n        \n        if hasattr(self, 'monitor_thread') and self.monitor_thread:\n            self.monitor_thread.join(timeout=1.0)\n            self.monitor_thread = None\n            \n        if hasattr(self, 'monitor_button'):\n            self.monitor_button.config(text=\"Start Monitoring\")\n            \n        self.log(\"Model monitoring stopped\")\n        \n    def reset_stats(self):\n        \"\"\"Reset monitoring statistics\"\"\"\n        self.model_stats = {\n            \"tokens_per_second\": 0.0,\n            \"total_tokens\": 0,\n            \"batch_size\": 0,\n            \"model_temperature\": 0.0,\n            \"memory_allocated\": 0.0\n        }\n        self.tokens_history.clear()\n        self.memory_history.clear()\n        self.log(\"Model monitoring statistics reset\")\n        \n    def _monitor_thread_func(self):\n        \"\"\"Background thread for monitoring model performance\"\"\"\n        last_token_count = 0\n        last_time = time.time()\n        \n        while self.running:\n            try:\n                # Simulate getting model statistics\n                # In a real plugin, this would fetch data from the model API\n                self._collect_simulated_stats()\n                \n                # Calculate tokens per second\n                current_time = time.time()\n                current_tokens = self.model_stats[\"total_tokens\"]\n                elapsed = current_time - last_time\n                \n                if elapsed > 0:\n                    tokens_per_sec = (current_tokens - last_token_count) / elapsed\n                    self.model_stats[\"tokens_per_second\"] = tokens_per_sec\n                    \n                    # Add to history\n                    self.tokens_history.append(tokens_per_sec)\n                    if len(self.tokens_history) > 60:\n                        self.tokens_history.pop(0)\n                        \n                    # Also track memory\n                    self.memory_history.append(self.model_stats[\"memory_allocated\"])\n                    if len(self.memory_history) > 60:\n                        self.memory_history.pop(0)\n                    \n                    # Update the UI\n                    if hasattr(self, 'token_label') and self.token_label:\n                        self._update_labels()\n                \n                last_token_count = current_tokens\n                last_time = current_time\n                \n            except Exception as e:\n                self.log(f\"Error in model monitoring thread: {e}\")\n                \n            time.sleep(1.0)\n    \n    def _collect_simulated_stats(self):\n        \"\"\"Collect simulated model stats for demonstration\"\"\"\n        # In a real plugin, this would query the model API\n        \n        # Get current stats\n        current_tokens = self.model_stats[\"total_tokens\"]\n        current_memory = self.model_stats[\"memory_allocated\"]\n        \n        # Simulate processing more tokens\n        import random\n        new_tokens = random.randint(5, 50)\n        self.model_stats[\"total_tokens\"] = current_tokens + new_tokens\n        \n        # Simulate memory changes\n        memory_change = random.uniform(-10, 30)\n        new_memory = max(50, current_memory + memory_change)\n        self.model_stats[\"memory_allocated\"] = new_memory\n        \n        # Update other stats occasionally\n        if random.random() < 0.1:\n            self.model_stats[\"batch_size\"] = random.randint(1, 8)\n        \n        if random.random() < 0.1:\n            self.model_stats[\"model_temperature\"] = round(random.uniform(0.1, 1.0), 2)\n    \n    def _update_labels(self):\n        \"\"\"Update the UI labels with current stats\"\"\"\n        if not hasattr(self, 'token_label') or not self.token_label:\n            return\n            \n        # Use after() to safely update from another thread\n        if hasattr(self.token_label, 'after'):\n            self.token_label.after(0, lambda: self._do_update_labels())\n    \n    def _do_update_labels(self):\n        \"\"\"Update labels on the main thread\"\"\"\n        try:\n            self.token_label.config(text=f\"{self.model_stats['tokens_per_second']:.1f}\")\n            self.memory_label.config(text=f\"{self.model_stats['memory_allocated']:.1f} MB\")\n            self.batch_label.config(text=f\"{self.model_stats['batch_size']}\")\n            self.temperature_label.config(text=f\"{self.model_stats['model_temperature']:.2f}\")\n        except Exception:\n            # Widget may have been destroyed\n            pass\n    \n    def get_tokens_per_second(self):\n        \"\"\"\n        Get tokens per second metric\n        \n        Returns:\n            Current tokens per second\n        \"\"\"\n        return self.model_stats[\"tokens_per_second\"]\n    \n    def get_model_memory_usage(self):\n        \"\"\"\n        Get model memory usage in MB\n        \n        Returns:\n            Current memory usage\n        \"\"\"\n        return self.model_stats[\"memory_allocated\"]\n    \n    def collect_model_stats(self, current_stats):\n        \"\"\"\n        Collect and provide model statistics\n        \n        Args:\n            current_stats: Current system stats\n            \n        Returns:\n            Dictionary of model stats to add\n        \"\"\"\n        return {\n            \"model_tokens_per_sec\": self.model_stats[\"tokens_per_second\"],\n            \"model_memory_mb\": self.model_stats[\"memory_allocated\"],\n            \"model_temperature\": self.model_stats[\"model_temperature\"],\n            \"model_batch_size\": self.model_stats[\"batch_size\"]\n        }\n    \n    def on_model_started(self, model_name, config):\n        \"\"\"\n        Handle model started event\n        \n        Args:\n            model_name: Name of the started model\n            config: Model configuration\n        \"\"\"\n        self.log(f\"Model started: {model_name}\")\n        self.reset_stats()\n        self.start_monitoring()\n    \n    def on_model_stopped(self):\n        \"\"\"Handle model stopped event\"\"\"\n        self.log(\"Model stopped\")\n        self.stop_monitoring()\n\n\n# Plugin metadata\nplugin_info = {\n    \"name\": \"Model Monitor\",\n    \"description\": \"Monitors and tracks model performance metrics\",\n    \"version\": \"1.0.0\",\n    \"author\": \"Irintai\",\n    \"url\": \"https://example.com/plugins/model_monitor\",\n    \"plugin_class\": IrintaiPlugin,\n    \"compatibility\": \"0.5.0\",\n    \"tags\": [\"model\", \"performance\", \"monitoring\"]\n}",
  "D:\\AI\\IrintAI Assistant\\ui\\panels\\plugin_panel.py": "\"\"\"\nPlugin panel UI component for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, messagebox, scrolledtext\nimport threading\nimport json\nimport os\nfrom typing import Callable, Dict, List, Any, Optional\nimport time\n\n# Constants for model status\nMODEL_STATUS = {\n    \"INSTALLED\": \"Installed\",\n    \"RUNNING\": \"Running\",\n    \"LOADING\": \"Loading\",\n    \"ERROR\": \"Error\",\n    \"NOT_INSTALLED\": \"Not Installed\"\n}\n\nclass PluginPanel:\n    \"\"\"Plugin management panel for discovering, loading, and configuring plugins\"\"\"\n    \n    def __init__(self, parent, plugin_manager, config_manager=None, logger: Callable=None):\n        \"\"\"\n        Initialize the plugin panel\n        \n        Args:\n            parent: Parent widget\n            plugin_manager: PluginManager instance\n            config_manager: Configuration manager instance\n            logger: Logging function\n        \"\"\"\n        self.parent = parent\n        self.plugin_manager = plugin_manager\n        self.config_manager = config_manager\n        self.log = logger\n        \n        # Add this line:\n        self.is_running = True\n        \n        # Track when the frame is destroyed\n        self.frame = ttk.Frame(parent)\n        self.frame.bind(\"<Destroy>\", self._on_destroy)\n        \n        # Current plugin being configured (for settings tab)\n        self.current_plugin_id = None\n        self.current_config = {}\n        self.config_widgets = {}\n        \n        # Initialize UI components\n        self.initialize_ui()\n        \n        # Refresh plugin list\n        self.refresh_plugin_list()\n    \n    def initialize_ui(self):\n        \"\"\"Initialize the UI components\"\"\"\n        # Create notebook for tabbed interface\n        self.notebook = ttk.Notebook(self.frame)\n        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create local plugins tab\n        self.local_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.local_frame, text=\"Local Plugins\")\n        \n        # Create marketplace tab\n        self.marketplace_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.marketplace_frame, text=\"Plugin Marketplace\")\n        \n        # Create sandbox tab\n        self.sandbox_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.sandbox_frame, text=\"Plugin Sandbox\")\n        \n        # Create settings tab for plugin configuration\n        self.settings_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.settings_frame, text=\"Plugin Settings\")\n\n        # Setup local plugins tab\n        self.setup_local_plugins_tab()\n        \n        # Setup marketplace tab\n        self.setup_marketplace_tab()\n        \n        # Setup sandbox tab\n        self.setup_sandbox_tab()\n        \n        # Setup settings tab\n        self.setup_settings_tab()\n        \n        # Create progress bar\n        self.create_progress_bar()\n\n    def setup_local_plugins_tab(self):\n        \"\"\"Setup the local plugins tab\"\"\"\n        # Create plugin discovery section\n        self.create_discovery_section()\n        \n        # Create plugin management section\n        self.create_management_section()\n        \n        # Create plugin information section\n        self.create_info_section()\n\n    def setup_marketplace_tab(self):\n        \"\"\"Setup the plugin marketplace tab\"\"\"\n        # Create search frame\n        search_frame = ttk.Frame(self.marketplace_frame)\n        search_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        ttk.Label(search_frame, text=\"Search Plugins:\").pack(side=tk.LEFT)\n        \n        self.search_var = tk.StringVar()\n        search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)\n        search_entry.pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            search_frame,\n            text=\"Search\",\n            command=self.search_marketplace\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Repository selector\n        repo_frame = ttk.Frame(search_frame)\n        repo_frame.pack(side=tk.RIGHT)\n        \n        ttk.Label(repo_frame, text=\"Repository:\").pack(side=tk.LEFT)\n        \n        self.repo_var = tk.StringVar(value=\"Official\")\n        repo_combobox = ttk.Combobox(\n            repo_frame,\n            textvariable=self.repo_var,\n            values=[\"Official\", \"Community\", \"All\"],\n            state=\"readonly\",\n            width=12\n        )\n        repo_combobox.pack(side=tk.LEFT, padx=5)\n        \n        # Create marketplace results treeview\n        marketplace_frame = ttk.LabelFrame(self.marketplace_frame, text=\"Available Plugins\")\n        marketplace_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create a tree view for marketplace plugins\n        columns = (\"Name\", \"Version\", \"Rating\", \"Downloads\")\n        self.marketplace_tree = ttk.Treeview(\n            marketplace_frame,\n            columns=columns,\n            show=\"headings\",\n            selectmode=\"browse\",\n            height=10\n        )\n        \n        # Configure columns\n        self.marketplace_tree.heading(\"Name\", text=\"Plugin Name\")\n        self.marketplace_tree.heading(\"Version\", text=\"Version\")\n        self.marketplace_tree.heading(\"Rating\", text=\"Rating\")\n        self.marketplace_tree.heading(\"Downloads\", text=\"Downloads\")\n        \n        self.marketplace_tree.column(\"Name\", width=200, anchor=tk.W)\n        self.marketplace_tree.column(\"Version\", width=80, anchor=tk.CENTER)\n        self.marketplace_tree.column(\"Rating\", width=80, anchor=tk.CENTER)\n        self.marketplace_tree.column(\"Downloads\", width=100, anchor=tk.CENTER)\n        \n        # Add scrollbar\n        scrollbar = ttk.Scrollbar(marketplace_frame, orient=\"vertical\", command=self.marketplace_tree.yview)\n        self.marketplace_tree.configure(yscrollcommand=scrollbar.set)\n        \n        # Pack the tree and scrollbar\n        self.marketplace_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        # Bind selection event\n        self.marketplace_tree.bind(\"<<TreeviewSelect>>\", self.on_marketplace_selected)\n        \n        # Plugin details section\n        details_frame = ttk.LabelFrame(self.marketplace_frame, text=\"Plugin Details\")\n        details_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Plugin description\n        ttk.Label(details_frame, text=\"Description:\").pack(anchor=tk.W, padx=10, pady=(5, 0))\n        \n        self.market_description = scrolledtext.ScrolledText(details_frame, height=5, wrap=tk.WORD)\n        self.market_description.pack(fill=tk.X, padx=10, pady=5)\n        \n        # Plugin metadata\n        meta_frame = ttk.Frame(details_frame)\n        meta_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        # Author and rating info\n        left_meta = ttk.Frame(meta_frame)\n        left_meta.pack(side=tk.LEFT, fill=tk.X, expand=True)\n        \n        ttk.Label(left_meta, text=\"Author:\").grid(row=0, column=0, sticky=tk.W, padx=5)\n        self.market_author_var = tk.StringVar(value=\"-\")\n        ttk.Label(left_meta, textvariable=self.market_author_var).grid(row=0, column=1, sticky=tk.W, padx=5)\n        \n        ttk.Label(left_meta, text=\"Category:\").grid(row=1, column=0, sticky=tk.W, padx=5)\n        self.market_category_var = tk.StringVar(value=\"-\")\n        ttk.Label(left_meta, textvariable=self.market_category_var).grid(row=1, column=1, sticky=tk.W, padx=5)\n        \n        # Size and release info\n        right_meta = ttk.Frame(meta_frame)\n        right_meta.pack(side=tk.RIGHT, fill=tk.X, expand=True)\n        \n        ttk.Label(right_meta, text=\"Last Updated:\").grid(row=0, column=0, sticky=tk.W, padx=5)\n        self.market_updated_var = tk.StringVar(value=\"-\")\n        ttk.Label(right_meta, textvariable=self.market_updated_var).grid(row=0, column=1, sticky=tk.W, padx=5)\n        \n        ttk.Label(right_meta, text=\"Size:\").grid(row=1, column=0, sticky=tk.W, padx=5)\n        self.market_size_var = tk.StringVar(value=\"-\")\n        ttk.Label(right_meta, textvariable=self.market_size_var).grid(row=1, column=1, sticky=tk.W, padx=5)\n        \n        # Dependencies section\n        ttk.Label(details_frame, text=\"Dependencies:\").pack(anchor=tk.W, padx=10, pady=(5, 0))\n        \n        self.dependencies_var = tk.StringVar(value=\"None\")\n        ttk.Label(\n            details_frame,\n            textvariable=self.dependencies_var,\n            wraplength=400\n        ).pack(anchor=tk.W, padx=20, pady=5)\n        \n        # Action buttons\n        action_frame = ttk.Frame(details_frame)\n        action_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        ttk.Button(\n            action_frame,\n            text=\"Install Plugin\",\n            command=self.install_marketplace_plugin\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            action_frame,\n            text=\"Visit Website\",\n            command=self.visit_plugin_website\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Add dependency view button\n        self.dependency_button = ttk.Button(\n            action_frame,\n            text=\"View Dependencies\",\n            command=self.view_plugin_dependencies\n        )\n        self.dependency_button.pack(side=tk.LEFT, padx=5)\n        \n        # Add update button\n        self.update_button = ttk.Button(\n            action_frame,\n            text=\"Check for Updates\",\n            command=self.check_plugin_updates\n        )\n        self.update_button.pack(side=tk.RIGHT, padx=5)\n\n    def create_progress_bar(self):\n        \"\"\"Create the progress bar\"\"\"\n        progress_frame = ttk.Frame(self.frame)\n        progress_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        # Progress bar\n        self.progress_var = tk.DoubleVar(value=0.0)\n        self.progress_bar = ttk.Progressbar(\n            progress_frame,\n            variable=self.progress_var,\n            mode=\"indeterminate\",\n            length=100\n        )\n        self.progress_bar.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Status text\n        self.status_var = tk.StringVar(value=\"Ready\")\n        status_label = ttk.Label(progress_frame, textvariable=self.status_var)\n        status_label.pack(anchor=tk.W, padx=5)\n        \n    def refresh_plugin_list(self):\n        \"\"\"Refresh the plugin list\"\"\"\n        # Clear the current tree\n        for item in self.plugin_tree.get_children():\n            self.plugin_tree.delete(item)\n            \n        # Update progress bar\n        self.progress_bar.start()\n        self.status_var.set(\"Discovering plugins...\")\n        \n        # Start discovery in a separate thread\n        threading.Thread(\n            target=self._discover_plugins_thread,\n            daemon=True\n        ).start()\n    \n    def _discover_plugins_thread(self):\n        \"\"\"Discover plugins in a background thread\"\"\"\n        # Discover plugins\n        self.plugin_manager.discover_plugins()\n        \n        # Get plugin information\n        plugins_info = self.plugin_manager.get_all_plugins()\n        \n        # Only try to update UI if we're still running\n        if self.is_running:\n            try:\n                # Schedule update on main thread\n                self.frame.after(0, lambda: self._update_plugin_tree(plugins_info))\n            except Exception:\n                # Silently fail if we can't update\n                pass\n        \n    def _update_plugin_tree(self, plugins_info):\n        \"\"\"\n        Update the plugin tree with discovered plugins\n        \n        Args:\n            plugins_info: Dictionary of plugin information\n        \"\"\"\n        # Clear current items\n        for item in self.plugin_tree.get_children():\n            self.plugin_tree.delete(item)\n            \n        # Add plugins to tree\n        for plugin_name, info in plugins_info.items():\n            self.plugin_tree.insert(\n                \"\",\n                tk.END,\n                values=(\n                    plugin_name,\n                    info.get(\"version\", \"Unknown\"),\n                    info.get(\"status\", \"Unknown\"),\n                    info.get(\"author\", \"Unknown\")\n                )\n            )\n            \n        # Stop progress bar\n        self.progress_bar.stop()\n        self.status_var.set(f\"Found {len(plugins_info)} plugins\")\n        \n        # Select first item if available\n        if self.plugin_tree.get_children():\n            first_item = self.plugin_tree.get_children()[0]\n            self.plugin_tree.selection_set(first_item)\n            self.on_plugin_selected()\n            \n    def on_plugin_selected(self, event=None):\n        \"\"\"Handle plugin selection in the tree\"\"\"\n        selection = self.plugin_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected plugin info\n        item = selection[0]\n        values = self.plugin_tree.item(item, \"values\")\n        \n        plugin_name = values[0]\n        plugin_status = values[2]\n        \n        # Get detailed metadata\n        metadata = self.plugin_manager.get_plugin_metadata(plugin_name)\n        \n        # Update info display\n        self.selected_name_var.set(plugin_name)\n        self.selected_status_var.set(plugin_status)\n        self.selected_version_var.set(metadata.get(\"version\", \"Unknown\"))\n        self.selected_author_var.set(metadata.get(\"author\", \"Unknown\"))\n        self.selected_license_var.set(metadata.get(\"license\", \"Unknown\"))\n        \n        # Set location\n        plugin_path = os.path.join(self.plugin_manager.plugin_dir, plugin_name)\n        self.selected_location_var.set(plugin_path)\n        \n        # Update description\n        self.description_text.config(state=tk.NORMAL)\n        self.description_text.delete(1.0, tk.END)\n        self.description_text.insert(tk.END, metadata.get(\"description\", \"No description available\"))\n        self.description_text.config(state=tk.DISABLED)\n        \n        # Update configuration display\n        self.update_config_display(plugin_name)\n        \n        # Update button states based on plugin status\n        self._update_button_states(plugin_status)\n        \n    def _update_button_states(self, status):\n        \"\"\"\n        Update button states based on plugin status\n        \n        Args:\n            status: Current plugin status\n        \"\"\"\n        # Load button - enabled if not loaded\n        self.load_button.config(\n            state=tk.NORMAL if status in [\"Not Loaded\", \"Error\"] else tk.DISABLED\n        )\n        \n        # Activate button - enabled if loaded but not active\n        self.activate_button.config(\n            state=tk.NORMAL if status in [\"Loaded\", \"Inactive\"] else tk.DISABLED\n        )\n        \n        # Deactivate button - enabled if active\n        self.deactivate_button.config(\n            state=tk.NORMAL if status == \"Active\" else tk.DISABLED\n        )\n        \n        # Reload button - enabled if loaded\n        self.reload_button.config(\n            state=tk.NORMAL if status in [\"Loaded\", \"Active\", \"Inactive\"] else tk.DISABLED\n        )\n        \n    def update_config_display(self, plugin_name):\n        \"\"\"\n        Update the configuration display for a plugin\n        \n        Args:\n            plugin_name: Name of the plugin\n        \"\"\"\n        # Clear current content\n        self.config_text.config(state=tk.NORMAL)\n        self.config_text.delete(1.0, tk.END)\n        \n        # Get plugin config path\n        config_path = os.path.join(self.plugin_manager.config_dir, plugin_name, \"config.json\")\n        \n        # Check if config exists\n        if os.path.exists(config_path):\n            try:\n                with open(config_path, 'r') as f:\n                    config = json.load(f)\n                    \n                # Format config as JSON\n                formatted_config = json.dumps(config, indent=2)\n                self.config_text.insert(tk.END, formatted_config)\n            except Exception as e:\n                self.config_text.insert(tk.END, f\"Error loading configuration: {e}\")\n        else:\n            self.config_text.insert(tk.END, \"No configuration file found\")\n            \n        # Make editable\n        self.config_text.config(state=tk.NORMAL)\n        \n    def load_selected_plugin(self):\n        \"\"\"Load the selected plugin\"\"\"\n        selection = self.plugin_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected plugin\n        item = selection[0]\n        values = self.plugin_tree.item(item, \"values\")\n        plugin_name = values[0]\n        \n        # Update status\n        self.status_var.set(f\"Loading plugin: {plugin_name}...\")\n        self.progress_bar.start()\n        \n        # Load in a separate thread\n        threading.Thread(\n            target=self._load_plugin_thread,\n            args=(plugin_name,),\n            daemon=True\n        ).start()\n        \n    def _load_plugin_thread(self, plugin_name):\n        \"\"\"\n        Load a plugin in a background thread\n        \n        Args:\n            plugin_name: Name of the plugin to load\n        \"\"\"\n        # Load the plugin\n        success = self.plugin_manager.load_plugin(plugin_name)\n        \n        # Update UI on main thread\n        self.frame.after(0, lambda: self._on_plugin_loaded(plugin_name, success))\n        \n    def _on_plugin_loaded(self, plugin_name, success):\n        \"\"\"\n        Handle plugin loading completion\n        \n        Args:\n            plugin_name: Name of the plugin\n            success: Whether loading was successful\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        if success:\n            self.status_var.set(f\"Plugin loaded successfully: {plugin_name}\")\n            \n            # Update plugin info in tree\n            plugins_info = self.plugin_manager.get_all_plugins()\n            info = plugins_info.get(plugin_name, {})\n            \n            for item in self.plugin_tree.get_children():\n                values = self.plugin_tree.item(item, \"values\")\n                if values[0] == plugin_name:\n                    self.plugin_tree.item(\n                        item,\n                        values=(\n                            plugin_name,\n                            info.get(\"version\", \"Unknown\"),\n                            info.get(\"status\", \"Unknown\"),\n                            info.get(\"author\", \"Unknown\")\n                        )\n                    )\n                    break\n                    \n            # Update selection info\n            if self.selected_name_var.get() == plugin_name:\n                self.selected_status_var.set(info.get(\"status\", \"Unknown\"))\n                self._update_button_states(info.get(\"status\", \"Unknown\"))\n        else:\n            self.status_var.set(f\"Failed to load plugin: {plugin_name}\")\n            \n    def activate_selected_plugin(self):\n        \"\"\"Activate the selected plugin\"\"\"\n        selection = self.plugin_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected plugin\n        item = selection[0]\n        values = self.plugin_tree.item(item, \"values\")\n        plugin_name = values[0]\n        \n        # Update status\n        self.status_var.set(f\"Activating plugin: {plugin_name}...\")\n        self.progress_bar.start()\n        \n        # Activate in a separate thread\n        threading.Thread(\n            target=self._activate_plugin_thread,\n            args=(plugin_name,),\n            daemon=True\n        ).start()\n        \n    def _activate_plugin_thread(self, plugin_name):\n        \"\"\"\n        Activate a plugin in a background thread\n        \n        Args:\n            plugin_name: Name of the plugin to activate\n        \"\"\"\n        # Activate the plugin\n        success = self.plugin_manager.activate_plugin(plugin_name)\n        \n        # Update UI on main thread\n        self.frame.after(0, lambda: self._on_plugin_activated(plugin_name, success))\n        \n    def _on_plugin_activated(self, plugin_name, success):\n        \"\"\"\n        Handle plugin activation completion\n        \n        Args:\n            plugin_name: Name of the plugin\n            success: Whether activation was successful\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        if success:\n            self.status_var.set(f\"Plugin activated successfully: {plugin_name}\")\n            \n            # Update plugin info in tree\n            plugins_info = self.plugin_manager.get_all_plugins()\n            info = plugins_info.get(plugin_name, {})\n            \n            for item in self.plugin_tree.get_children():\n                values = self.plugin_tree.item(item, \"values\")\n                if values[0] == plugin_name:\n                    self.plugin_tree.item(\n                        item,\n                        values=(\n                            plugin_name,\n                            info.get(\"version\", \"Unknown\"),\n                            info.get(\"status\", \"Unknown\"),\n                            info.get(\"author\", \"Unknown\")\n                        )\n                    )\n                    break\n                    \n            # Update selection info\n            if self.selected_name_var.get() == plugin_name:\n                self.selected_status_var.set(info.get(\"status\", \"Unknown\"))\n                self._update_button_states(info.get(\"status\", \"Unknown\"))\n        else:\n            self.status_var.set(f\"Failed to activate plugin: {plugin_name}\")\n            \n    def deactivate_selected_plugin(self):\n        \"\"\"Deactivate the selected plugin\"\"\"\n        selection = self.plugin_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected plugin\n        item = selection[0]\n        values = self.plugin_tree.item(item, \"values\")\n        plugin_name = values[0]\n        \n        # Update status\n        self.status_var.set(f\"Deactivating plugin: {plugin_name}...\")\n        self.progress_bar.start()\n        \n        # Deactivate in a separate thread\n        threading.Thread(\n            target=self._deactivate_plugin_thread,\n            args=(plugin_name,),\n            daemon=True\n        ).start()\n        \n    def _deactivate_plugin_thread(self, plugin_name):\n        \"\"\"\n        Deactivate a plugin in a background thread\n        \n        Args:\n            plugin_name: Name of the plugin to deactivate\n        \"\"\"\n        # Deactivate the plugin\n        success = self.plugin_manager.deactivate_plugin(plugin_name)\n        \n        # Update UI on main thread\n        self.frame.after(0, lambda: self._on_plugin_deactivated(plugin_name, success))\n        \n    def _on_plugin_deactivated(self, plugin_name, success):\n        \"\"\"\n        Handle plugin deactivation completion\n        \n        Args:\n            plugin_name: Name of the plugin\n            success: Whether deactivation was successful\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        if success:\n            self.status_var.set(f\"Plugin deactivated successfully: {plugin_name}\")\n            \n            # Update plugin info in tree\n            plugins_info = self.plugin_manager.get_all_plugins()\n            info = plugins_info.get(plugin_name, {})\n            \n            for item in self.plugin_tree.get_children():\n                values = self.plugin_tree.item(item, \"values\")\n                if values[0] == plugin_name:\n                    self.plugin_tree.item(\n                        item,\n                        values=(\n                            plugin_name,\n                            info.get(\"version\", \"Unknown\"),\n                            info.get(\"status\", \"Unknown\"),\n                            info.get(\"author\", \"Unknown\")\n                        )\n                    )\n                    break\n                    \n            # Update selection info\n            if self.selected_name_var.get() == plugin_name:\n                self.selected_status_var.set(info.get(\"status\", \"Unknown\"))\n                self._update_button_states(info.get(\"status\", \"Unknown\"))\n        else:\n            self.status_var.set(f\"Failed to deactivate plugin: {plugin_name}\")\n            \n    def reload_selected_plugin(self):\n        \"\"\"Reload the selected plugin\"\"\"\n        selection = self.plugin_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected plugin\n        item = selection[0]\n        values = self.plugin_tree.item(item, \"values\")\n        plugin_name = values[0]\n        \n        # Confirm reload\n        result = messagebox.askyesno(\n            \"Reload Plugin\",\n            f\"Are you sure you want to reload the plugin '{plugin_name}'?\\n\\n\"\n            \"This will deactivate the plugin, unload it, and load it again.\",\n            icon=messagebox.WARNING\n        )\n        \n        if not result:\n            return\n            \n        # Update status\n        self.status_var.set(f\"Reloading plugin: {plugin_name}...\")\n        self.progress_bar.start()\n        \n        # Reload in a separate thread\n        threading.Thread(\n            target=self._reload_plugin_thread,\n            args=(plugin_name,),\n            daemon=True\n        ).start()\n        \n    def _reload_plugin_thread(self, plugin_name):\n        \"\"\"\n        Reload a plugin in a background thread\n        \n        Args:\n            plugin_name: Name of the plugin to reload\n        \"\"\"\n        # Reload the plugin\n        success = self.plugin_manager.reload_plugin(plugin_name)\n        \n        # Update UI on main thread\n        self.frame.after(0, lambda: self._on_plugin_reloaded(plugin_name, success))\n        \n    def _on_plugin_reloaded(self, plugin_name, success):\n        \"\"\"\n        Handle plugin reload completion\n        \n        Args:\n            plugin_name: Name of the plugin\n            success: Whether reload was successful\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        if success:\n            self.status_var.set(f\"Plugin reloaded successfully: {plugin_name}\")\n            \n            # Update plugin info in tree\n            plugins_info = self.plugin_manager.get_all_plugins()\n            info = plugins_info.get(plugin_name, {})\n            \n            for item in self.plugin_tree.get_children():\n                values = self.plugin_tree.item(item, \"values\")\n                if values[0] == plugin_name:\n                    self.plugin_tree.item(\n                        item,\n                        values=(\n                            plugin_name,\n                            info.get(\"version\", \"Unknown\"),\n                            info.get(\"status\", \"Unknown\"),\n                            info.get(\"author\", \"Unknown\")\n                        )\n                    )\n                    break\n                    \n            # Update selection info\n            if self.selected_name_var.get() == plugin_name:\n                self.selected_status_var.set(info.get(\"status\", \"Unknown\"))\n                self._update_button_states(info.get(\"status\", \"Unknown\"))\n                \n            # Update config display\n            self.update_config_display(plugin_name)\n        else:\n            self.status_var.set(f\"Failed to reload plugin: {plugin_name}\")\n            \n    def load_config(self):\n        \"\"\"Load configuration from file\"\"\"\n        plugin_name = self.selected_name_var.get()\n        if plugin_name == \"None\":\n            return\n            \n        # Get config path\n        config_path = os.path.join(self.plugin_manager.config_dir, plugin_name, \"config.json\")\n        \n        # Check if config exists\n        if os.path.exists(config_path):\n            try:\n                with open(config_path, 'r') as f:\n                    config = json.load(f)\n                    \n                # Format config as JSON\n                formatted_config = json.dumps(config, indent=2)\n                \n                # Update display\n                self.config_text.config(state=tk.NORMAL)\n                self.config_text.delete(1.0, tk.END)\n                self.config_text.insert(tk.END, formatted_config)\n                \n                self.status_var.set(f\"Configuration loaded for {plugin_name}\")\n            except Exception as e:\n                messagebox.showerror(\"Error\", f\"Failed to load configuration: {e}\")\n        else:\n            messagebox.showinfo(\"Information\", \"No configuration file found\")\n\n    def create_discovery_section(self): # <<< ADD THIS METHOD\n        \"\"\"Create the plugin discovery and refresh section\"\"\"\n        discovery_frame = ttk.LabelFrame(self.local_frame, text=\"Plugin Discovery\")\n        discovery_frame.pack(fill=tk.X, padx=10, pady=10, anchor=tk.N)\n\n        # Refresh button\n        ttk.Button(\n            discovery_frame,\n            text=\"Refresh Plugin List\",\n            command=self.refresh_plugin_list\n        ).pack(side=tk.LEFT, padx=5, pady=5)\n\n        # Open plugin folder button\n        ttk.Button(\n            discovery_frame,\n            text=\"Open Plugin Folder\",\n            command=self.open_plugin_folder # Assumes this method exists or will be added\n        ).pack(side=tk.LEFT, padx=5, pady=5)\n\n    def create_management_section(self): # <<< ADD THIS METHOD\n        \"\"\"Create the plugin management section with the list\"\"\"\n        management_frame = ttk.LabelFrame(self.local_frame, text=\"Installed Plugins\")\n        management_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n\n        # Create a tree view for plugins\n        columns = (\"Name\", \"Version\", \"Status\", \"Author\")\n        self.plugin_tree = ttk.Treeview(\n            management_frame,\n            columns=columns,\n            show=\"headings\",\n            selectmode=\"browse\",\n            height=8 # Adjust height as needed\n        )\n\n        # Configure columns\n        self.plugin_tree.heading(\"Name\", text=\"Plugin Name\")\n        self.plugin_tree.heading(\"Version\", text=\"Version\")\n        self.plugin_tree.heading(\"Status\", text=\"Status\")\n        self.plugin_tree.heading(\"Author\", text=\"Author\")\n\n        self.plugin_tree.column(\"Name\", width=180, anchor=tk.W)\n        self.plugin_tree.column(\"Version\", width=80, anchor=tk.CENTER)\n        self.plugin_tree.column(\"Status\", width=100, anchor=tk.CENTER)\n        self.plugin_tree.column(\"Author\", width=120, anchor=tk.W)\n\n        # Add scrollbar\n        scrollbar = ttk.Scrollbar(management_frame, orient=\"vertical\", command=self.plugin_tree.yview)\n        self.plugin_tree.configure(yscrollcommand=scrollbar.set)\n\n        # Pack the tree and scrollbar\n        self.plugin_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5,0), pady=5)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y, padx=(0,5), pady=5)\n\n        # Bind selection event\n        self.plugin_tree.bind(\"<<TreeviewSelect>>\", self.on_plugin_selected)\n\n        # --- Action buttons for selected plugin ---\n        action_frame = ttk.Frame(management_frame)\n        # Place action frame to the right or below the tree as desired\n        # Example: Packing below\n        action_frame.pack(fill=tk.X, padx=5, pady=5)\n\n        self.load_button = ttk.Button(\n            action_frame,\n            text=\"Load\",\n            command=self.load_selected_plugin,\n            state=tk.DISABLED\n        )\n        self.load_button.pack(side=tk.LEFT, padx=2)\n\n        self.activate_button = ttk.Button(\n            action_frame,\n            text=\"Activate\",\n            command=self.activate_selected_plugin,\n            state=tk.DISABLED\n        )\n        self.activate_button.pack(side=tk.LEFT, padx=2)\n\n        self.deactivate_button = ttk.Button(\n            action_frame,\n            text=\"Deactivate\",\n            command=self.deactivate_selected_plugin,\n            state=tk.DISABLED\n        )\n        self.deactivate_button.pack(side=tk.LEFT, padx=2)\n\n        self.reload_button = ttk.Button(\n            action_frame,\n            text=\"Reload\",\n            command=self.reload_selected_plugin,\n            state=tk.DISABLED\n        )\n        self.reload_button.pack(side=tk.LEFT, padx=2)\n\n\n    def create_info_section(self): # <<< ADD THIS METHOD\n        \"\"\"Create the plugin information display section\"\"\"\n        info_frame = ttk.LabelFrame(self.local_frame, text=\"Plugin Information\")\n        info_frame.pack(fill=tk.X, padx=10, pady=10)\n\n        # Grid for details\n        details_grid = ttk.Frame(info_frame)\n        details_grid.pack(fill=tk.X, padx=5, pady=5)\n        details_grid.columnconfigure(1, weight=1) # Make value column expandable\n\n        # Name\n        ttk.Label(details_grid, text=\"Name:\", width=10).grid(row=0, column=0, sticky=tk.W, padx=5, pady=1)\n        self.selected_name_var = tk.StringVar(value=\"None\")\n        ttk.Label(details_grid, textvariable=self.selected_name_var, font=(\"Helvetica\", 10, \"bold\")).grid(row=0, column=1, sticky=tk.W, padx=5, pady=1)\n\n        # Status\n        ttk.Label(details_grid, text=\"Status:\", width=10).grid(row=1, column=0, sticky=tk.W, padx=5, pady=1)\n        self.selected_status_var = tk.StringVar(value=\"N/A\")\n        ttk.Label(details_grid, textvariable=self.selected_status_var).grid(row=1, column=1, sticky=tk.W, padx=5, pady=1)\n\n        # Version\n        ttk.Label(details_grid, text=\"Version:\", width=10).grid(row=2, column=0, sticky=tk.W, padx=5, pady=1)\n        self.selected_version_var = tk.StringVar(value=\"N/A\")\n        ttk.Label(details_grid, textvariable=self.selected_version_var).grid(row=2, column=1, sticky=tk.W, padx=5, pady=1)\n\n        # Author\n        ttk.Label(details_grid, text=\"Author:\", width=10).grid(row=3, column=0, sticky=tk.W, padx=5, pady=1)\n        self.selected_author_var = tk.StringVar(value=\"N/A\")\n        ttk.Label(details_grid, textvariable=self.selected_author_var).grid(row=3, column=1, sticky=tk.W, padx=5, pady=1)\n\n        # License\n        ttk.Label(details_grid, text=\"License:\", width=10).grid(row=4, column=0, sticky=tk.W, padx=5, pady=1)\n        self.selected_license_var = tk.StringVar(value=\"N/A\")\n        ttk.Label(details_grid, textvariable=self.selected_license_var).grid(row=4, column=1, sticky=tk.W, padx=5, pady=1)\n\n        # Location\n        ttk.Label(details_grid, text=\"Location:\", width=10).grid(row=5, column=0, sticky=tk.W, padx=5, pady=1)\n        self.selected_location_var = tk.StringVar(value=\"N/A\")\n        ttk.Label(details_grid, textvariable=self.selected_location_var, wraplength=400).grid(row=5, column=1, sticky=tk.W, padx=5, pady=1)\n\n\n        # Description section\n        desc_frame = ttk.Frame(info_frame)\n        desc_frame.pack(fill=tk.X, padx=5, pady=5)\n        ttk.Label(desc_frame, text=\"Description:\").pack(anchor=tk.W)\n\n        self.description_text = scrolledtext.ScrolledText(\n            desc_frame,\n            height=4,\n            wrap=tk.WORD,\n            font=(\"Helvetica\", 9)\n        )\n        self.description_text.pack(fill=tk.X, padx=5, pady=(0,5))\n        self.description_text.config(state=tk.DISABLED) # Start disabled\n\n        # Configuration section (Read-only view)\n        config_frame = ttk.Frame(info_frame)\n        config_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        ttk.Label(config_frame, text=\"Configuration (View only - Edit in Plugin Settings):\").pack(anchor=tk.W)\n\n        self.config_text = scrolledtext.ScrolledText(\n            config_frame,\n            height=5,\n            wrap=tk.WORD,\n            font=(\"Courier New\", 9)\n        )\n        self.config_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0,5))\n        self.config_text.config(state=tk.DISABLED) # Start disabled\n\n    # --- Add the missing open_plugin_folder method ---\n    def open_plugin_folder(self): # <<< ADD THIS METHOD\n        \"\"\"Open the plugin folder in file explorer\"\"\"\n        import os\n        import subprocess\n        import sys\n\n        plugin_dir = self.plugin_manager.plugin_dir\n\n        try:\n            if not os.path.exists(plugin_dir):\n                os.makedirs(plugin_dir, exist_ok=True)\n\n            # Open folder based on OS\n            if os.name == 'nt':  # Windows\n                os.startfile(plugin_dir)\n            elif os.name == 'posix':  # macOS, Linux\n                subprocess.run(['open' if sys.platform == 'darwin' else 'xdg-open', plugin_dir])\n\n            self.log(f\"[Opened] Plugin folder: {plugin_dir}\")\n        except Exception as e:\n            self.log(f\"[Error] Cannot open plugin folder: {e}\")\n            messagebox.showerror(\"Error\", f\"Cannot open plugin folder: {e}\")\n\n    def setup_sandbox_tab(self):\n        \"\"\"Setup the plugin sandbox tab\"\"\"\n        # Create sandbox controls\n        controls_frame = ttk.Frame(self.sandbox_frame)\n        controls_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        ttk.Label(\n            controls_frame,\n            text=\"Plugin Sandbox Environment\",\n            font=(\"Helvetica\", 10, \"bold\")\n        ).pack(anchor=tk.W)\n        \n        ttk.Label(\n            controls_frame,\n            text=\"Test plugins in an isolated environment before activating them in the main application.\",\n            wraplength=600\n        ).pack(anchor=tk.W, pady=(0, 10))\n        \n        # Plugin selector\n        selector_frame = ttk.Frame(controls_frame)\n        selector_frame.pack(fill=tk.X, pady=5)\n        \n        ttk.Label(selector_frame, text=\"Select Plugin:\").pack(side=tk.LEFT)\n        \n        self.sandbox_plugin_var = tk.StringVar()\n        self.sandbox_plugin_combobox = ttk.Combobox(\n            selector_frame,\n            textvariable=self.sandbox_plugin_var,\n            state=\"readonly\",\n            width=30\n        )\n        self.sandbox_plugin_combobox.pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            selector_frame,\n            text=\"Load in Sandbox\",\n            command=self.load_plugin_in_sandbox\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Sandbox options\n        options_frame = ttk.LabelFrame(controls_frame, text=\"Sandbox Options\")\n        options_frame.pack(fill=tk.X, pady=10)\n        \n        # Create a grid layout\n        for i in range(3):\n            options_frame.columnconfigure(i, weight=1)\n        \n        # File system access\n        self.fs_access_var = tk.StringVar(value=\"read-only\")\n        ttk.Label(options_frame, text=\"File System Access:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        ttk.Radiobutton(\n            options_frame,\n            text=\"None\",\n            variable=self.fs_access_var,\n            value=\"none\"\n        ).grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)\n        ttk.Radiobutton(\n            options_frame,\n            text=\"Read-only\",\n            variable=self.fs_access_var,\n            value=\"read-only\"\n        ).grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)\n        \n        # Network access\n        self.network_access_var = tk.BooleanVar(value=False)\n        ttk.Label(options_frame, text=\"Network Access:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)\n        ttk.Checkbutton(\n            options_frame,\n            text=\"Allow\",\n            variable=self.network_access_var\n        ).grid(row=1, column=1, columnspan=2, sticky=tk.W, padx=5, pady=5)\n        \n        # Memory limit\n        ttk.Label(options_frame, text=\"Memory Limit:\").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)\n        self.memory_limit_var = tk.StringVar(value=\"256 MB\")\n        memory_combobox = ttk.Combobox(\n            options_frame,\n            textvariable=self.memory_limit_var,\n            values=[\"128 MB\", \"256 MB\", \"512 MB\", \"1 GB\"],\n            state=\"readonly\",\n            width=10\n        )\n        memory_combobox.grid(row=2, column=1, columnspan=2, sticky=tk.W, padx=5, pady=5)\n        \n        # Sandbox output\n        output_frame = ttk.LabelFrame(self.sandbox_frame, text=\"Sandbox Output\")\n        output_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create output text with syntax highlighting\n        self.sandbox_output = scrolledtext.ScrolledText(\n            output_frame,\n            wrap=tk.WORD,\n            font=(\"Courier\", 9)\n        )\n        self.sandbox_output.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Add tag configurations for syntax highlighting\n        self.sandbox_output.tag_config(\"success\", foreground=\"green\")\n        self.sandbox_output.tag_config(\"error\", foreground=\"red\")\n        self.sandbox_output.tag_config(\"warning\", foreground=\"orange\")\n        self.sandbox_output.tag_config(\"info\", foreground=\"blue\")\n        \n        # Control buttons\n        control_buttons = ttk.Frame(self.sandbox_frame)\n        control_buttons.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Button(\n            control_buttons,\n            text=\"Run Tests\",\n            command=self.run_sandbox_tests\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            control_buttons,\n            text=\"View Permissions\",\n            command=self.view_plugin_permissions\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            control_buttons,\n            text=\"Clear Output\",\n            command=lambda: self.sandbox_output.delete(1.0, tk.END)\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            control_buttons,\n            text=\"Approve and Install\",\n            command=self.approve_sandbox_plugin,\n            style=\"Accent.TButton\"\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        # Update sandbox plugin list\n        self.update_sandbox_plugin_list()\n\n    def update_sandbox_plugin_list(self):\n        \"\"\"Update the list of plugins available for sandboxing\"\"\"\n        # Get all plugins\n        plugin_info = self.plugin_manager.get_all_plugins()\n        \n        # Filter to unloaded or error plugins\n        sandbox_plugins = [\n            name for name, info in plugin_info.items() \n            if info.get(\"status\") in (\"Not Loaded\", \"Error\")\n        ]\n        \n        # Update combobox\n        self.sandbox_plugin_combobox[\"values\"] = sorted(sandbox_plugins) if sandbox_plugins else [\"No plugins available\"]\n        if sandbox_plugins:\n            self.sandbox_plugin_combobox.current(0)\n\n    def load_plugin_in_sandbox(self):\n        \"\"\"Load selected plugin in the sandbox environment\"\"\"\n        plugin_name = self.sandbox_plugin_var.get()\n        \n        if not plugin_name or plugin_name == \"No plugins available\":\n            return\n            \n        # Clear output\n        self.sandbox_output.delete(1.0, tk.END)\n        \n        # Show loading message\n        self.sandbox_output.insert(tk.END, f\"Loading plugin in sandbox: {plugin_name}\\n\", \"info\")\n        self.sandbox_output.insert(tk.END, f\"Sandbox configuration:\\n\")\n        self.sandbox_output.insert(tk.END, f\"- File system: {self.fs_access_var.get()}\\n\")\n        self.sandbox_output.insert(tk.END, f\"- Network access: {'Allowed' if self.network_access_var.get() else 'Blocked'}\\n\")\n        self.sandbox_output.insert(tk.END, f\"- Memory limit: {self.memory_limit_var.get()}\\n\\n\")\n        \n        # Simulate sandbox loading\n        self.sandbox_output.insert(tk.END, \"Preparing sandbox environment...\\n\")\n        self.frame.update_idletasks()\n        \n        # Start a background thread for sandbox operations\n        threading.Thread(\n            target=self._sandbox_load_thread,\n            args=(plugin_name,),\n            daemon=True\n        ).start()\n        \n    def _sandbox_load_thread(self, plugin_name):\n        \"\"\"\n        Load a plugin in the sandbox environment\n        \n        Args:\n            plugin_name: Name of the plugin to load\n        \"\"\"\n        try:\n            # Get plugin path\n            plugin_path = os.path.join(self.plugin_manager.plugin_dir, plugin_name)\n            \n            # Check plugin structure and files\n            self._append_sandbox_output(f\"Checking plugin structure...\\n\")\n            \n            # Check for __init__.py\n            init_path = os.path.join(plugin_path, \"__init__.py\")\n            if os.path.exists(init_path):\n                self._append_sandbox_output(f\"Found __init__.py file.\\n\", \"success\")\n            else:\n                self._append_sandbox_output(f\"ERROR: Missing __init__.py file!\\n\", \"error\")\n                return\n                \n            # Check for manifest.json\n            manifest_path = os.path.join(plugin_path, \"manifest.json\")\n            if os.path.exists(manifest_path):\n                self._append_sandbox_output(f\"Found manifest.json file.\\n\", \"success\")\n                \n                # Parse manifest\n                try:\n                    with open(manifest_path, 'r') as f:\n                        manifest = json.load(f)\n                        \n                    # Check required fields\n                    required_fields = [\"name\", \"version\", \"description\", \"author\"]\n                    missing_fields = [field for field in required_fields if field not in manifest]\n                    \n                    if missing_fields:\n                        self._append_sandbox_output(f\"WARNING: Manifest missing fields: {', '.join(missing_fields)}\\n\", \"warning\")\n                    else:\n                        self._append_sandbox_output(f\"Manifest validation successful.\\n\", \"success\")\n                        \n                    # Check dependencies\n                    if \"dependencies\" in manifest and manifest[\"dependencies\"]:\n                        deps = manifest[\"dependencies\"]\n                        self._append_sandbox_output(f\"Plugin has dependencies: {', '.join(deps)}\\n\", \"info\")\n                        \n                        # Check if dependencies are installed\n                        for dep in deps:\n                            if self.plugin_manager.is_plugin_loaded(dep):\n                                self._append_sandbox_output(f\"Dependency satisfied: {dep}\\n\", \"success\")\n                            else:\n                                self._append_sandbox_output(f\"Missing dependency: {dep}\\n\", \"warning\")\n                                \n                except Exception as e:\n                    self._append_sandbox_output(f\"ERROR: Failed to parse manifest: {e}\\n\", \"error\")\n            else:\n                self._append_sandbox_output(f\"WARNING: No manifest.json file found.\\n\", \"warning\")\n                \n            # Check for any potentially unsafe imports\n            self._append_sandbox_output(f\"Scanning for potentially unsafe imports...\\n\")\n            \n            unsafe_imports = self._scan_unsafe_imports(plugin_path)\n            \n            if unsafe_imports:\n                self._append_sandbox_output(f\"WARNING: Found potentially unsafe imports:\\n\", \"warning\")\n                for imp in unsafe_imports:\n                    self._append_sandbox_output(f\"- {imp}\\n\", \"warning\")\n            else:\n                self._append_sandbox_output(f\"No unsafe imports detected.\\n\", \"success\")\n                \n            # Static analysis complete\n            self._append_sandbox_output(f\"\\nStatic analysis complete. The plugin appears to be structurally valid.\\n\", \"info\")\n            self._append_sandbox_output(f\"Use 'Run Tests' to perform dynamic testing in the sandbox.\\n\", \"info\")\n            \n        except Exception as e:\n            self._append_sandbox_output(f\"ERROR: Sandbox analysis failed: {e}\\n\", \"error\")\n            \n    def _scan_unsafe_imports(self, plugin_path):\n        \"\"\"\n        Scan plugin files for potentially unsafe imports\n        \n        Args:\n            plugin_path: Path to the plugin directory\n            \n        Returns:\n            List of potentially unsafe imports\n        \"\"\"\n        unsafe_imports = []\n        unsafe_modules = [\n            \"os.system\", \"subprocess\", \"socket\", \"multiprocessing\",\n            \"ctypes\", \"winreg\", \"msvcrt\", \"_winapi\"\n        ]\n        \n        # Walk through all Python files\n        for root, _, files in os.walk(plugin_path):\n            for file in files:\n                if file.endswith(\".py\"):\n                    file_path = os.path.join(root, file)\n                    \n                    try:\n                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                            content = f.read()\n                            \n                        # Simple import scanning\n                        for mod in unsafe_modules:\n                            if f\"import {mod}\" in content or f\"from {mod}\" in content:\n                                unsafe_imports.append(f\"{os.path.relpath(file_path, plugin_path)}: {mod}\")\n                            \n                    except Exception:\n                        continue\n                        \n        return unsafe_imports\n\n    def _append_sandbox_output(self, text, tag=None):\n        \"\"\"\n        Append text to sandbox output with optional tag\n        \n        Args:\n            text: Text to append\n            tag: Optional tag for formatting\n        \"\"\"\n        # Use after() to safely update from another thread\n        self.frame.after(0, lambda: self._do_append_sandbox_output(text, tag))\n        \n        # Small sleep to allow UI updates\n        time.sleep(0.01)\n        \n    def _do_append_sandbox_output(self, text, tag=None):\n        \"\"\"\n        Actual implementation of append that runs on the main thread\n        \n        Args:\n            text: Text to append\n            tag: Optional tag for formatting\n        \"\"\"\n        # Insert at end\n        self.sandbox_output.insert(tk.END, text, tag)\n        \n        # Auto-scroll\n        self.sandbox_output.see(tk.END)\n\n    def search_marketplace(self):\n        \"\"\"Search the plugin marketplace based on current search criteria\"\"\"\n        # Get search query\n        query = self.search_var.get().strip()\n        repository = self.repo_var.get()\n        \n        # Clear current results\n        for item in self.marketplace_tree.get_children():\n            self.marketplace_tree.delete(item)\n            \n        # Update status\n        self.status_var.set(f\"Searching for '{query}' in {repository} repository...\")\n        self.progress_bar.start()\n        \n        # Start search in a separate thread\n        threading.Thread(\n            target=self._search_marketplace_thread,\n            args=(query, repository),\n            daemon=True\n        ).start()\n        \n    def _search_marketplace_thread(self, query, repository):\n        \"\"\"\n        Search the marketplace in a background thread\n        \n        Args:\n            query: Search query\n            repository: Repository to search (Official, Community, All)\n        \"\"\"\n        try:\n            # TODO: In a real implementation, this would connect to an external API\n            # For now, we'll simulate some results\n            time.sleep(1)  # Simulate network delay\n            \n            # Simulate search results\n            results = []\n            \n            # Add some dummy results based on query\n            if not query or \"plugin\" in query.lower():\n                results.extend([\n                    {\n                        \"name\": \"Advanced Search Plugin\",\n                        \"version\": \"1.2.1\",\n                        \"rating\": \"4.8\",\n                        \"downloads\": \"12,453\",\n                        \"author\": \"Irintai Team\",\n                        \"category\": \"Utilities\",\n                        \"description\": \"Enhanced search capabilities for vector databases and document retrieval.\",\n                        \"updated\": \"2025-03-15\",\n                        \"size\": \"1.2 MB\",\n                        \"dependencies\": []\n                    },\n                    {\n                        \"name\": \"Document Scanner Plugin\",\n                        \"version\": \"0.9.5\",\n                        \"rating\": \"4.2\",\n                        \"downloads\": \"8,712\",\n                        \"author\": \"DocScan Inc.\",\n                        \"category\": \"Document Processing\",\n                        \"description\": \"Automatically processes and indexes documents from various sources.\",\n                        \"updated\": \"2025-01-22\",\n                        \"size\": \"3.5 MB\",\n                        \"dependencies\": [\"Advanced Search Plugin\"]\n                    }\n                ])\n                \n            if not query or \"code\" in query.lower():\n                results.extend([\n                    {\n                        \"name\": \"Code Assistant Pro\",\n                        \"version\": \"2.1.0\",\n                        \"rating\": \"4.9\",\n                        \"downloads\": \"32,150\",\n                        \"author\": \"DevTools Corp\",\n                        \"category\": \"Development\",\n                        \"description\": \"Adds code completion, refactoring suggestions, and more to enhance coding capabilities.\",\n                        \"updated\": \"2025-04-01\",\n                        \"size\": \"4.8 MB\",\n                        \"dependencies\": []\n                    }\n                ])\n                \n            if not query or \"ui\" in query.lower() or \"theme\" in query.lower():\n                results.extend([\n                    {\n                        \"name\": \"UI Theme Pack\",\n                        \"version\": \"1.5.2\",\n                        \"rating\": \"4.7\",\n                        \"downloads\": \"18,325\",\n                        \"author\": \"Design Studio X\",\n                        \"category\": \"UI/UX\",\n                        \"description\": \"Collection of modern UI themes with customizable color schemes and layouts.\",\n                        \"updated\": \"2025-02-18\",\n                        \"size\": \"2.3 MB\",\n                        \"dependencies\": []\n                    }\n                ])\n            \n            # Filter by repository if needed\n            if repository == \"Official\":\n                results = [r for r in results if \"Irintai Team\" in r.get(\"author\", \"\")]\n            elif repository == \"Community\":\n                results = [r for r in results if \"Irintai Team\" not in r.get(\"author\", \"\")]\n            \n            # Update UI on main thread\n            self.frame.after(0, lambda: self._update_marketplace_results(results, query))\n            \n        except Exception as e:\n            # Update UI with error\n            self.frame.after(0, lambda: self._update_marketplace_error(str(e)))\n            \n    def _update_marketplace_results(self, results, query):\n        \"\"\"\n        Update the marketplace tree with search results\n        \n        Args:\n            results: List of plugin results\n            query: Search query used\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        # Clear current results\n        for item in self.marketplace_tree.get_children():\n            self.marketplace_tree.delete(item)\n            \n        # Add results to tree\n        if results:\n            for plugin in results:\n                self.marketplace_tree.insert(\n                    \"\",\n                    tk.END,\n                    values=(\n                        plugin[\"name\"],\n                        plugin[\"version\"],\n                        plugin[\"rating\"],\n                        plugin[\"downloads\"]\n                    ),\n                    tags=(plugin[\"name\"],)  # Use name as tag for lookup\n                )\n                \n            # Select first result\n            first = self.marketplace_tree.get_children()[0]\n            self.marketplace_tree.selection_set(first)\n            self.on_marketplace_selected(None)\n            \n            self.status_var.set(f\"Found {len(results)} plugins matching '{query}'\")\n        else:\n            self.status_var.set(f\"No plugins found matching '{query}'\")\n            \n            # Clear details\n            self.market_description.delete(1.0, tk.END)\n            self.market_author_var.set(\"-\")\n            self.market_category_var.set(\"-\")\n            self.market_updated_var.set(\"-\")\n            self.market_size_var.set(\"-\")\n            self.dependencies_var.set(\"None\")\n        \n    def _update_marketplace_error(self, error_message):\n        \"\"\"\n        Update the UI with search error\n        \n        Args:\n            error_message: Error message to display\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        # Show error\n        self.status_var.set(f\"Error searching marketplace: {error_message}\")\n        messagebox.showerror(\"Search Error\", f\"Failed to search marketplace:\\n{error_message}\")\n\n    def on_marketplace_selected(self, event):\n        \"\"\"Handle selection in the marketplace tree\"\"\"\n        selection = self.marketplace_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected item\n        item = selection[0]\n        values = self.marketplace_tree.item(item, \"values\")\n        \n        if not values:\n            return\n            \n        # Get plugin name\n        plugin_name = values[0]\n        \n        # Find plugin details (in real implementation, would fetch from API)\n        plugin = None\n        for p in self._get_demo_plugins():\n            if p[\"name\"] == plugin_name:\n                plugin = p\n                break\n                \n        if not plugin:\n            return\n            \n        # Update details\n        self.market_description.delete(1.0, tk.END)\n        self.market_description.insert(1.0, plugin.get(\"description\", \"No description available\"))\n        \n        self.market_author_var.set(plugin.get(\"author\", \"Unknown\"))\n        self.market_category_var.set(plugin.get(\"category\", \"General\"))\n        self.market_updated_var.set(plugin.get(\"updated\", \"Unknown\"))\n        self.market_size_var.set(plugin.get(\"size\", \"Unknown\"))\n        \n        # Update dependencies\n        dependencies = plugin.get(\"dependencies\", [])\n        if dependencies:\n            self.dependencies_var.set(\", \".join(dependencies))\n        else:\n            self.dependencies_var.set(\"None\")\n\n    def _get_demo_plugins(self):\n        \"\"\"Get demo plugins for marketplace display\"\"\"\n        return [\n            {\n                \"name\": \"Advanced Search Plugin\",\n                \"version\": \"1.2.1\",\n                \"rating\": \"4.8\",\n                \"downloads\": \"12,453\",\n                \"author\": \"Irintai Team\",\n                \"category\": \"Utilities\",\n                \"description\": \"Enhanced search capabilities for vector databases and document retrieval.\",\n                \"updated\": \"2025-03-15\",\n                \"size\": \"1.2 MB\",\n                \"dependencies\": []\n            },\n            {\n                \"name\": \"Document Scanner Plugin\",\n                \"version\": \"0.9.5\",\n                \"rating\": \"4.2\",\n                \"downloads\": \"8,712\",\n                \"author\": \"DocScan Inc.\",\n                \"category\": \"Document Processing\",\n                \"description\": \"Automatically processes and indexes documents from various sources.\",\n                \"updated\": \"2025-01-22\",\n                \"size\": \"3.5 MB\",\n                \"dependencies\": [\"Advanced Search Plugin\"]\n            },\n            {\n                \"name\": \"Code Assistant Pro\",\n                \"version\": \"2.1.0\",\n                \"rating\": \"4.9\",\n                \"downloads\": \"32,150\",\n                \"author\": \"DevTools Corp\",\n                \"category\": \"Development\",\n                \"description\": \"Adds code completion, refactoring suggestions, and more to enhance coding capabilities.\",\n                \"updated\": \"2025-04-01\",\n                \"size\": \"4.8 MB\",\n                \"dependencies\": []\n            },\n            {\n                \"name\": \"UI Theme Pack\",\n                \"version\": \"1.5.2\",\n                \"rating\": \"4.7\",\n                \"downloads\": \"18,325\",\n                \"author\": \"Design Studio X\",\n                \"category\": \"UI/UX\",\n                \"description\": \"Collection of modern UI themes with customizable color schemes and layouts.\",\n                \"updated\": \"2025-02-18\",\n                \"size\": \"2.3 MB\",\n                \"dependencies\": []\n            }\n        ]\n\n    def install_marketplace_plugin(self):\n        \"\"\"Install the selected plugin from marketplace\"\"\"\n        selection = self.marketplace_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected item\n        item = selection[0]\n        values = self.marketplace_tree.item(item, \"values\")\n        \n        if not values:\n            return\n            \n        # Get plugin name\n        plugin_name = values[0]\n        \n        # Confirm installation\n        result = messagebox.askyesno(\n            \"Install Plugin\",\n            f\"Do you want to install '{plugin_name}'?\"\n        )\n        \n        if not result:\n            return\n            \n        # Show progress\n        self.progress_bar.start()\n        self.status_var.set(f\"Installing {plugin_name}...\")\n        \n        # Start installation in a separate thread\n        threading.Thread(\n            target=self._install_marketplace_plugin_thread,\n            args=(plugin_name,),\n            daemon=True\n        ).start()\n        \n    def _install_marketplace_plugin_thread(self, plugin_name):\n        \"\"\"\n        Install a plugin from marketplace in a background thread\n        \n        Args:\n            plugin_name: Name of the plugin to install\n        \"\"\"\n        try:\n            # Simulate installation process\n            time.sleep(2)\n            \n            # Update UI on main thread\n            self.frame.after(0, lambda: self._on_marketplace_install_complete(plugin_name, True))\n            \n        except Exception as e:\n            # Update UI with error\n            self.frame.after(0, lambda: self._on_marketplace_install_complete(plugin_name, False, str(e)))\n        \n    def _on_marketplace_install_complete(self, plugin_name, success, error_message=None):\n        \"\"\"\n        Handle completion of plugin installation\n        \n        Args:\n            plugin_name: Name of the plugin\n            success: Whether installation was successful\n            error_message: Optional error message\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        if success:\n            self.status_var.set(f\"Successfully installed {plugin_name}\")\n            messagebox.showinfo(\"Installation Complete\", f\"Plugin {plugin_name} installed successfully.\")\n            \n            # Refresh local plugin list\n            self.refresh_plugin_list()\n        else:\n            self.status_var.set(f\"Failed to install {plugin_name}: {error_message}\")\n            messagebox.showerror(\"Installation Failed\", f\"Failed to install {plugin_name}:\\n{error_message}\")\n\n    def visit_plugin_website(self):\n        \"\"\"Open the plugin website in the default browser\"\"\"\n        selection = self.marketplace_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected item\n        item = selection[0]\n        values = self.marketplace_tree.item(item, \"values\")\n        \n        if not values:\n            return\n            \n        # Get plugin name\n        plugin_name = values[0]\n        \n        # Find plugin details\n        plugin = None\n        for p in self._get_demo_plugins():\n            if p[\"name\"] == plugin_name:\n                plugin = p\n                break\n                \n        if not plugin:\n            return\n            \n        # Simulate website (would be in plugin[\"url\"] in a real implementation)\n        url = f\"https://example.com/plugins/{plugin_name.lower().replace(' ', '-')}\"\n        \n        # Try to open URL in browser\n        import webbrowser\n        try:\n            webbrowser.open(url)\n            self.status_var.set(f\"Opened website for {plugin_name}\")\n        except Exception as e:\n            self.status_var.set(f\"Failed to open website: {e}\")\n            messagebox.showerror(\"Error\", f\"Failed to open website:\\n{e}\")\n\n    def view_plugin_dependencies(self):\n        \"\"\"Show plugin dependencies in a dialog\"\"\"\n        selection = self.marketplace_tree.selection()\n        if not selection:\n            return\n            \n        # Get selected item\n        item = selection[0]\n        values = self.marketplace_tree.item(item, \"values\")\n        \n        if not values:\n            return\n            \n        # Get plugin name\n        plugin_name = values[0]\n        \n        # Find plugin details\n        plugin = None\n        for p in self._get_demo_plugins():\n            if p[\"name\"] == plugin_name:\n                plugin = p\n                break\n                \n        if not plugin:\n            return\n            \n        # Get dependencies\n        dependencies = plugin.get(\"dependencies\", [])\n        \n        if not dependencies:\n            messagebox.showinfo(\"Dependencies\", f\"{plugin_name} has no dependencies.\")\n            return\n            \n        # Show dependencies dialog\n        dialog = tk.Toplevel(self.frame)\n        dialog.title(f\"Dependencies for {plugin_name}\")\n        dialog.geometry(\"400x300\")\n        dialog.transient(self.frame)\n        dialog.grab_set()\n        \n        # Add content\n        ttk.Label(\n            dialog,\n            text=f\"Dependencies for {plugin_name}\",\n            font=(\"\", 12, \"bold\")\n        ).pack(pady=(10, 5))\n        \n        # Create a listbox for dependencies\n        listbox = tk.Listbox(dialog)\n        listbox.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n        \n        # Add dependencies to listbox\n        for dep in dependencies:\n            listbox.insert(tk.END, dep)\n            \n        # Close button\n        ttk.Button(\n            dialog,\n            text=\"Close\",\n            command=dialog.destroy\n        ).pack(pady=10)\n\n    def check_plugin_updates(self):\n        \"\"\"Check for plugin updates\"\"\"\n        # Show progress\n        self.progress_bar.start()\n        self.status_var.set(\"Checking for plugin updates...\")\n        \n        # Start check in a separate thread\n        threading.Thread(\n            target=self._check_updates_thread,\n            daemon=True\n        ).start()\n        \n    def _check_updates_thread(self):\n        \"\"\"Check for updates in a background thread\"\"\"\n        try:\n            # Simulate network operation\n            time.sleep(1.5)\n            \n            # No updates in this demo\n            self.frame.after(0, lambda: self._on_update_check_complete([]))\n            \n        except Exception as e:\n            self.frame.after(0, lambda: self._on_update_check_error(str(e)))\n        \n    def _on_update_check_complete(self, updates):\n        \"\"\"\n        Handle completion of update check\n        \n        Args:\n            updates: List of available updates\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        if updates:\n            self.status_var.set(f\"Found {len(updates)} plugin updates\")\n            \n            # Show updates in a dialog\n            # (Not implemented in this example)\n            messagebox.showinfo(\"Plugin Updates\", f\"Found {len(updates)} plugin updates.\")\n        else:\n            self.status_var.set(\"All plugins are up to date\")\n            messagebox.showinfo(\"Plugin Updates\", \"All plugins are up to date.\")\n        \n    def _on_update_check_error(self, error_message):\n        \"\"\"\n        Handle error during update check\n        \n        Args:\n            error_message: Error message\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        # Show error\n        self.status_var.set(f\"Error checking for updates: {error_message}\")\n        messagebox.showerror(\"Update Error\", f\"Failed to check for updates:\\n{error_message}\")\n\n    def run_sandbox_tests(self):\n        \"\"\"Run tests for the plugin in the sandbox\"\"\"\n        plugin_name = self.sandbox_plugin_var.get()\n        \n        if not plugin_name or plugin_name == \"No plugins available\":\n            return\n            \n        # Clear output and show header\n        self.sandbox_output.delete(1.0, tk.END)\n        self.sandbox_output.insert(tk.END, f\"==== Running tests for {plugin_name} ====\\n\\n\", \"info\")\n        \n        # Show test configuration\n        self.sandbox_output.insert(tk.END, f\"Test configuration:\\n\")\n        self.sandbox_output.insert(tk.END, f\"- File system access: {self.fs_access_var.get()}\\n\")\n        self.sandbox_output.insert(tk.END, f\"- Network access: {'Allowed' if self.network_access_var.get() else 'Blocked'}\\n\")\n        self.sandbox_output.insert(tk.END, f\"- Memory limit: {self.memory_limit_var.get()}\\n\\n\")\n        \n        # Start testing in a separate thread\n        threading.Thread(\n            target=self._run_sandbox_tests_thread,\n            args=(plugin_name,),\n            daemon=True\n        ).start()\n        \n    def _run_sandbox_tests_thread(self, plugin_name):\n        \"\"\"\n        Run sandbox tests in a background thread\n        \n        Args:\n            plugin_name: Name of the plugin to test\n        \"\"\"\n        try:\n            # Get plugin path\n            plugin_path = os.path.join(self.plugin_manager.plugin_dir, plugin_name)\n            \n            # Simulate tests\n            self._append_sandbox_output(\"Initializing sandbox environment...\\n\")\n            time.sleep(0.5)\n            \n            self._append_sandbox_output(\"Loading plugin in isolated environment...\\n\")\n            time.sleep(1.0)\n            \n            self._append_sandbox_output(\"Running standard tests...\\n\\n\")\n            \n            # Test plugin initialization\n            self._append_sandbox_output(\"1. Testing plugin initialization... \")\n            time.sleep(0.5)\n            self._append_sandbox_output(\"OK\\n\", \"success\")\n            \n            # Test activate method\n            self._append_sandbox_output(\"2. Testing activate() method... \")\n            time.sleep(0.5)\n            self._append_sandbox_output(\"OK\\n\", \"success\")\n            \n            # Test deactivate method\n            self._append_sandbox_output(\"3. Testing deactivate() method... \")\n            time.sleep(0.5)\n            self._append_sandbox_output(\"OK\\n\", \"success\")\n            \n            # Test file operations\n            self._append_sandbox_output(\"4. Testing file operations... \")\n            if self.fs_access_var.get() == \"none\":\n                self._append_sandbox_output(\"SKIPPED (no file access)\\n\", \"warning\")\n            else:\n                time.sleep(0.7)\n                self._append_sandbox_output(\"OK\\n\", \"success\")\n                \n            # Test network access\n            self._append_sandbox_output(\"5. Testing network operations... \")\n            if not self.network_access_var.get():\n                self._append_sandbox_output(\"SKIPPED (no network access)\\n\", \"warning\")\n            else:\n                time.sleep(0.8)\n                self._append_sandbox_output(\"OK\\n\", \"success\")\n                \n            # Test memory allocation\n            self._append_sandbox_output(\"6. Testing memory allocation... \")\n            time.sleep(0.6)\n            \n            # Parse memory limit\n            limit_str = self.memory_limit_var.get()\n            if \"MB\" in limit_str:\n                limit = int(limit_str.split(\" \")[0])\n            elif \"GB\" in limit_str:\n                limit = int(limit_str.split(\" \")[0]) * 1024\n            else:\n                limit = 256  # Default\n                \n            if limit < 256:\n                self._append_sandbox_output(\"WARNING: Low memory limit may affect plugin performance\\n\", \"warning\")\n            else:\n                self._append_sandbox_output(\"OK\\n\", \"success\")\n                \n            # Summary\n            self._append_sandbox_output(\"\\nAll tests completed successfully.\\n\", \"success\")\n            self._append_sandbox_output(\"The plugin appears to be safe and working correctly.\\n\", \"success\")\n            \n        except Exception as e:\n            self._append_sandbox_output(f\"ERROR: Test failed: {e}\\n\", \"error\")\n\n    def view_plugin_permissions(self):\n        \"\"\"View the permissions requested by the plugin\"\"\"\n        plugin_name = self.sandbox_plugin_var.get()\n        \n        if not plugin_name or plugin_name == \"No plugins available\":\n            return\n            \n        # Show permissions dialog\n        dialog = tk.Toplevel(self.frame)\n        dialog.title(f\"Permissions - {plugin_name}\")\n        dialog.geometry(\"500x400\")\n        dialog.transient(self.frame)\n        dialog.grab_set()\n        \n        # Add content\n        ttk.Label(\n            dialog,\n            text=f\"Permissions for {plugin_name}\",\n            font=(\"\", 12, \"bold\")\n        ).pack(pady=(10, 5))\n        \n        # Create a frame for permissions\n        perm_frame = ttk.Frame(dialog, padding=10)\n        perm_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Permission columns\n        ttk.Label(perm_frame, text=\"Permission\", font=(\"\", 10, \"bold\")).grid(row=0, column=0, sticky=tk.W, pady=(0, 5))\n        ttk.Label(perm_frame, text=\"Status\", font=(\"\", 10, \"bold\")).grid(row=0, column=1, sticky=tk.W, pady=(0, 5))\n        ttk.Label(perm_frame, text=\"Description\", font=(\"\", 10, \"bold\")).grid(row=0, column=2, sticky=tk.W, pady=(0, 5))\n        \n        # File system access\n        ttk.Label(perm_frame, text=\"File System\").grid(row=1, column=0, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=self.fs_access_var.get().capitalize(),\n            foreground=\"green\" if self.fs_access_var.get() != \"none\" else \"red\"\n        ).grid(row=1, column=1, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"Access to plugin-specific data directory\"\n        ).grid(row=1, column=2, sticky=tk.W, pady=2)\n        \n        # Network access\n        ttk.Label(perm_frame, text=\"Network\").grid(row=2, column=0, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"Enabled\" if self.network_access_var.get() else \"Disabled\",\n            foreground=\"green\" if self.network_access_var.get() else \"red\"\n        ).grid(row=2, column=1, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"Internet access for API calls and data retrieval\"\n        ).grid(row=2, column=2, sticky=tk.W, pady=2)\n        \n        # UI access\n        ttk.Label(perm_frame, text=\"UI Access\").grid(row=3, column=0, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"Limited\",\n            foreground=\"orange\"\n        ).grid(row=3, column=1, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"Can create dialog windows and panel elements\"\n        ).grid(row=3, column=2, sticky=tk.W, pady=2)\n        \n        # System access\n        ttk.Label(perm_frame, text=\"System\").grid(row=4, column=0, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"None\",\n            foreground=\"red\"\n        ).grid(row=4, column=1, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"No access to system functions or processes\"\n        ).grid(row=4, column=2, sticky=tk.W, pady=2)\n        \n        # Plugin API\n        ttk.Label(perm_frame, text=\"Plugin API\").grid(row=5, column=0, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"Full\",\n            foreground=\"green\"\n        ).grid(row=5, column=1, sticky=tk.W, pady=2)\n        ttk.Label(\n            perm_frame,\n            text=\"Access to plugin API for events and services\"\n        ).grid(row=5, column=2, sticky=tk.W, pady=2)\n        \n        # Close button\n        ttk.Button(\n            dialog,\n            text=\"Close\",\n            command=dialog.destroy\n        ).pack(pady=10)\n\n    def approve_sandbox_plugin(self):\n        \"\"\"Approve a plugin from sandbox and install it\"\"\"\n        plugin_name = self.sandbox_plugin_var.get()\n        \n        if not plugin_name or plugin_name == \"No plugins available\":\n            return\n            \n        # Confirm installation\n        result = messagebox.askyesno(\n            \"Approve Plugin\",\n            f\"Do you want to approve and activate {plugin_name}?\\n\\n\"\n            f\"This will load the plugin with the following permissions:\\n\"\n            f\"- File System: {self.fs_access_var.get()}\\n\"\n            f\"- Network: {'Allowed' if self.network_access_var.get() else 'Blocked'}\"\n        )\n        \n        if not result:\n            return\n            \n        # Update status\n        self.status_var.set(f\"Installing and activating {plugin_name}...\")\n        self.progress_bar.start()\n        \n        # Install in a separate thread\n        threading.Thread(\n            target=self._approve_plugin_thread,\n            args=(plugin_name,),\n            daemon=True\n        ).start()\n        \n    def _approve_plugin_thread(self, plugin_name):\n        \"\"\"\n        Approve and install plugin in a background thread\n        \n        Args:\n            plugin_name: Name of the plugin to approve\n        \"\"\"\n        try:\n            # Try to load the plugin\n            success = self.plugin_manager.load_plugin(plugin_name)\n            \n            if success:\n                # Activate the plugin\n                activate_success = self.plugin_manager.activate_plugin(plugin_name)\n                \n                # Update UI on main thread\n                self.frame.after(0, lambda: self._on_plugin_approved(plugin_name, activate_success))\n            else:\n                # Update UI with error\n                self.frame.after(0, lambda: self._on_plugin_approval_failed(plugin_name))\n                \n        except Exception as e:\n            # Update UI with error\n            self.frame.after(0, lambda: self._on_plugin_approval_error(plugin_name, str(e)))\n        \n    def _on_plugin_approved(self, plugin_name, activate_success):\n        \"\"\"\n        Handle successful plugin approval\n        \n        Args:\n            plugin_name: Name of the plugin\n            activate_success: Whether activation was successful\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        if activate_success:\n            self.status_var.set(f\"Plugin {plugin_name} approved and activated\")\n            messagebox.showinfo(\n                \"Plugin Approved\",\n                f\"Plugin {plugin_name} has been approved and activated successfully.\"\n            )\n        else:\n            self.status_var.set(f\"Plugin {plugin_name} loaded but not activated\")\n            messagebox.showwarning(\n                \"Plugin Partially Approved\",\n                f\"Plugin {plugin_name} was loaded but could not be activated.\"\n            )\n            \n        # Refresh plugin list\n        self.refresh_plugin_list()\n        \n        # Update sandbox plugin list\n        self.update_sandbox_plugin_list()\n        \n    def _on_plugin_approval_failed(self, plugin_name):\n        \"\"\"\n        Handle failed plugin approval\n        \n        Args:\n            plugin_name: Name of the plugin\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        self.status_var.set(f\"Failed to approve plugin {plugin_name}\")\n        messagebox.showerror(\n            \"Approval Failed\",\n            f\"Failed to load and approve plugin {plugin_name}.\"\n        )\n        \n    def _on_plugin_approval_error(self, plugin_name, error_message):\n        \"\"\"\n        Handle error during plugin approval\n        \n        Args:\n            plugin_name: Name of the plugin\n            error_message: Error message\n        \"\"\"\n        # Stop progress\n        self.progress_bar.stop()\n        \n        self.status_var.set(f\"Error approving plugin {plugin_name}: {error_message}\")\n        messagebox.showerror(\n            \"Approval Error\",\n            f\"Error approving plugin {plugin_name}:\\n{error_message}\"\n        )\n\n    def _on_destroy(self, event):\n        \"\"\"Called when the frame is destroyed\"\"\"\n        if event.widget == self.frame:\n            self.is_running = False\n\n    def setup_settings_tab(self):\n        \"\"\"Setup the settings tab for plugin configuration\"\"\"\n        # Create split layout with plugin list on left and config on right\n        self.settings_paned = ttk.PanedWindow(self.settings_frame, orient=tk.HORIZONTAL)\n        self.settings_paned.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create left frame for plugin list\n        left_frame = ttk.Frame(self.settings_paned, width=200)\n        self.settings_paned.add(left_frame, weight=1)\n        \n        # Create plugin list with header\n        ttk.Label(left_frame, text=\"Available Plugins\", font=(\"\", 10, \"bold\")).pack(anchor=tk.W, padx=5, pady=5)\n        \n        # Plugin list frame with scrollbar\n        list_frame = ttk.Frame(left_frame)\n        list_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Use a styled listbox\n        self.settings_plugin_listbox = tk.Listbox(\n            list_frame, \n            selectmode=tk.SINGLE,\n            activestyle='dotbox',\n            font=(\"\", 9),\n            borderwidth=1,\n            relief=tk.SOLID,\n            highlightthickness=0\n        )\n        self.settings_plugin_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.settings_plugin_listbox.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.settings_plugin_listbox.configure(yscrollcommand=scrollbar.set)\n\n        # Bind selection event\n        self.settings_plugin_listbox.bind('<<ListboxSelect>>', self.on_settings_plugin_selected)\n        \n        # Create right frame for config\n        self.settings_right_frame = ttk.Frame(self.settings_paned, width=500)\n        self.settings_paned.add(self.settings_right_frame, weight=3)\n        \n        # Create config area with scrolling\n        self.settings_canvas = tk.Canvas(self.settings_right_frame, highlightthickness=0)\n        self.settings_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        self.settings_scrollbar = ttk.Scrollbar(self.settings_right_frame, orient=tk.VERTICAL, command=self.settings_canvas.yview)\n        self.settings_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        self.settings_canvas.configure(yscrollcommand=self.settings_scrollbar.set)\n        self.settings_canvas.bind('<Configure>', self._on_settings_canvas_configure)\n        \n        # Enable mousewheel scrolling\n        self.settings_canvas.bind_all('<MouseWheel>', lambda event: self.settings_canvas.yview_scroll(int(-1*(event.delta/120)), \"units\"))\n        \n        # Create a frame inside the canvas for config widgets\n        self.settings_config_frame = ttk.Frame(self.settings_canvas)\n        self.settings_canvas_window = self.settings_canvas.create_window((0, 0), window=self.settings_config_frame, anchor=tk.NW)\n        self.settings_config_frame.bind('<Configure>', self._on_settings_frame_configure)\n        \n        # Add header to config frame\n        self.settings_header = ttk.Label(self.settings_config_frame, text=\"Select a plugin to configure\", font=(\"\", 12, \"bold\"))\n        self.settings_header.grid(row=0, column=0, columnspan=3, sticky=tk.W, padx=15, pady=15)\n        \n        # Add description\n        self.settings_description = ttk.Label(self.settings_config_frame, text=\"\", wraplength=500, font=(\"\", 9))\n        self.settings_description.grid(row=1, column=0, columnspan=3, sticky=tk.W, padx=15, pady=(0, 10))\n        \n        # Add separator\n        ttk.Separator(self.settings_config_frame, orient=tk.HORIZONTAL).grid(row=2, column=0, columnspan=3, sticky=tk.EW, padx=10, pady=10)\n        \n        # Add config content\n        self.settings_content = ttk.Frame(self.settings_config_frame)\n        self.settings_content.grid(row=3, column=0, columnspan=3, sticky=tk.NSEW, padx=15, pady=5)\n        \n        # Add buttons\n        button_frame = ttk.Frame(self.settings_config_frame)\n        button_frame.grid(row=4, column=0, columnspan=3, sticky=tk.E, padx=15, pady=15)\n        \n        self.settings_save_button = ttk.Button(button_frame, text=\"Save\", command=self.save_plugin_config, style=\"Accent.TButton\")\n        self.settings_save_button.pack(side=tk.RIGHT, padx=5)\n        self.settings_save_button.state(['disabled'])\n        \n        self.settings_reset_button = ttk.Button(button_frame, text=\"Reset\", command=self.reset_plugin_config)\n        self.settings_reset_button.pack(side=tk.RIGHT, padx=5)\n        self.settings_reset_button.state(['disabled'])\n        \n        # Load plugins into settings tab\n        self.load_settings_plugins()    \n        \n    def load_settings_plugins(self):\n        \"\"\"Load the list of available plugins into the settings tab\"\"\"\n        # Clear the listbox\n        self.settings_plugin_listbox.delete(0, tk.END)\n        \n        # Get all plugins\n        plugins = self.plugin_manager.get_all_plugins()\n        if not plugins:\n            # If plugins dict is empty, try to discover plugins first\n            self.plugin_manager.discover_plugins()\n            # Try again to get plugins\n            plugins = self.plugin_manager.get_all_plugins()\n            \n        # Sort plugins by name\n        plugin_ids = sorted(plugins.keys()) if plugins else []\n        \n        # Add plugins to listbox with status indicator\n        for plugin_id in plugin_ids:\n            plugin_info = plugins.get(plugin_id, {})\n            status = plugin_info.get(\"status\", \"unknown\")\n            display_name = f\"\u2713 {plugin_id}\" if status == \"active\" else plugin_id\n            self.settings_plugin_listbox.insert(tk.END, display_name)\n            \n        # Log the number of plugins found\n        if self.log:\n            self.log(f\"[PluginPanel] Loaded {len(plugin_ids)} plugins into settings tab\")\n    \n    def on_settings_plugin_selected(self, event):\n        \"\"\"Handle plugin selection in the settings tab\"\"\"\n        # Get selected plugin\n        selection = self.settings_plugin_listbox.curselection()\n        if not selection:\n            return\n            \n        plugin_id = self.settings_plugin_listbox.get(selection[0])\n        self.load_plugin_config(plugin_id)\n        \n    def load_plugin_config(self, plugin_id):\n        \"\"\"Load the configuration for a plugin\"\"\"\n        # Clear the config content\n        for widget in self.settings_content.winfo_children():\n            widget.destroy()\n        \n        # Update current plugin\n        self.current_plugin_id = plugin_id\n        self.current_config = {}\n        self.config_widgets = {}\n        \n        # Enable buttons\n        self.settings_save_button.state(['!disabled'])\n        self.settings_reset_button.state(['!disabled'])\n        \n        # Update header\n        self.settings_header.config(text=f\"Configure: {plugin_id}\")\n        \n        # Get plugin info\n        plugin_info = self.plugin_manager.get_plugin_metadata(plugin_id)\n        \n        # Update description\n        if plugin_info and \"description\" in plugin_info:\n            self.settings_description.config(text=plugin_info[\"description\"])\n        else:\n            self.settings_description.config(text=\"No description available\")\n        \n        # Get plugin config schema\n        config_schema = self.plugin_manager.get_plugin_config_schema(plugin_id)\n        \n        if not config_schema:\n            # Show no config message\n            ttk.Label(\n                self.settings_content,\n                text=\"This plugin has no configurable settings.\",\n                font=(\"\", 10, \"italic\")\n            ).pack(pady=20)\n            return\n        \n        # Get current plugin config\n        current_config = self.plugin_manager.get_plugin_config(plugin_id) or {}\n        self.current_config = current_config.copy()\n        \n        # Build config UI based on schema\n        self._create_config_widgets(config_schema, current_config)\n        \n    def _create_config_widgets(self, schema, config):\n        \"\"\"Create configuration widgets based on schema\"\"\"\n        # Check if we have properties\n        if \"properties\" not in schema:\n            ttk.Label(\n                self.settings_content,\n                text=\"Invalid configuration schema\",\n                font=(\"\", 10, \"italic\")\n            ).pack(pady=20)\n            return\n            \n        # Get properties\n        properties = schema[\"properties\"]\n        \n        # Track row for grid\n        row = 0\n        \n        # Create widgets for each property\n        for prop_name, prop_details in properties.items():\n            if \"type\" not in prop_details:\n                continue\n                \n            # Get current value or default\n            current_value = config.get(prop_name, prop_details.get(\"default\", \"\"))\n            \n            # Create label\n            ttk.Label(\n                self.settings_content,\n                text=prop_details.get(\"title\", prop_name),\n                font=(\"\", 10)\n            ).grid(row=row, column=0, sticky=tk.W, padx=5, pady=5)\n            \n            # Create widget based on type\n            widget_type = prop_details[\"type\"]\n            \n            if widget_type == \"string\":\n                # Create string input\n                if \"enum\" in prop_details:\n                    # Create dropdown for enum\n                    var = tk.StringVar(value=str(current_value))\n                    dropdown = ttk.Combobox(\n                        self.settings_content,\n                        textvariable=var,\n                        values=prop_details[\"enum\"],\n                        state=\"readonly\",\n                        width=30\n                    )\n                    dropdown.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n                    self.config_widgets[prop_name] = var\n                else:\n                    # Create regular text input\n                    var = tk.StringVar(value=str(current_value))\n                    entry = ttk.Entry(self.settings_content, textvariable=var, width=30)\n                    entry.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n                    self.config_widgets[prop_name] = var\n                    \n            elif widget_type == \"integer\" or widget_type == \"number\":\n                # Create numeric input with validation\n                var = tk.StringVar(value=str(current_value))\n                validate_cmd = (self.settings_content.register(\n                    lambda s: s == \"\" or s.isdigit() or (s[0] == \"-\" and s[1:].isdigit())\n                ), '%P')\n                entry = ttk.Entry(\n                    self.settings_content, \n                    textvariable=var,\n                    validate=\"key\",\n                    validatecommand=validate_cmd,\n                    width=10\n                )\n                entry.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n                self.config_widgets[prop_name] = var\n                \n            elif widget_type == \"boolean\":\n                # Create checkbox\n                var = tk.BooleanVar(value=bool(current_value))\n                checkbox = ttk.Checkbutton(self.settings_content, variable=var)\n                checkbox.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n                self.config_widgets[prop_name] = var\n                \n            # Add description if available\n            if \"description\" in prop_details:\n                ttk.Label(\n                    self.settings_content,\n                    text=prop_details[\"description\"],\n                    font=(\"\", 8),\n                    foreground=\"gray\"\n                ).grid(row=row, column=2, sticky=tk.W, padx=5, pady=5)\n                \n            # Increment row\n            row += 1\n                \n    def save_plugin_config(self):\n        \"\"\"Save the current plugin configuration\"\"\"\n        if not self.current_plugin_id:\n            return\n            \n        # Get values from widgets\n        new_config = {}\n        for prop_name, widget_var in self.config_widgets.items():\n            new_config[prop_name] = widget_var.get()\n            \n        # Save config\n        success = self.plugin_manager.set_plugin_config(self.current_plugin_id, new_config)\n        \n        if success:\n            self.log(f\"[Plugins] Saved configuration for {self.current_plugin_id}\")\n            messagebox.showinfo(\"Configuration Saved\", f\"Configuration for {self.current_plugin_id} has been saved.\")\n            \n            # Update current config\n            self.current_config = new_config.copy()\n        else:\n            self.log(f\"[Error] Failed to save configuration for {self.current_plugin_id}\")\n            messagebox.showerror(\"Error\", f\"Failed to save configuration for {self.current_plugin_id}\")\n            \n    def reset_plugin_config(self):\n        \"\"\"Reset the plugin configuration to the last saved state\"\"\"\n        if not self.current_plugin_id:\n            return\n            \n        # Reload the plugin configuration\n        self.load_plugin_config(self.current_plugin_id)\n        \n    def _on_settings_canvas_configure(self, event):\n        \"\"\"Handle canvas resize for settings tab\"\"\"\n        self.settings_canvas.configure(scrollregion=self.settings_canvas.bbox(\"all\"))\n        self.settings_canvas.itemconfig(self.settings_canvas_window, width=event.width)\n        \n    def _on_settings_frame_configure(self, event):\n        \"\"\"Handle frame resize for settings tab\"\"\"\n        self.settings_canvas.configure(scrollregion=self.settings_canvas.bbox(\"all\"))\n        \n    def _create_config_widgets(self, schema, config):\n        \"\"\"Create configuration widgets based on schema\"\"\"\n        # Check if we have properties\n        if \"properties\" not in schema:\n            ttk.Label(\n                self.settings_content,\n                text=\"Invalid configuration schema\",\n                font=(\"\", 10, \"italic\")\n            ).pack(pady=20)\n            return\n            \n        # Get properties\n        properties = schema[\"properties\"]\n        \n        # Track row for grid\n        row = 0\n        \n        # Create widgets for each property\n        for prop_name, prop_details in properties.items():\n            if \"type\" not in prop_details:\n                continue\n                \n            # Get current value or default\n            current_value = config.get(prop_name, prop_details.get(\"default\", \"\"))\n            \n            # Create label\n            ttk.Label(\n                self.settings_content,\n                text=prop_details.get(\"title\", prop_name),\n                font=(\"\", 10)\n            ).grid(row=row, column=0, sticky=tk.W, padx=5, pady=5)\n            \n            # Create widget based on type\n            widget_type = prop_details[\"type\"]\n            \n            if widget_type == \"string\":\n                # Create string input\n                if \"enum\" in prop_details:\n                    # Create dropdown for enum\n                    var = tk.StringVar(value=str(current_value))\n                    dropdown = ttk.Combobox(\n                        self.settings_content,\n                        textvariable=var,\n                        values=prop_details[\"enum\"],\n                        state=\"readonly\",\n                        width=30\n                    )\n                    dropdown.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n                    self.config_widgets[prop_name] = var\n                else:\n                    # Create regular text input\n                    var = tk.StringVar(value=str(current_value))\n                    entry = ttk.Entry(self.settings_content, textvariable=var, width=30)\n                    entry.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n                    self.config_widgets[prop_name] = var\n                    \n            elif widget_type == \"integer\" or widget_type == \"number\":\n                # Create numeric input with validation\n                var = tk.StringVar(value=str(current_value))\n                validate_cmd = (self.settings_content.register(\n                    lambda s: s == \"\" or s.isdigit() or (s[0] == \"-\" and s[1:].isdigit())\n                ), '%P')\n                entry = ttk.Entry(\n                    self.settings_content, \n                    textvariable=var,\n                    validate=\"key\",\n                    validatecommand=validate_cmd,\n                    width=10\n                )\n                entry.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n                self.config_widgets[prop_name] = var\n                \n            elif widget_type == \"boolean\":\n                # Create checkbox\n                var = tk.BooleanVar(value=bool(current_value))\n                checkbox = ttk.Checkbutton(self.settings_content, variable=var)\n                checkbox.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n                self.config_widgets[prop_name] = var\n                \n            # Add description if available\n            if \"description\" in prop_details:\n                ttk.Label(\n                    self.settings_content,\n                    text=prop_details[\"description\"],\n                    font=(\"\", 8),\n                    foreground=\"gray\"\n                ).grid(row=row, column=2, sticky=tk.W, padx=5, pady=5)\n                \n            # Increment row\n            row += 1\n            \n        # Add save button\n        ttk.Button(\n            self.settings_content,\n            text=\"Save Configuration\",\n            command=self.save_plugin_config\n        ).grid(row=row, column=0, columnspan=3, sticky=tk.W, padx=5, pady=(10, 5))  \n        \n        # Add reset button\n        ttk.Button(\n            self.settings_content,\n            text=\"Reset Configuration\",\n            command=self.reset_plugin_config\n        ).grid(row=row + 1, column=0, columnspan=3, sticky=tk.W, padx=5, pady=5)\n        \n        # Add cancel button\n        ttk.Button(\n            self.settings_content,\n            text=\"Cancel\",\n            command=self.hide_settings\n        ).grid(row=row + 2, column=0, columnspan=3, sticky=tk.W, padx=5, pady=5)\n        \n        # Add spacing\n        ttk.Label(self.settings_content, text=\"\").grid(row=row + 3, column=0, columnspan=3, sticky=tk.W, padx=5, pady=5)\n        \n        # Add version label\n        ttk.Label(self.settings_content, text=\"Version: \" + self.current_plugin_version, font=(\"\", 8), foreground=\"gray\").grid(row=row + 4, column=0, columnspan=3, sticky=tk.W, padx=5, pady=5)\n        \n        # Add copyright label\n        ttk.Label(self.settings_content, text=\"Copyright: \" + self.current_plugin_copyright, font=(\"\", 8), foreground=\"gray\").grid(row=row + 5, column=0, columnspan=3, sticky=tk.W, padx=5, pady=5)\n        \n        # Add license label\n        ttk.Label(self.settings_content, text=\"License: \" + self.current_plugin_license, font=(\"\", 8), foreground=\"gray\").grid(row=row + 6, column=0, columnspan=3, sticky=tk.W, padx=5, pady=5)\n    def _append_sandbox_output(self, text, tag=None):\n        # Use after() to safely update from another thread\n        self.frame.after(0, lambda: self._do_append_sandbox_output(text, tag))  \n        \n    def _do_append_sandbox_output(self, text, tag=None):\n        self.sandbox_output.configure(state=\"normal\")\n        self.sandbox_output.insert(\"end\", text, tag)\n        self.sandbox_output.configure(state=\"disabled\")\n        \n        # Auto-scroll\n        self.sandbox_output.see(\"end\")\n        \n        # Update UI\n\n        threading.Thread(target=self.long_running_task).start()\n\n    def long_running_task(self):\n\n        time.sleep(5)\n        self._append_sandbox_output(\"Task completed.\\n\")\n        \n    def start_long_running_task(self):\n        threading.Thread(target=self.long_running_task).start()\n",
  "D:\\AI\\IrintAI Assistant\\ui\\panels\\config_panel.py": "\"\"\"\nConfiguration panel UI component for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, filedialog, messagebox\nimport os\nimport subprocess\nimport sys\nfrom typing import Callable, Dict, List, Any, Optional\n\nclass ConfigPanel:\n    \"\"\"Configuration panel for managing application settings\"\"\"\n\n    def __init__(self, parent, config_manager, model_manager, memory_system, chat_engine, logger: Callable, on_config_updated: Callable):\n        \"\"\"\n        Initialize the configuration panel\n\n        Args:\n            parent: Parent widget\n            config_manager: ConfigManager instance\n            model_manager: ModelManager instance\n            memory_system: MemorySystem instance\n            chat_engine: ChatEngine instance\n            logger: Logging function\n            on_config_updated: Callback for configuration updates\n        \"\"\"\n        self.parent = parent\n        self.config_manager = config_manager\n        self.model_manager = model_manager\n        self.memory_system = memory_system\n        self.chat_engine = chat_engine\n        self.log = logger\n        self.on_config_updated_callback = on_config_updated\n\n        # Create the main frame\n        self.frame = ttk.Frame(parent)\n\n        # Initialize dictionary for plugin settings widgets <<< ADD THIS LINE\n        self.plugin_settings_widgets = {}\n\n        # Initialize UI components\n        self.initialize_ui()\n        \n    def initialize_ui(self):\n        \"\"\"Initialize the UI components\"\"\"\n        # Create notebook for tabbed settings\n        self.notebook = ttk.Notebook(self.frame)\n        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create general settings tab\n        self.create_general_settings()\n        \n        # Create model settings tab\n        self.create_model_settings()\n        \n        # Create memory settings tab\n        self.create_memory_settings()\n        \n        # Create system settings tab\n        self.create_system_settings()\n        \n        # Add save and reset buttons at the bottom\n        button_frame = ttk.Frame(self.frame)\n        button_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Save All Settings\",\n            command=self.save_all_settings,\n            style=\"Accent.TButton\"\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Reset to Defaults\",\n            command=self.reset_to_defaults\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Apply Changes\",\n            command=self.apply_changes\n        ).pack(side=tk.RIGHT, padx=5)\n        \n    def create_general_settings(self):\n        \"\"\"Create the general settings tab\"\"\"\n        general_frame = ttk.Frame(self.notebook)\n        self.notebook.add(general_frame, text=\"General\")\n        \n        # Create UI section\n        ui_frame = ttk.LabelFrame(general_frame, text=\"UI Settings\")\n        ui_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Theme selection\n        theme_frame = ttk.Frame(ui_frame)\n        theme_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(theme_frame, text=\"Theme:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)\n        \n        self.theme_var = tk.StringVar(\n            value=self.config_manager.get(\"theme\", \"Light\")\n        )\n        theme_dropdown = ttk.Combobox(\n            theme_frame,\n            textvariable=self.theme_var,\n            values=[\"Light\", \"Dark\", \"System\"],\n            state=\"readonly\",\n            width=15\n        )\n        theme_dropdown.grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        # Font size\n        ttk.Label(theme_frame, text=\"Font Size:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)\n        \n        self.font_size_var = tk.StringVar(\n            value=str(self.config_manager.get(\"font_size\", 10))\n        )\n        font_size_spinbox = ttk.Spinbox(\n            theme_frame,\n            textvariable=self.font_size_var,\n            from_=8,\n            to=16,\n            width=5\n        )\n        font_size_spinbox.grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        # Show debug messages\n        self.show_debug_var = tk.BooleanVar(\n            value=self.config_manager.get(\"show_debug_messages\", False)\n        )\n        ttk.Checkbutton(\n            theme_frame,\n            text=\"Show Debug Messages\",\n            variable=self.show_debug_var\n        ).grid(row=2, column=0, columnspan=2, sticky=tk.W, padx=5, pady=2)\n        \n        # App behavior section\n        behavior_frame = ttk.LabelFrame(general_frame, text=\"Behavior\")\n        behavior_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Auto-start last model\n        self.auto_start_var = tk.BooleanVar(\n            value=self.config_manager.get(\"auto_start_last_model\", True)\n        )\n        ttk.Checkbutton(\n            behavior_frame,\n            text=\"Auto-start Last Used Model on Startup\",\n            variable=self.auto_start_var\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n        # Auto-save session\n        self.auto_save_var = tk.BooleanVar(\n            value=self.config_manager.get(\"auto_save_session\", True)\n        )\n        ttk.Checkbutton(\n            behavior_frame,\n            text=\"Auto-save Session on Exit\",\n            variable=self.auto_save_var\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n        # System prompt section\n        prompt_frame = ttk.LabelFrame(general_frame, text=\"Default System Prompt\")\n        prompt_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # System prompt entry\n        self.system_prompt_var = tk.StringVar(\n            value=self.config_manager.get(\n                \"system_prompt\", \n                \"You are Irintai, a helpful and knowledgeable assistant.\"\n            )\n        )\n        \n        system_entry = ttk.Entry(\n            prompt_frame,\n            textvariable=self.system_prompt_var,\n            width=70\n        )\n        system_entry.pack(fill=tk.X, padx=5, pady=5)\n        \n        # System prompt description\n        ttk.Label(\n            prompt_frame,\n            text=\"This prompt will be used when starting a new conversation.\",\n            font=(\"Helvetica\", 9, \"italic\")\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n    def create_model_settings(self):\n        \"\"\"Create the model settings tab\"\"\"\n        model_frame = ttk.Frame(self.notebook)\n        self.notebook.add(model_frame, text=\"Models\")\n        \n        # Model path section\n        path_frame = ttk.LabelFrame(model_frame, text=\"Model Storage\")\n        path_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        path_input_frame = ttk.Frame(path_frame)\n        path_input_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(path_input_frame, text=\"Model Path:\").pack(side=tk.LEFT)\n        \n        self.model_path_var = tk.StringVar(\n            value=self.config_manager.get(\"model_path\", \"data/models\")\n        )\n        path_entry = ttk.Entry(\n            path_input_frame,\n            textvariable=self.model_path_var,\n            width=50\n        )\n        path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n        \n        ttk.Button(\n            path_input_frame,\n            text=\"Browse\",\n            command=self.browse_model_path\n        ).pack(side=tk.LEFT)\n        \n        # Disk space info\n        self.disk_frame = ttk.Frame(path_frame)\n        self.disk_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        self.update_disk_space_info()\n        \n        ttk.Label(\n            self.disk_frame,\n            text=\"Note: Changing model path requires restart to take full effect.\",\n            font=(\"Helvetica\", 9, \"italic\")\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n        # Set system environment variable option\n        system_var_frame = ttk.Frame(path_frame)\n        system_var_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        self.set_sys_var = tk.BooleanVar(value=False)\n        ttk.Checkbutton(\n            system_var_frame,\n            text=\"Set OLLAMA_MODELS as system environment variable (recommended)\",\n            variable=self.set_sys_var\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            system_var_frame,\n            text=\"Apply System Variable\",\n            command=self.set_system_variable\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Model performance section\n        perf_frame = ttk.LabelFrame(model_frame, text=\"Model Performance\")\n        perf_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # 8-bit mode option\n        self.use_8bit_var = tk.BooleanVar(\n            value=self.config_manager.get(\"use_8bit\", False)\n        )\n        ttk.Checkbutton(\n            perf_frame,\n            text=\"Enable 8-bit mode for large models (13B+)\",\n            variable=self.use_8bit_var\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n        # Temperature setting\n        temp_frame = ttk.Frame(perf_frame)\n        temp_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(temp_frame, text=\"Temperature:\").pack(side=tk.LEFT)\n        \n        self.temperature_var = tk.DoubleVar(\n            value=self.config_manager.get(\"temperature\", 0.7)\n        )\n        temp_scale = ttk.Scale(\n            temp_frame,\n            from_=0.0,\n            to=1.0,\n            orient=tk.HORIZONTAL,\n            variable=self.temperature_var,\n            length=200\n        )\n        temp_scale.pack(side=tk.LEFT, padx=5)\n        \n        temp_label = ttk.Label(temp_frame, textvariable=self.temperature_var, width=5)\n        temp_label.pack(side=tk.LEFT)\n        \n        # Update temperature label when scale changes\n        temp_scale.bind(\"<Motion>\", lambda e: self.temperature_var.set(round(self.temperature_var.get(), 1)))\n        \n        # Temperature description\n        ttk.Label(\n            temp_frame,\n            text=\"(Higher = more creative, Lower = more precise)\",\n            font=(\"Helvetica\", 9, \"italic\")\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Inference mode\n        inference_frame = ttk.Frame(perf_frame)\n        inference_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(inference_frame, text=\"Inference Mode:\").pack(side=tk.LEFT)\n        \n        self.inference_mode_var = tk.StringVar(\n            value=self.config_manager.get(\"inference_mode\", \"GPU\")\n        )\n        mode_dropdown = ttk.Combobox(\n            inference_frame,\n            textvariable=self.inference_mode_var,\n            values=[\"GPU\", \"CPU\"],\n            state=\"readonly\",\n            width=10\n        )\n        mode_dropdown.pack(side=tk.LEFT, padx=5)\n        \n        # Mode description\n        gpu_desc = \"Use GPU acceleration if available (recommended)\"\n        cpu_desc = \"Force CPU-only mode (slower but more compatible)\"\n        \n        self.mode_desc_var = tk.StringVar(\n            value=gpu_desc if self.inference_mode_var.get() == \"GPU\" else cpu_desc\n        )\n        \n        ttk.Label(\n            inference_frame,\n            textvariable=self.mode_desc_var,\n            font=(\"Helvetica\", 9, \"italic\")\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Update description when mode changes\n        mode_dropdown.bind(\"<<ComboboxSelected>>\", lambda e: self.mode_desc_var.set(\n            gpu_desc if self.inference_mode_var.get() == \"GPU\" else cpu_desc\n        ))\n        \n    def create_memory_settings(self):\n        \"\"\"Create the memory settings tab\"\"\"\n        memory_frame = ttk.Frame(self.notebook)\n        self.notebook.add(memory_frame, text=\"Memory\")\n        \n        # Memory mode section\n        mode_frame = ttk.LabelFrame(memory_frame, text=\"Memory Mode\")\n        mode_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Mode selection\n        self.memory_mode_var = tk.StringVar(\n            value=self.config_manager.get(\"memory_mode\", \"Off\")\n        )\n        \n        modes = [\n            (\"Off\", \"Memory not used for responses\"),\n            (\"Manual\", \"Manual search only\"),\n            (\"Auto\", \"Automatically adds context to prompts\"),\n            (\"Background\", \"Silently adds context to all prompts\")\n        ]\n        \n        for i, (mode, desc) in enumerate(modes):\n            frame = ttk.Frame(mode_frame)\n            frame.pack(fill=tk.X, padx=5, pady=2)\n            \n            radio = ttk.Radiobutton(\n                frame,\n                text=mode,\n                variable=self.memory_mode_var,\n                value=mode\n            )\n            radio.pack(side=tk.LEFT)\n            \n            ttk.Label(\n                frame,\n                text=f\"- {desc}\",\n                font=(\"Helvetica\", 9, \"italic\")\n            ).pack(side=tk.LEFT, padx=5)\n        \n        # Vector store settings\n        vector_frame = ttk.LabelFrame(memory_frame, text=\"Vector Store\")\n        vector_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Index path\n        path_frame = ttk.Frame(vector_frame)\n        path_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(path_frame, text=\"Index Path:\").pack(side=tk.LEFT)\n        \n        self.index_path_var = tk.StringVar(\n            value=self.config_manager.get(\"index_path\", \"data/vector_store/vector_store.json\")\n        )\n        index_entry = ttk.Entry(\n            path_frame,\n            textvariable=self.index_path_var,\n            width=50\n        )\n        index_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n        \n        ttk.Button(\n            path_frame,\n            text=\"Browse\",\n            command=self.browse_index_path\n        ).pack(side=tk.LEFT)\n        \n        # Embedding model\n        model_frame = ttk.Frame(vector_frame)\n        model_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(model_frame, text=\"Embedding Model:\").pack(side=tk.LEFT)\n        \n        self.embedding_model_var = tk.StringVar(\n            value=self.config_manager.get(\"embedding_model\", \"all-MiniLM-L6-v2\")\n        )\n        model_dropdown = ttk.Combobox(\n            model_frame,\n            textvariable=self.embedding_model_var,\n            values=[\n                \"all-MiniLM-L6-v2\",\n                \"all-mpnet-base-v2\",\n                \"paraphrase-multilingual-MiniLM-L12-v2\"\n            ],\n            state=\"readonly\",\n            width=30\n        )\n        model_dropdown.pack(side=tk.LEFT, padx=5)\n        \n        # Search settings\n        search_frame = ttk.LabelFrame(memory_frame, text=\"Search Settings\")\n        search_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Result count\n        count_frame = ttk.Frame(search_frame)\n        count_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(count_frame, text=\"Default Results:\").pack(side=tk.LEFT)\n        \n        self.result_count_var = tk.IntVar(\n            value=self.config_manager.get(\"default_result_count\", 5)\n        )\n        count_spinbox = ttk.Spinbox(\n            count_frame,\n            textvariable=self.result_count_var,\n            from_=1,\n            to=20,\n            width=5\n        )\n        count_spinbox.pack(side=tk.LEFT, padx=5)\n        \n        # Relevance threshold\n        threshold_frame = ttk.Frame(search_frame)\n        threshold_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(threshold_frame, text=\"Relevance Threshold:\").pack(side=tk.LEFT)\n        \n        self.threshold_var = tk.DoubleVar(\n            value=self.config_manager.get(\"relevance_threshold\", 0.7)\n        )\n        threshold_scale = ttk.Scale(\n            threshold_frame,\n            from_=0.0,\n            to=1.0,\n            orient=tk.HORIZONTAL,\n            variable=self.threshold_var,\n            length=200\n        )\n        threshold_scale.pack(side=tk.LEFT, padx=5)\n        \n        threshold_label = ttk.Label(threshold_frame, textvariable=self.threshold_var, width=5)\n        threshold_label.pack(side=tk.LEFT)\n        \n        # Update threshold label when scale changes\n        threshold_scale.bind(\"<Motion>\", lambda e: self.threshold_var.set(round(self.threshold_var.get(), 2)))\n        \n    def create_system_settings(self):\n        \"\"\"Create the system settings tab\"\"\"\n        system_frame = ttk.Frame(self.notebook)\n        self.notebook.add(system_frame, text=\"System\")\n        \n        # Logging settings\n        log_frame = ttk.LabelFrame(system_frame, text=\"Logging\")\n        log_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Log file path\n        log_path_frame = ttk.Frame(log_frame)\n        log_path_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(log_path_frame, text=\"Log Directory:\").pack(side=tk.LEFT)\n        \n        self.log_dir_var = tk.StringVar(\n            value=self.config_manager.get(\"log_dir\", \"data/logs\")\n        )\n        log_entry = ttk.Entry(\n            log_path_frame,\n            textvariable=self.log_dir_var,\n            width=50\n        )\n        log_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n        \n        ttk.Button(\n            log_path_frame,\n            text=\"Browse\",\n            command=self.browse_log_dir\n        ).pack(side=tk.LEFT)\n        \n        # Log level\n        log_level_frame = ttk.Frame(log_frame)\n        log_level_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(log_level_frame, text=\"Log Level:\").pack(side=tk.LEFT)\n        \n        self.log_level_var = tk.StringVar(\n            value=self.config_manager.get(\"log_level\", \"INFO\")\n        )\n        level_dropdown = ttk.Combobox(\n            log_level_frame,\n            textvariable=self.log_level_var,\n            values=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"],\n            state=\"readonly\",\n            width=10\n        )\n        level_dropdown.pack(side=tk.LEFT, padx=5)\n        \n        # Max log size\n        log_size_frame = ttk.Frame(log_frame)\n        log_size_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(log_size_frame, text=\"Max Log Size (MB):\").pack(side=tk.LEFT)\n        \n        self.max_log_size_var = tk.IntVar(\n            value=self.config_manager.get(\"max_log_size_mb\", 10)\n        )\n        size_spinbox = ttk.Spinbox(\n            log_size_frame,\n            textvariable=self.max_log_size_var,\n            from_=1,\n            to=100,\n            width=5\n        )\n        size_spinbox.pack(side=tk.LEFT, padx=5)\n        \n        # Keep backup logs\n        self.keep_logs_var = tk.BooleanVar(\n            value=self.config_manager.get(\"keep_backup_logs\", True)\n        )\n        ttk.Checkbutton(\n            log_frame,\n            text=\"Keep Backup Logs\",\n            variable=self.keep_logs_var\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n        # Startup settings\n        startup_frame = ttk.LabelFrame(system_frame, text=\"Startup & Shutdown\")\n        startup_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Check for updates\n        self.check_updates_var = tk.BooleanVar(\n            value=self.config_manager.get(\"check_updates\", True)\n        )\n        ttk.Checkbutton(\n            startup_frame,\n            text=\"Check for Updates on Startup\",\n            variable=self.check_updates_var\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n        # Start minimized\n        self.start_minimized_var = tk.BooleanVar(\n            value=self.config_manager.get(\"start_minimized\", False)\n        )\n        ttk.Checkbutton(\n            startup_frame,\n            text=\"Start Minimized to System Tray\",\n            variable=self.start_minimized_var\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n        # Confirm on exit\n        self.confirm_exit_var = tk.BooleanVar(\n            value=self.config_manager.get(\"confirm_exit\", True)\n        )\n        ttk.Checkbutton(\n            startup_frame,\n            text=\"Confirm Before Exiting\",\n            variable=self.confirm_exit_var\n        ).pack(anchor=tk.W, padx=5, pady=2)\n        \n    def update_disk_space_info(self):\n        \"\"\"Update the disk space information display\"\"\"\n        path = self.model_path_var.get()\n        \n        try:\n            # Get drive letter\n            if os.name == 'nt':  # Windows\n                drive = os.path.splitdrive(path)[0]\n                if drive:\n                    drive = drive + \"\\\\\"\n                else:\n                    drive = \"C:\\\\\"  # Default to C: if no drive letter found\n            else:\n                drive = \"/\"  # Unix root\n                \n            # Get disk space info\n            import shutil\n            usage = shutil.disk_usage(drive)\n            free_space = round(usage.free / (1024**3), 2)  # Convert to GB\n            total_space = round(usage.total / (1024**3), 2)  # Convert to GB\n            \n            # Set color based on free space\n            color = \"green\" if free_space > 20 else \"red\"\n            \n            # Update label with disk space info\n            if hasattr(self, 'disk_info_label'):\n                self.disk_info_label.destroy()\n                \n            self.disk_info_label = ttk.Label(\n                self.disk_frame,\n                text=f\"Free space on {drive}: {free_space} GB / {total_space} GB\",\n                foreground=color\n            )\n            self.disk_info_label.pack(anchor=tk.W, padx=5, pady=2)\n        except Exception as e:\n            if hasattr(self, 'disk_info_label'):\n                self.disk_info_label.destroy()\n                \n            self.disk_info_label = ttk.Label(\n                self.disk_frame,\n                text=f\"Error checking disk space: {e}\",\n                foreground=\"red\"\n            )\n            self.disk_info_label.pack(anchor=tk.W, padx=5, pady=2)\n            \n    def browse_model_path(self):\n        \"\"\"Browse for model path\"\"\"\n        path = filedialog.askdirectory(\n            initialdir=self.model_path_var.get(),\n            title=\"Select Model Directory\"\n        )\n        \n        if path:\n            self.model_path_var.set(path)\n            self.update_disk_space_info()\n            \n    def browse_index_path(self):\n        \"\"\"Browse for index path\"\"\"\n        path = filedialog.asksaveasfilename(\n            initialdir=os.path.dirname(self.index_path_var.get()),\n            initialfile=os.path.basename(self.index_path_var.get()),\n            defaultextension=\".json\",\n            filetypes=[(\"JSON Files\", \"*.json\"), (\"All Files\", \"*.*\")],\n            title=\"Select Index File\"\n        )\n        \n        if path:\n            self.index_path_var.set(path)\n            \n    def browse_log_dir(self):\n        \"\"\"Browse for log directory\"\"\"\n        path = filedialog.askdirectory(\n            initialdir=self.log_dir_var.get(),\n            title=\"Select Log Directory\"\n        )\n        \n        if path:\n            self.log_dir_var.set(path)\n            \n    def set_system_variable(self):\n        \"\"\"Set system environment variable for model path\"\"\"\n        path = self.model_path_var.get()\n        \n        # Confirm action\n        result = messagebox.askyesno(\n            \"Set System Variable\",\n            f\"This will set OLLAMA_MODELS={path} as a system environment variable.\\n\\n\"\n            \"This requires administrator privileges and may prompt for elevation.\\n\\n\"\n            \"Do you want to continue?\",\n            icon=messagebox.WARNING\n        )\n        \n        if not result:\n            return\n            \n        # Try to set the variable\n        success = self.config_manager.set_system_path_var(path)\n        \n        if success:\n            messagebox.showinfo(\n                \"System Variable Set\",\n                \"Successfully set OLLAMA_MODELS system environment variable.\\n\\n\"\n                \"You may need to restart your computer for the change to take full effect.\"\n            )\n        else:\n            messagebox.showerror(\n                \"Error\",\n                \"Failed to set system environment variable.\\n\\n\"\n                \"This might be due to insufficient privileges.\"\n            )\n            \n    def save_all_settings(self):\n        \"\"\"Save all settings to config\"\"\"\n        # Collect all settings from UI\n        config = {}\n        \n        # General settings\n        config[\"theme\"] = self.theme_var.get()\n        config[\"font_size\"] = int(self.font_size_var.get())\n        config[\"show_debug_messages\"] = self.show_debug_var.get()\n        config[\"auto_start_last_model\"] = self.auto_start_var.get()\n        config[\"auto_save_session\"] = self.auto_save_var.get()\n        config[\"system_prompt\"] = self.system_prompt_var.get()\n        \n        # Model settings\n        config[\"model_path\"] = self.model_path_var.get()\n        config[\"use_8bit\"] = self.use_8bit_var.get()\n        config[\"temperature\"] = self.temperature_var.get()\n        config[\"inference_mode\"] = self.inference_mode_var.get()\n        \n        # Memory settings\n        config[\"memory_mode\"] = self.memory_mode_var.get()\n        config[\"index_path\"] = self.index_path_var.get()\n        config[\"embedding_model\"] = self.embedding_model_var.get()\n        config[\"default_result_count\"] = self.result_count_var.get()\n        config[\"relevance_threshold\"] = self.threshold_var.get()\n        \n        # System settings\n        config[\"log_dir\"] = self.log_dir_var.get()\n        config[\"log_level\"] = self.log_level_var.get()\n        config[\"max_log_size_mb\"] = self.max_log_size_var.get()\n        config[\"keep_backup_logs\"] = self.keep_logs_var.get()\n        config[\"check_updates\"] = self.check_updates_var.get()\n        config[\"start_minimized\"] = self.start_minimized_var.get()\n        config[\"confirm_exit\"] = self.confirm_exit_var.get()\n        \n        # Collect plugin settings\n        for plugin_id, settings_widget in self.plugin_settings_widgets.items():\n            # Check if widget has get_settings method\n            if hasattr(settings_widget, \"get_settings\"):\n                try:\n                    # Get settings from plugin\n                    plugin_settings = settings_widget.get_settings()\n                    \n                    if plugin_settings:\n                        # Add plugin settings with plugin_id prefix\n                        for key, value in plugin_settings.items():\n                            config[f\"{plugin_id}.{key}\"] = value\n                except Exception as e:\n                    self.log(f\"[Config] Error getting settings from plugin {plugin_id}: {e}\")\n        \n        # Update config manager\n        self.config_manager.update(config)\n        \n        # Save config\n        success = self.config_manager.save_config()\n        \n        if success:\n            messagebox.showinfo(\n                \"Settings Saved\",\n                \"All settings have been saved successfully.\"\n            )\n            \n            # Apply changes\n            self.apply_changes()\n        else:\n            messagebox.showerror(\n                \"Error\",\n                \"Failed to save settings.\"\n            )\n            \n    def reset_to_defaults(self):\n        \"\"\"Reset settings to default values\"\"\"\n        # Confirm action\n        result = messagebox.askyesno(\n            \"Reset to Defaults\",\n            \"Are you sure you want to reset all settings to default values?\",\n            icon=messagebox.WARNING\n        )\n        \n        if not result:\n            return\n            \n        # Reset config to defaults\n        self.config_manager.reset_to_defaults()\n        \n        # Update UI with default values\n        self.theme_var.set(\"Light\")\n        self.font_size_var.set(\"10\")\n        self.show_debug_var.set(False)\n        self.auto_start_var.set(True)\n        self.auto_save_var.set(True)\n        self.system_prompt_var.set(\"You are Irintai, a helpful and knowledgeable assistant.\")\n        \n        self.model_path_var.set(\"data/models\")\n        self.use_8bit_var.set(False)\n        self.temperature_var.set(0.7)\n        self.inference_mode_var.set(\"GPU\")\n        \n        self.memory_mode_var.set(\"Off\")\n        self.index_path_var.set(\"data/vector_store/vector_store.json\")\n        self.embedding_model_var.set(\"all-MiniLM-L6-v2\")\n        self.result_count_var.set(5)\n        self.threshold_var.set(0.7)\n        \n        self.log_dir_var.set(\"data/logs\")\n        self.log_level_var.set(\"INFO\")\n        self.max_log_size_var.set(10)\n        self.keep_logs_var.set(True)\n        self.check_updates_var.set(True)\n        self.start_minimized_var.set(False)\n        self.confirm_exit_var.set(True)\n        \n        # Update disk space info\n        self.update_disk_space_info()\n        \n        messagebox.showinfo(\n            \"Settings Reset\",\n            \"All settings have been reset to default values.\\n\\n\"\n            \"Click 'Save All Settings' to apply these changes.\"\n        )\n        \n    def apply_changes(self):\n        \"\"\"Apply changes without saving to config file\"\"\"\n        # Update model path environment variables\n        if self.model_path_var.get() != self.model_manager.model_path:\n            self.model_manager.update_model_path(self.model_path_var.get())\n            \n        # Update model manager settings\n        self.model_manager.use_8bit = self.use_8bit_var.get()\n        \n        # Update memory system settings\n        if self.index_path_var.get() != self.memory_system.index_path:\n            # Create a new memory system with the new path\n            old_path = self.memory_system.index_path\n            new_path = self.index_path_var.get()\n            \n            # Ask if the user wants to copy the old index to the new path\n            if os.path.exists(old_path):\n                result = messagebox.askyesno(\n                    \"Copy Index\",\n                    f\"Do you want to copy the existing index from\\n{old_path}\\nto\\n{new_path}?\",\n                    icon=messagebox.QUESTION\n                )\n                \n                if result:\n                    # Create directory if it doesn't exist\n                    os.makedirs(os.path.dirname(new_path), exist_ok=True)\n                    \n                    # Copy the file\n                    import shutil\n                    try:\n                        shutil.copy2(old_path, new_path)\n                        self.log(f\"[Config] Copied index from {old_path} to {new_path}\")\n                    except Exception as e:\n                        self.log(f\"[Error] Failed to copy index: {e}\")\n                        messagebox.showerror(\n                            \"Error\",\n                            f\"Failed to copy index: {e}\"\n                        )\n            \n            # Update memory system path\n            self.memory_system.index_path = new_path\n            \n            # Reload index\n            self.memory_system.load_index()\n        \n        # Update chat engine settings\n        self.chat_engine.set_system_prompt(self.system_prompt_var.get())\n        self.chat_engine.set_memory_mode(self.memory_mode_var.get())\n        \n        # Apply plugin settings\n        for plugin_id, settings_widget in self.plugin_settings_widgets.items():\n            # Check if widget has apply_settings method\n            if hasattr(settings_widget, \"apply_settings\"):\n                try:\n                    # Apply settings\n                    settings_widget.apply_settings()\n                except Exception as e:\n                    self.log(f\"[Config] Error applying settings for plugin {plugin_id}: {e}\")\n        \n        # Call the callback to notify parent\n        if self.on_config_updated_callback:\n            self.on_config_updated_callback()\n            \n        messagebox.showinfo(\n            \"Changes Applied\",\n            \"Changes have been applied to the running system.\\n\\n\"\n            \"Note that some changes may require a restart to take full effect.\"\n        )",
  "D:\\AI\\IrintAI Assistant\\file_operations\\pdf_file_ops.py": "\"\"\"\nEnhanced PDF Extraction for IrintAI Assistant\n\nThis module provides improved PDF text extraction capabilities using:\n1. PyMuPDF for robust PDF parsing\n2. Text preprocessing to clean extracted content\n3. Optional OCR for image-based content\n\"\"\"\n\nimport os\nimport re\nimport fitz  # PyMuPDF\nimport base64\nfrom typing import Tuple, List, Dict, Any, Optional\nfrom file_operations.file_ops import FileOps\n\n# Try to import OCR dependencies, but make them optional\ntry:\n    import pytesseract\n    from PIL import Image\n    import numpy as np\n    HAS_OCR = True\nexcept ImportError:\n    HAS_OCR = False\n\n\nclass PDFFileOps:\n    \"\"\"Extends FileOps with enhanced PDF handling capabilities\"\"\"\n    \n    def __init__(self, file_ops: FileOps, enable_ocr: bool = False):\n        \"\"\"\n        Initialize PDF file operations\n        \n        Args:\n            file_ops: Base FileOps instance\n            enable_ocr: Whether to enable OCR for image-based text\n        \"\"\"\n        self.file_ops = file_ops\n        self.pdf_extractor = get_pdf_extractor(logger=file_ops.log, enable_ocr=enable_ocr)\n        \n    def read_pdf(self, file_path: str) -> Tuple[bool, str]:\n        \"\"\"\n        Read a PDF file with enhanced text extraction\n        \n        Args:\n            file_path: Path to the PDF file\n            \n        Returns:\n            Tuple with success flag and extracted text\n        \"\"\"\n        # Check if file exists\n        if not os.path.exists(file_path):\n            self.file_ops.log(f\"[PDF] File not found: {file_path}\")\n            return False, f\"Error: File not found: {file_path}\"\n            \n        # Check if file is a PDF\n        if not file_path.lower().endswith(\".pdf\"):\n            self.file_ops.log(f\"[PDF] Not a PDF file: {file_path}\")\n            return False, \"Error: Not a PDF file\"\n            \n        # Extract text from PDF using enhanced extractor\n        return self.pdf_extractor.extract_text_from_pdf(file_path)\n        \n    def get_pdf_metadata(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Get metadata from a PDF file\n        \n        Args:\n            file_path: Path to the PDF file\n            \n        Returns:\n            Dictionary with PDF metadata\n        \"\"\"\n        try:\n            import fitz  # PyMuPDF\n            \n            if not os.path.exists(file_path):\n                self.file_ops.log(f\"[PDF] File not found: {file_path}\")\n                return {\"error\": \"File not found\"}\n                \n            # Open the PDF\n            doc = fitz.open(file_path)\n            \n            # Get basic metadata\n            metadata = {\n                \"title\": doc.metadata.get(\"title\", \"\"),\n                \"author\": doc.metadata.get(\"author\", \"\"),\n                \"subject\": doc.metadata.get(\"subject\", \"\"),\n                \"keywords\": doc.metadata.get(\"keywords\", \"\"),\n                \"creator\": doc.metadata.get(\"creator\", \"\"),\n                \"producer\": doc.metadata.get(\"producer\", \"\"),\n                \"creation_date\": doc.metadata.get(\"creationDate\", \"\"),\n                \"modification_date\": doc.metadata.get(\"modDate\", \"\"),\n                \"page_count\": len(doc),\n                \"file_size\": os.path.getsize(file_path),\n                \"has_text\": any(page.get_text().strip() for page in doc),\n                \"is_encrypted\": doc.is_encrypted,\n                \"permissions\": doc.permissions if hasattr(doc, \"permissions\") else None\n            }\n            \n            # Additional statistics\n            text_length = sum(len(page.get_text()) for page in doc)\n            metadata[\"total_text_length\"] = text_length\n            \n            # Count images\n            image_count = 0\n            for page in doc:\n                image_count += len(page.get_images())\n            metadata[\"image_count\"] = image_count\n            \n            doc.close()\n            return metadata\n            \n        except Exception as e:\n            self.file_ops.log(f\"[PDF] Error getting metadata: {e}\")\n            return {\"error\": str(e)}\n\n    @staticmethod\n    def extend_file_ops(file_ops: FileOps, enable_ocr: bool = False) -> \"PDFFileOps\":\n        \"\"\"\n        Extend a FileOps instance with enhanced PDF capabilities\n        \n        Args:\n            file_ops: The FileOps instance to extend\n            enable_ocr: Whether to enable OCR for image-based text\n            \n        Returns:\n            PDFFileOps instance\n        \"\"\"\n        return PDFFileOps(file_ops, enable_ocr=enable_ocr)\n\nclass EnhancedPDFExtractor:\n    \"\"\"Enhanced PDF extraction with preprocessing and OCR capabilities\"\"\"\n    \n    def __init__(self, logger=None, ocr_enabled=False, ocr_lang=\"eng\"):\n        \"\"\"\n        Initialize the PDF extractor with optional OCR support\n        \n        Args:\n            logger: Optional logging function\n            ocr_enabled: Whether to use OCR when text extraction fails\n            ocr_lang: Language for OCR (default: English)\n        \"\"\"\n        self.logger = logger or print\n        self.ocr_enabled = ocr_enabled and HAS_OCR\n        self.ocr_lang = ocr_lang\n        \n        # If OCR is enabled but dependencies aren't installed, log a warning\n        if ocr_enabled and not HAS_OCR:\n            self.logger(\"[PDF] OCR requested but dependencies not installed. Install pytesseract and Pillow.\")\n    \n    def extract_text_from_pdf(self, pdf_path: str) -> Tuple[bool, str]:\n        \"\"\"\n        Extract text from a PDF with enhanced quality\n        \n        Args:\n            pdf_path: Path to the PDF file\n            \n        Returns:\n            Tuple with success flag and extracted text\n        \"\"\"\n        if not os.path.exists(pdf_path):\n            self.logger(f\"[PDF] File not found: {pdf_path}\")\n            return False, f\"Error: File not found: {pdf_path}\"\n            \n        try:\n            self.logger(f\"[PDF] Extracting text from {os.path.basename(pdf_path)}\")\n            document = fitz.open(pdf_path)\n            \n            content = []\n            images_processed = 0\n            \n            for page_num, page in enumerate(document):\n                # First try regular text extraction\n                text = page.get_text(\"text\")\n                \n                # If page has very little text and OCR is enabled, try OCR\n                if len(text.strip()) < 100 and self.ocr_enabled:\n                    # Only process the page with OCR if it likely contains images\n                    if page.get_images():\n                        ocr_text = self._ocr_page(page, page_num)\n                        if ocr_text.strip():\n                            text = ocr_text\n                            images_processed += 1\n                \n                # Clean and preprocess the text\n                text = self._preprocess_text(text)\n                \n                # Add page number as metadata\n                page_header = f\"\\n\\n--- Page {page_num + 1} ---\\n\\n\"\n                content.append(page_header + text)\n            \n            document.close()\n            \n            if images_processed > 0:\n                self.logger(f\"[PDF] Used OCR on {images_processed} pages with minimal text\")\n                \n            full_text = \"\\n\".join(content)\n            \n            # Apply global cleaning\n            full_text = self._apply_global_cleaning(full_text)\n            \n            return True, full_text\n            \n        except Exception as e:\n            self.logger(f\"[PDF] Error extracting text: {e}\")\n            return False, f\"Error: {str(e)}\"\n    \n    def _preprocess_text(self, text: str) -> str:\n        \"\"\"Clean and normalize extracted text\"\"\"\n        # Replace multiple newlines with double newline\n        text = re.sub(r'\\n{3,}', '\\n\\n', text)\n        \n        # Remove null bytes and other control characters except newlines and tabs\n        text = re.sub(r'[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\xFF]', '', text)\n        \n        # Replace Unicode replacement characters\n        text = text.replace(\"\\uFFFD\", \"\")\n        \n        # Fix common PDF encoding issues with math symbols\n        text = text.replace(\"\u03b1\", \"alpha\")\n        text = text.replace(\"\u03b2\", \"beta\")\n        text = text.replace(\"\u03b3\", \"gamma\")\n        text = text.replace(\"\u0394\", \"Delta\")\n        text = text.replace(\"\u03c0\", \"pi\")\n        text = text.replace(\"\u221e\", \"infinity\")\n        \n        # Clean up excessive whitespace without removing paragraph breaks\n        text = re.sub(r' {2,}', ' ', text)\n        \n        # Fix hyphens at end of lines (attempt to identify hyphenated words)\n        text = re.sub(r'([a-zA-Z])- *\\n *([a-zA-Z])', r'\\1\\2', text)\n        \n        return text\n    \n    def _apply_global_cleaning(self, text: str) -> str:\n        \"\"\"Apply global text cleaning operations\"\"\"\n        # Remove PDF artifacts like headers/footers that repeat on every page\n        # This uses a heuristic to detect repeated lines at page boundaries\n        lines = text.split('\\n')\n        repeated_lines = self._find_repeated_lines(lines)\n        \n        for pattern in repeated_lines:\n            if len(pattern) > 5:  # Only remove if substantial pattern found\n                text = text.replace(pattern, '')\n        \n        # Final cleanup of multiple blank lines\n        text = re.sub(r'\\n{3,}', '\\n\\n', text)\n        \n        return text\n    \n    def _find_repeated_lines(self, lines: List[str]) -> List[str]:\n        \"\"\"Find lines that repeat across pages (likely headers/footers)\"\"\"\n        patterns = []\n        threshold = 3  # Minimum occurrences to consider a line as repeating\n        \n        # Count line frequencies\n        line_counts = {}\n        for line in lines:\n            line_clean = line.strip()\n            if len(line_clean) > 5:  # Ignore very short lines\n                line_counts[line_clean] = line_counts.get(line_clean, 0) + 1\n        \n        # Find repeated lines\n        for line, count in line_counts.items():\n            if count >= threshold:\n                patterns.append(line)\n                \n        return patterns\n    \n    def _ocr_page(self, page, page_num: int) -> str:\n        \"\"\"Extract text from a page using OCR\"\"\"\n        if not HAS_OCR:\n            return \"\"\n            \n        try:\n            # Convert page to a PIL Image\n            pix = page.get_pixmap(matrix=fitz.Matrix(2, 2))  # Increase resolution for OCR\n            img = Image.frombytes(\"RGB\", [pix.width, pix.height], pix.samples)\n            \n            # Use pytesseract for OCR\n            text = pytesseract.image_to_string(img, lang=self.ocr_lang)\n            return text\n        except Exception as e:\n            self.logger(f\"[PDF] OCR failed on page {page_num}: {e}\")\n            return \"\"\n\ndef get_pdf_extractor(logger=None, enable_ocr=False):\n    \"\"\"Factory function to create a PDF extractor\"\"\"\n    return EnhancedPDFExtractor(logger=logger, ocr_enabled=enable_ocr)\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\personality_plugin\\core\\__init__.py": "\"\"\"\nPersonality Plugin Core Module - Provides functionality for modulating assistant's communication style\n\nThis module contains the core functionality for the Personality Plugin, including:\n- The main PersonalityPlugin class\n- Helper functions for profile management\n- Utilities for text transformation and style analysis\n\"\"\"\n\n# Import the main plugin class\nfrom plugins.personality_plugin.core.personality_plugin import PersonalityPlugin\n\n# Import helper functions for easy access\nfrom plugins.personality_plugin.core.helpers import (create_empty_profile,\n    load_default_profiles,\n    validate_profile,\n    merge_profiles,\n    calculate_style_vector,\n    apply_style_transforms,\n    find_similar_profiles,\n    export_profile_to_file,\n    import_profile_from_file,\n    create_empty_profile)\n\n# Package metadata\n__version__ = \"1.0.0\"\n__author__ = \"Andrew\"\n__license__ = \"MIT\"\n\n# Constants for profile aspects\nSTYLE_DIMENSIONS = [\n    \"formality\",\n    \"creativity\", \n    \"complexity\",\n    \"empathy\", \n    \"directness\",\n    \"humor\",\n    \"enthusiasm\", \n    \"conciseness\"\n]\n\n# Default style values\nDEFAULT_STYLE = {dim: 0.5 for dim in STYLE_DIMENSIONS}\n\n# Export public interface\n__all__ = [\n    # Main class\n    'PersonalityPlugin',\n    \n    # Helper functions\n    'load_default_profiles',\n    'validate_profile',\n    'merge_profiles',\n    'calculate_style_vector',\n    'apply_style_transforms',\n    'find_similar_profiles',\n    'export_profile_to_file',\n    'import_profile_from_file',\n    'create_empty_profile',\n    \n    # Constants\n    'STYLE_DIMENSIONS',\n    'DEFAULT_STYLE',\n    \n    # Metadata\n    '__version__',\n    '__author__',\n    '__license__'\n]",
  "D:\\AI\\IrintAI Assistant\\ui\\panels\\chat_panel.py": "\"\"\"\nChat panel UI component for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, scrolledtext\nimport time\nfrom typing import Callable, Optional, Dict, List, Any\nimport threading\nfrom core.model_manager import MODEL_STATUS\n\nclass ChatPanel:\n    \"\"\"Chat interface panel for user interaction with the AI assistant\"\"\"\n\n    def __init__(self, parent, chat_engine, logger: Callable, config_manager):\n        \"\"\"\n        Initialize the chat panel\n\n        Args:\n            parent: Parent widget\n            chat_engine: ChatEngine instance\n            logger: Logging function\n            config_manager: ConfigManager instance\n        \"\"\"\n        self.parent = parent\n        self.chat_engine = chat_engine\n        self.log = logger\n        self.config_manager = config_manager\n\n        # Create the main frame\n        self.frame = ttk.Frame(parent)\n\n        # Initialize UI components\n        self.initialize_ui()\n\n        # Initialize plugin hooks \n        self.initialize_plugin_hooks()\n\n        # Load chat history\n        self.load_chat_history()\n\n        # Update status indicators \n        self.update_status_indicators()\n\n        # Set up keyboard shortcuts\n        self.attach_keyboard_shortcuts()\n        \n    def initialize_ui(self):\n        \"\"\"Initialize the UI components\"\"\"\n        # System prompt section\n        self.create_system_prompt_section()\n        \n        # Chat console section\n        self.create_chat_console()\n        \n        # Input section\n        self.create_input_section()\n        \n        # Timeline section\n        self.create_timeline_section()\n        \n    def create_system_prompt_section(self):\n        \"\"\"Create the system prompt input section\"\"\"\n        self.system_frame = ttk.Frame(self.frame)\n        self.system_frame.pack(fill=tk.X, padx=5, pady=(5, 0))\n        \n        # Add label\n        ttk.Label(\n            self.system_frame, \n            text=\"System Prompt:\", \n            font=(\"Arial\", 9, \"bold\")\n        ).pack(side=tk.LEFT)\n        \n        # Add entry for system prompt\n        self.system_prompt_var = tk.StringVar(\n            value=self.chat_engine.system_prompt\n        )\n        self.system_prompt_entry = ttk.Entry(\n            self.system_frame, \n            textvariable=self.system_prompt_var, \n            width=70\n        )\n        self.system_prompt_entry.pack(\n            side=tk.LEFT, \n            fill=tk.X, \n            expand=True, \n            padx=5\n        )\n        \n        # Add apply button\n        ttk.Button(\n            self.system_frame, \n            text=\"Apply\", \n            command=self.apply_system_prompt,\n            style=\"Accent.TButton\"\n        ).pack(side=tk.LEFT)\n        \n        # Add presets section\n        preset_frame = ttk.Frame(self.frame)\n        preset_frame.pack(fill=tk.X, padx=5, pady=(0, 5))\n        \n        ttk.Label(preset_frame, text=\"Presets:\").pack(side=tk.LEFT)\n        \n        # Load presets from config or use defaults\n        self.system_presets = self.config_manager.get(\n            \"system_presets\", \n            [\n                \"You are Irintai, a helpful and knowledgeable assistant.\",\n                \"You are Irintai, an AI programmer focused on writing clean, efficient code.\",\n                \"You are Irintai, a creative writing assistant specializing in storytelling.\",\n                \"You are Irintai, an academic research assistant with expertise in scholarly analysis.\",\n                \"You are Irintai, a personal coach helping with motivation and productivity.\"\n            ]\n        )\n        \n        # Create preset dropdown\n        self.system_preset_var = tk.StringVar()\n        self.system_preset_dropdown = ttk.Combobox(\n            preset_frame, \n            textvariable=self.system_preset_var, \n            values=self.system_presets,\n            width=70,\n            state=\"readonly\"\n        )\n        self.system_preset_dropdown.pack(\n            side=tk.LEFT, \n            fill=tk.X, \n            expand=True, \n            padx=5\n        )\n        self.system_preset_dropdown.bind(\n            \"<<ComboboxSelected>>\", \n            self.on_system_preset_selected\n        )\n        \n        # Add save preset button\n        ttk.Button(\n            preset_frame, \n            text=\"Save Current as Preset\", \n            command=self.save_system_preset\n        ).pack(side=tk.LEFT)\n    \n    def create_chat_console(self):\n        \"\"\"Create the chat console display area\"\"\"\n        chat_frame = ttk.Frame(self.frame)\n        chat_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Create a labeled frame for the chat console\n        chat_label_frame = ttk.LabelFrame(chat_frame, text=\"Chat Window\")\n        chat_label_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Create the console with better styling\n        self.console = scrolledtext.ScrolledText(\n            chat_label_frame, \n            wrap=tk.WORD, \n            font=(\"Helvetica\", 10),\n            width=80,\n            height=20\n        )\n        self.console.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Make console read-only\n        self.console.config(state=tk.DISABLED)\n        \n        # Configure text tags for better formatting\n        self.console.tag_configure(\n            \"user\", \n            foreground=\"#000080\", \n            font=(\"Helvetica\", 10, \"bold\")\n        )\n        self.console.tag_configure(\n            \"irintai\", \n            foreground=\"#800000\", \n            font=(\"Helvetica\", 10, \"bold\")\n        )\n        self.console.tag_configure(\n            \"user_message\", \n            foreground=\"#000000\", \n            lmargin1=20, \n            lmargin2=20\n        )\n        self.console.tag_configure(\n            \"irintai_message\", \n            foreground=\"#000000\", \n            background=\"#f8f8f8\", \n            lmargin1=20, \n            lmargin2=20, \n            rmargin=10\n        )\n        self.console.tag_configure(\n            \"system\", \n            foreground=\"#008000\", \n            font=(\"Helvetica\", 9, \"italic\")\n        )\n        self.console.tag_configure(\n            \"timestamp\", \n            foreground=\"#888888\", \n            font=(\"Helvetica\", 8)\n        )\n        \n        # Add filter controls\n        filter_frame = ttk.Frame(self.frame)\n        filter_frame.pack(fill=tk.X, padx=5, pady=(0, 5))\n        \n        ttk.Label(filter_frame, text=\"Filter:\").pack(side=tk.LEFT)\n        \n        self.filter_var = tk.StringVar(value=\"All\")\n        self.filter_dropdown = ttk.Combobox(\n            filter_frame, \n            textvariable=self.filter_var,\n            values=[\"All\", \"User\", \"Irintai\", \"System\"],\n            state=\"readonly\",\n            width=10\n        )\n        self.filter_dropdown.pack(side=tk.LEFT, padx=5)\n        self.filter_dropdown.bind(\"<<ComboboxSelected>>\", self.apply_filter)\n        \n        # Add clear button\n        ttk.Button(\n            filter_frame, \n            text=\"Clear Console\", \n            command=self.clear_console\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        # Add save button\n        ttk.Button(\n            filter_frame, \n            text=\"Save Conversation\", \n            command=self.save_conversation\n        ).pack(side=tk.RIGHT, padx=5)\n        \n    def create_input_section(self):\n        \"\"\"Create the user input section\"\"\"\n        input_frame = ttk.Frame(self.frame)\n        input_frame.pack(fill=tk.X, padx=5, pady=(0, 5))\n        \n        # Create the input entry\n        self.prompt_entry = ttk.Entry(input_frame, font=(\"Helvetica\", 10))\n        self.prompt_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n        self.prompt_entry.bind(\"<Return>\", self.submit_prompt)\n        \n        # Add submit button\n        self.submit_button = ttk.Button(\n            input_frame,\n            text=\"Send\",\n            command=self.submit_prompt,\n            style=\"Accent.TButton\"\n        )\n        self.submit_button.pack(side=tk.LEFT, padx=5)\n        \n        # Add model control buttons\n        ttk.Button(\n            input_frame,\n            text=\"Start Model\",\n            command=self.start_model\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Button(\n            input_frame,\n            text=\"Stop Model\",\n            command=self.stop_model\n        ).pack(side=tk.LEFT, padx=2)\n        \n        # Add status indicator\n        self.status_light = ttk.Label(\n            input_frame,\n            text=\"\u25cf\",\n            font=(\"Helvetica\", 14),\n            foreground=\"red\"\n        )\n        self.status_light.pack(side=tk.LEFT, padx=5)\n        \n    def create_timeline_section(self):\n        \"\"\"Create the conversation timeline\"\"\"\n        timeline_frame = ttk.Frame(self.frame)\n        timeline_frame.pack(fill=tk.X, padx=5, pady=(0, 5))\n        \n        ttk.Label(timeline_frame, text=\"Timeline:\").pack(side=tk.LEFT)\n        \n        # Create the timeline listbox\n        self.timeline_listbox = tk.Listbox(\n            timeline_frame,\n            height=3,\n            font=(\"Helvetica\", 9)\n        )\n        self.timeline_listbox.pack(\n            side=tk.LEFT,\n            fill=tk.X,\n            expand=True,\n            padx=5\n        )\n        \n        # Add scrollbar\n        timeline_scrollbar = ttk.Scrollbar(\n            timeline_frame,\n            orient=\"vertical\",\n            command=self.timeline_listbox.yview\n        )\n        timeline_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.timeline_listbox.config(yscrollcommand=timeline_scrollbar.set)\n        \n        # Bind selection event\n        self.timeline_listbox.bind(\n            \"<<ListboxSelect>>\",\n            self.on_timeline_selected\n        )\n        \n        # Initialize timeline map\n        self.timeline_map = {}\n        \n    def apply_system_prompt(self):\n        \"\"\"Apply the system prompt\"\"\"\n        system_prompt = self.system_prompt_var.get().strip()\n        if not system_prompt:\n            return\n        \n        # Update the chat engine\n        self.chat_engine.set_system_prompt(system_prompt)\n        \n        # Save to config\n        self.config_manager.set(\"system_prompt\", system_prompt)\n        self.config_manager.save_config()\n        \n        # Log the change\n        self.log(f\"[System Prompt] Applied: {system_prompt}\")\n        \n        # Enable text insertion\n        self.console.config(state=tk.NORMAL)\n        \n        # Show in console\n        self.console.insert(\n            tk.END,\n            f\"[System] System prompt updated: {system_prompt}\\n\\n\",\n            \"system\"\n        )\n        self.console.see(tk.END)\n        \n        # Make console read-only again\n        self.console.config(state=tk.DISABLED)\n        \n    def on_system_preset_selected(self, event):\n        \"\"\"Handle system prompt preset selection\"\"\"\n        selected = self.system_preset_var.get()\n        if selected:\n            self.system_prompt_var.set(selected)\n            self.apply_system_prompt()\n            \n    def save_system_preset(self):\n        \"\"\"Save the current system prompt as a preset\"\"\"\n        current = self.system_prompt_var.get().strip()\n        if not current:\n            return\n            \n        # Add to presets if not already present\n        if current not in self.system_presets:\n            self.system_presets.append(current)\n            self.system_preset_dropdown['values'] = self.system_presets\n            \n            # Save to config\n            self.config_manager.set(\"system_presets\", self.system_presets)\n            self.config_manager.save_config()\n            \n            self.log(f\"[System Preset] Saved: {current}\")\n        else:\n            self.log(\"[System Preset] This preset already exists\")\n    \n    def load_chat_history(self):\n        \"\"\"Load and display chat history\"\"\"\n        # Enable text insertion\n        self.console.config(state=tk.NORMAL)\n        \n        # Clear the console first\n        self.console.delete(1.0, tk.END)\n        \n        # Make console read-only between operations\n        self.console.config(state=tk.DISABLED)\n        \n        # Get history from chat engine\n        history = self.chat_engine.chat_history\n        \n        # Display the history\n        for message in history:\n            role = message.get(\"role\", \"\")\n            content = message.get(\"content\", \"\")\n            timestamp = message.get(\"timestamp\", \"\")\n            \n            if role == \"user\":\n                self.display_user_message(content, timestamp)\n            elif role == \"assistant\":\n                self.display_assistant_message(content, timestamp)\n                \n        # Update timeline\n        self.update_timeline()\n\n    def update_status_indicators(self): # <<< MODIFY THIS METHOD\n        \"\"\"Update the status indicator based on the model's status.\"\"\"\n        if hasattr(self, 'status_light') and hasattr(self.chat_engine, 'model_manager'):\n            model_manager = self.chat_engine.model_manager\n            is_running = model_manager.model_process and model_manager.model_process.poll() is None\n            current_status = model_manager.model_statuses.get(model_manager.current_model, \"Unknown\")\n\n            # Use the imported MODEL_STATUS dictionary\n            if is_running and current_status == MODEL_STATUS[\"RUNNING\"]:\n                self.status_light.config(foreground=\"green\", text=\"\u25cf Running\")\n            elif current_status == MODEL_STATUS[\"LOADING\"]:\n                 self.status_light.config(foreground=\"orange\", text=\"\u25cf Loading\")\n            elif current_status == MODEL_STATUS[\"ERROR\"]:\n                self.status_light.config(foreground=\"red\", text=\"\u25cf Error\")\n            else:\n                self.status_light.config(foreground=\"red\", text=\"\u25cf Stopped\")\n            self.frame.after(5000, self.update_status_indicators) # Check every 5 seconds\n\n    def attach_keyboard_shortcuts(self): \n        \"\"\"Attach keyboard shortcuts to the input entry.\"\"\"\n\n        self.prompt_entry.bind(\"<Control-Return>\", self.submit_prompt)\n    def display_user_message(self, content, timestamp=None):\n        \"\"\"\n        Display a user message in the console\n        \n        Args:\n            content: Message content\n            timestamp: Optional timestamp\n        \"\"\"\n        if not timestamp:\n            timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n            \n        # Enable text insertion\n        self.console.config(state=tk.NORMAL)\n            \n        # Add timestamp\n        self.console.insert(\n            tk.END,\n            f\"[{timestamp}] \",\n            \"timestamp\"\n        )\n        \n        # Add user header\n        self.console.insert(\n            tk.END,\n            \"[User] \",\n            \"user\"\n        )\n        \n        # Add message content\n        self.console.insert(\n            tk.END,\n            f\"{content}\\n\\n\",\n            \"user_message\"\n        )\n        \n        # Make console read-only again\n        self.console.config(state=tk.DISABLED)\n        \n        # Scroll to end\n        self.console.see(tk.END)\n        \n        # Make console read-only again\n        self.console.config(state=tk.DISABLED)\n    \n    def display_assistant_message(self, content, timestamp=None):\n        \"\"\"\n        Display an assistant message in the console\n        \n        Args:\n            content: Message content\n            timestamp: Optional timestamp\n        \"\"\"\n        if not timestamp:\n            timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n            \n        # Process content through plugin hooks\n        processed_content = self.process_message_hooks(content, \"assistant\")\n        \n        # Enable text insertion\n        self.console.config(state=tk.NORMAL)\n            \n        # Add timestamp\n        self.console.insert(\n            tk.END,\n            f\"[{timestamp}] \",\n            \"timestamp\"\n        )\n        \n        # Add assistant header\n        self.console.insert(\n            tk.END,\n            \"[Irintai] \",\n            \"irintai\"\n        )\n        \n        # Add message content\n        self.console.insert(\n            tk.END,\n            f\"{processed_content}\\n\\n\",\n            \"irintai_message\"\n        )\n        \n        # Make console read-only again\n        self.console.config(state=tk.DISABLED)\n        \n        # Scroll to end\n        self.console.see(tk.END)\n        \n        # Make console read-only again\n        self.console.config(state=tk.DISABLED)\n        \n    def submit_prompt(self, event=None):\n        \"\"\"Submit the user prompt\"\"\"\n        prompt = self.prompt_entry.get().strip()\n        if not prompt:\n            return\n            \n        # Clear the entry\n        self.prompt_entry.delete(0, tk.END)\n        \n        # Display user message\n        self.display_user_message(prompt)\n        \n        # Add to timeline\n        self.update_timeline(prompt)\n        \n        # Disable submit button while processing\n        self.submit_button.config(state=tk.DISABLED)\n        \n        # Send to chat engine\n        def on_response(response):\n            # Display assistant response\n            self.display_assistant_message(response)\n            \n            # Re-enable submit button\n            self.submit_button.config(state=tk.NORMAL)\n            \n            # Focus on entry\n            self.prompt_entry.focus_set()\n            \n        # Process in a separate thread\n        import threading\n        threading.Thread(\n            target=self._process_prompt,\n            args=(prompt, on_response),\n            daemon=True\n        ).start()\n        \n    def _process_prompt(self, prompt, callback):\n        \"\"\"\n        Process a prompt in a separate thread\n        \n        Args:\n            prompt: Prompt text\n            callback: Function to call with response\n        \"\"\"\n        # Send to chat engine\n        response = self.chat_engine.send_message(prompt)\n        \n        # Call callback on main thread\n        self.frame.after(0, lambda: callback(response))\n        \n    def update_timeline(self, prompt=None):\n        \"\"\"\n        Update the conversation timeline\n        \n        Args:\n            prompt: Optional new prompt to add\n        \"\"\"\n        # If a new prompt is provided, add it to the timeline\n        if prompt:\n            entry = f\"{time.strftime('%H:%M')} {prompt[:30]}{'...' if len(prompt) > 30 else ''}\"\n            self.timeline_listbox.insert(tk.END, entry)\n            \n            # Store the mapping\n            idx = self.timeline_listbox.size() - 1\n            self.timeline_map[idx] = prompt\n        else:\n            # Otherwise, update the entire timeline from chat history\n            self.timeline_listbox.delete(0, tk.END)\n            self.timeline_map = {}\n            \n            idx = 0\n            for message in self.chat_engine.chat_history:\n                if message.get(\"role\") == \"user\":\n                    content = message.get(\"content\", \"\")\n                    timestamp = message.get(\"timestamp\", \"\").split()[1].split(\":\")[:2]\n                    time_str = \":\".join(timestamp)\n                    \n                    entry = f\"{time_str} {content[:30]}{'...' if len(content) > 30 else ''}\"\n                    self.timeline_listbox.insert(tk.END, entry)\n                    \n                    # Store the mapping\n                    self.timeline_map[idx] = content\n                    idx += 1\n                    \n    def on_timeline_selected(self, event):\n        \"\"\"Handle timeline item selection\"\"\"\n        selection = event.widget.curselection()\n        if not selection:\n            return\n            \n        idx = selection[0]\n        if idx in self.timeline_map:\n            # Get the prompt\n            prompt = self.timeline_map[idx]\n            \n            # Insert into entry\n            self.prompt_entry.delete(0, tk.END)\n            self.prompt_entry.insert(0, prompt)\n            \n            # Focus on entry\n            self.prompt_entry.focus_set()\n            \n    def apply_filter(self, event=None):\n        \"\"\"Apply console filter\"\"\"\n        filter_type = self.filter_var.get()\n        \n        # Save current position\n        current_pos = self.console.yview()\n        \n        # Get all text with tags\n        text_data = []\n        for tag in [\"timestamp\", \"user\", \"user_message\", \"irintai\", \"irintai_message\", \"system\"]:\n            tag_ranges = self.console.tag_ranges(tag)\n            for i in range(0, len(tag_ranges), 2):\n                start = tag_ranges[i]\n                end = tag_ranges[i+1]\n                text = self.console.get(start, end)\n                text_data.append((tag, start, end, text))\n                \n        # Clear the console\n        self.console.delete(1.0, tk.END)\n        \n        # Reapply filtered content\n        for tag, start, end, text in text_data:\n            if filter_type == \"All\":\n                self.console.insert(tk.END, text, tag)\n            elif filter_type == \"User\" and (tag in [\"timestamp\", \"user\", \"user_message\"]):\n                self.console.insert(tk.END, text, tag)\n            elif filter_type == \"Irintai\" and (tag in [\"timestamp\", \"irintai\", \"irintai_message\"]):\n                self.console.insert(tk.END, text, tag)\n            elif filter_type == \"System\" and tag == \"system\":\n                self.console.insert(tk.END, text, tag)\n                \n        # Restore view position if not at the end\n        if current_pos[1] < 1.0:\n            self.console.yview_moveto(current_pos[0])\n        else:\n            self.console.see(tk.END)\n        \n        # Make console read-only again\n        self.console.config(state=tk.DISABLED)\n    \n    def clear_console(self):\n        \"\"\"Clear the console display\"\"\"\n        # Enable text insertion\n        self.console.config(state=tk.NORMAL)\n        \n        # Clear the console\n        self.console.delete(1.0, tk.END)\n        \n        # Make console read-only again\n        self.console.config(state=tk.DISABLED)\n        \n        self.log(\"[Chat] Console cleared\")\n        \n    def save_conversation(self):\n        \"\"\"Save the conversation to a file\"\"\"\n        from tkinter import filedialog\n        import datetime\n        \n        # Generate default filename\n        timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        default_filename = f\"irintai_conversation_{timestamp}.txt\"\n        \n        # Open save dialog\n        filename = filedialog.asksaveasfilename(\n            defaultextension=\".txt\",\n            filetypes=[(\"Text Files\", \"*.txt\"), (\"All Files\", \"*.*\")],\n            initialfile=default_filename\n        )\n        \n        if not filename:\n            return\n            \n        try:\n            # Get console content\n            content = self.console.get(1.0, tk.END)\n            \n            # Save to file\n            with open(filename, \"w\", encoding=\"utf-8\") as f:\n                f.write(f\"=== Irintai Conversation - {datetime.datetime.now()} ===\\n\\n\")\n                f.write(content)\n                \n            self.log(f\"[Conversation] Saved to {filename}\")\n        except Exception as e:\n            self.log(f\"[Error] Failed to save conversation: {e}\")\n            \n    def start_model(self):\n        \"\"\"Start the selected model\"\"\"\n        # Get the selected model from the chat engine\n        model_name = self.chat_engine.model_manager.current_model\n        \n        if not model_name:\n            # Find the first available model\n            for model, status in self.chat_engine.model_manager.model_statuses.items():\n                if status == \"Installed\":\n                    model_name = model\n                    break\n                    \n        if not model_name:\n            self.log(\"[Error] No model available to start\")\n            return\n            \n        # Start the model\n        def on_model_event(event_type, data):\n            if event_type == \"started\":\n                self.status_light.config(foreground=\"green\")\n            elif event_type == \"stopped\":\n                self.status_light.config(foreground=\"red\")\n            elif event_type == \"error\":\n                self.status_light.config(foreground=\"red\")\n                \n        success = self.chat_engine.model_manager.start_model(model_name, on_model_event)\n        \n        if success:\n            self.log(f\"[Model] Starting {model_name}\")\n            self.console.insert(\n                tk.END,\n                f\"[System] Starting model: {model_name}...\\n\\n\",\n                \"system\"\n            )\n            self.console.see(tk.END)\n            \n            # Make console read-only again\n            self.console.config(state=tk.DISABLED)\n        else:\n            self.log(f\"[Error] Failed to start model {model_name}\")\n            \n    def stop_model(self):\n        \"\"\"Stop the running model\"\"\"\n        success = self.chat_engine.model_manager.stop_model()\n        \n        if success:\n            self.status_light.config(foreground=\"red\")\n            self.log(\"[Model] Stopped\")\n            self.console.insert(\n                tk.END,\n                \"[System] Model stopped.\\n\\n\",\n                \"system\"\n            )\n            self.console.see(tk.END)\n            \n            # Make console read-only again\n            self.console.config(state=tk.DISABLED)\n        else:\n            self.log(\"[Error] Failed to stop model or no model running\")\n            \n    def set_model(self, model_name):\n        \"\"\"\n        Set the active model\n        \n        Args:\n            model_name: Name of the model to set\n        \"\"\"\n        # Update the model manager\n        self.chat_engine.model_manager.current_model = model_name\n        \n        # Check if the model is running\n        if (self.chat_engine.model_manager.model_process and \n            self.chat_engine.model_manager.model_process.poll() is None):\n            # Model is running, but it's a different model\n            if self.chat_engine.model_manager.current_model != model_name:\n                # Stop the current model\n                self.chat_engine.model_manager.stop_model()\n                \n                # Start the new model\n                self.start_model()\n        else:\n            # No model running, show notice\n            self.console.insert(\n                tk.END,\n                f\"[System] Model set to {model_name}. Click 'Start Model' to begin.\\n\\n\",\n                \"system\"\n            )\n            self.console.see(tk.END)\n        \n        # Make console read-only again\n        self.console.config(state=tk.DISABLED)\n\n    # Extension point system for the chat panel    \n    \n    def initialize_plugin_hooks(self):\n        \"\"\"Initialize plugin extension points\"\"\"\n        # Dictionary of registered UI hooks by plugin ID\n        self.plugin_ui_extensions = {}\n\n        # Get the chat frame (original parent of labeled frame containing console)\n        chat_frame = self.console.master.master.master  # Go up to the right level\n        \n        # Store reference to existing widgets for later cleanup\n        self.original_chat_widgets = chat_frame.winfo_children()\n        \n        # Original parent of the console for reference  \n        self.original_console_parent = self.console.master\n        \n        # Instead of modifying the existing hierarchy, create new frames\n        # that will be displayed alongside the existing ones\n        \n        # Create extension frames\n        self.extension_frames = {\n            \"top_bar\": ttk.Frame(self.frame),\n            \"side_panel\": ttk.Frame(self.frame),\n            \"bottom_bar\": ttk.Frame(self.frame),\n            \"floating\": None\n        }\n        \n        # Place extension frames in appropriate positions relative to console\n        self.extension_frames[\"top_bar\"].pack(in_=self.frame, fill=tk.X, side=tk.TOP, padx=5, pady=5)\n        self.extension_frames[\"side_panel\"].pack(in_=self.frame, fill=tk.Y, side=tk.RIGHT, padx=5, pady=5)\n        self.extension_frames[\"bottom_bar\"].pack(in_=self.frame, fill=tk.X, side=tk.BOTTOM, padx=5, pady=5)        # Create extension frames\n        self.extension_frames = {\n            \"top_bar\": ttk.Frame(self.frame),\n            \"side_panel\": ttk.Frame(self.frame),\n            \"bottom_bar\": ttk.Frame(self.frame),\n            \"floating\": None\n        }\n        \n        # Add extension frames to appropriate places\n        self.extension_frames[\"top_bar\"].pack(in_=self.frame, fill=tk.X, side=tk.TOP, padx=5, pady=5)\n        self.extension_frames[\"side_panel\"].pack(in_=self.frame, fill=tk.Y, side=tk.RIGHT, padx=5, pady=5)\n        self.extension_frames[\"bottom_bar\"].pack(in_=self.frame, fill=tk.X, side=tk.BOTTOM, padx=5, pady=5)\n\n        # Register notification methods for plugins\n        self.register_plugin_callbacks()\n\n    def register_plugin_callbacks(self):\n        \"\"\"Register plugin notification callbacks with the plugin manager\"\"\"\n        if not hasattr(self.parent, \"plugin_manager\"):\n            self.log(\"[Chat Panel] Plugin manager not available\")\n            return\n            \n        plugin_manager = self.parent.plugin_manager\n        \n        # Register for plugin lifecycle events\n        plugin_manager.register_event_handler(\"chat_panel\", \"plugin_activated\", \n                                             self.on_plugin_activated)\n        plugin_manager.register_event_handler(\"chat_panel\", \"plugin_deactivated\", \n                                             self.on_plugin_deactivated)\n        plugin_manager.register_event_handler(\"chat_panel\", \"plugin_unloaded\", \n                                             self.on_plugin_unloaded)\n\n    def on_plugin_activated(self, plugin_id, plugin_instance):\n        \"\"\"\n        Handle plugin activation event\n        \n        Args:\n            plugin_id: ID of the activated plugin\n            plugin_instance: Instance of the plugin\n        \"\"\"\n        # Check if plugin has UI integration capability\n        if hasattr(plugin_instance, \"get_chat_ui_extension\"):\n            self.log(f\"[Chat Panel] Plugin {plugin_id} has UI integration\")\n            \n            try:\n                # Get extension specification from plugin\n                extension = plugin_instance.get_chat_ui_extension(self)\n                \n                if extension and isinstance(extension, dict):\n                    # Store extension\n                    self.plugin_ui_extensions[plugin_id] = extension\n                    \n                    # Process UI components\n                    self.integrate_plugin_ui(plugin_id, extension)\n            except Exception as e:\n                self.log(f\"[Chat Panel] Error integrating plugin {plugin_id}: {e}\")\n\n    def on_plugin_deactivated(self, plugin_id):\n        \"\"\"\n        Handle plugin deactivation event\n        \n        Args:\n            plugin_id: ID of the deactivated plugin\n        \"\"\"\n        # Remove plugin UI if present\n        if plugin_id in self.plugin_ui_extensions:\n            self.remove_plugin_ui(plugin_id)\n\n    def on_plugin_unloaded(self, plugin_id):\n        \"\"\"\n        Handle plugin unloading event\n        \n        Args:\n            plugin_id: ID of the unloaded plugin\n        \"\"\"\n        # Ensure plugin UI is fully removed\n        if plugin_id in self.plugin_ui_extensions:\n            self.remove_plugin_ui(plugin_id)\n            del self.plugin_ui_extensions[plugin_id]    \n    \n    def integrate_plugin_ui(self, plugin_id, extension):\n        \"\"\"\n        Integrate a plugin's UI components\n        \n        Args:\n            plugin_id: ID of the plugin\n            extension: UI extension specification\n        \"\"\"\n        # Process each extension location\n        for location, components in extension.items():\n            if location not in self.extension_frames:\n                self.log(f\"[Chat Panel] Unknown extension location: {location}\")\n                continue\n                \n            # Get the container frame\n            container = self.extension_frames[location]\n            \n            # For floating windows, create a new toplevel if needed\n            if location == \"floating\" and components:\n                container = tk.Toplevel(self.frame)\n                container.title(f\"{plugin_id.capitalize()} Plugin\")\n                container.protocol(\"WM_DELETE_WINDOW\", lambda: self.hide_floating_window(plugin_id))\n                container.withdraw()  # Initially hidden\n                self.extension_frames[\"floating\"] = container\n                \n            # Create a frame specific to this plugin\n            plugin_frame = ttk.LabelFrame(container, text=extension.get(\"title\", plugin_id.capitalize()))\n            plugin_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n            \n            # Store the frame reference\n            extension[\"frame\"] = plugin_frame\n            \n            # Add components if any were specified\n            if isinstance(components, list):\n                for component in components:\n                    if hasattr(component, \"pack\") and component.master == plugin_frame:\n                        # Only pack if the component was created with plugin_frame as parent\n                        component.pack(fill=tk.BOTH, expand=True)\n                    elif hasattr(component, \"pack\"):\n                        # For components created with a different parent, recreate them\n                        self.log(f\"[Chat Panel] Component has incorrect parent for {plugin_id}. Skipping.\")\n                          # Show the container if it was hidden\n            if location == \"side_panel\":\n                # Ensure side panel is visible\n                self.extension_frames[\"side_panel\"].pack(fill=tk.Y, side=tk.RIGHT, padx=5, pady=5)\n\n    def remove_plugin_ui(self, plugin_id):\n        \"\"\"\n        Remove a plugin's UI components\n        \n        Args:\n            plugin_id: ID of the plugin\n        \"\"\"\n        extension = self.plugin_ui_extensions.get(plugin_id)\n        if not extension:\n            return\n            \n        # Get the plugin frame\n        plugin_frame = extension.get(\"frame\")\n        if plugin_frame and plugin_frame.winfo_exists():\n            plugin_frame.destroy()\n            \n        # If this was a floating window, destroy it\n        if extension.get(\"location\") == \"floating\" and self.extension_frames[\"floating\"]:\n            floating_window = self.extension_frames[\"floating\"]\n            if floating_window.winfo_exists():\n                floating_window.destroy()\n                self.extension_frames[\"floating\"] = None\n\n    def show_floating_window(self, plugin_id):\n        \"\"\"\n        Show a plugin's floating window\n        \n        Args:\n            plugin_id: ID of the plugin\n        \"\"\"\n        extension = self.plugin_ui_extensions.get(plugin_id)\n        if not extension or extension.get(\"location\") != \"floating\":\n            return\n            \n        # Get the window\n        window = self.extension_frames[\"floating\"]\n        if window and window.winfo_exists():\n            # Position near the main window\n            window.geometry(f\"+{self.frame.winfo_rootx() + 50}+{self.frame.winfo_rooty() + 50}\")\n            window.deiconify()\n            window.lift()\n\n    def hide_floating_window(self, plugin_id):\n        \"\"\"\n        Hide a plugin's floating window\n        \n        Args:\n            plugin_id: ID of the plugin\n        \"\"\"\n        extension = self.plugin_ui_extensions.get(plugin_id)\n        if not extension or extension.get(\"location\") != \"floating\":\n            return\n            \n        # Get the window\n        window = self.extension_frames[\"floating\"]\n        if window and window.winfo_exists():\n            window.withdraw()\n\n    # Messages API for plugins to interact with the chat\n    def register_message_hook(self, plugin_id, hook_function):\n        \"\"\"\n        Register a plugin hook for message processing\n        \n        Args:\n            plugin_id: ID of the plugin\n            hook_function: Function to call for message processing\n            \n        Returns:\n            Success flag\n        \"\"\"\n        if not hasattr(self, \"message_hooks\"):\n            self.message_hooks = {}\n            \n        self.message_hooks[plugin_id] = hook_function\n        self.log(f\"[Chat Panel] Registered message hook for plugin {plugin_id}\")\n        return True\n        \n    def unregister_message_hook(self, plugin_id):\n        \"\"\"\n        Unregister a plugin message hook\n        \n        Args:\n            plugin_id: ID of the plugin\n            \n        Returns:\n            Success flag\n        \"\"\"\n        if hasattr(self, \"message_hooks\") and plugin_id in self.message_hooks:\n            del self.message_hooks[plugin_id]\n            self.log(f\"[Chat Panel] Unregistered message hook for plugin {plugin_id}\")\n            return True\n        return False\n        \n    def process_message_hooks(self, message, role):\n        \"\"\"\n        Process message hooks from plugins\n        \n        Args:\n            message: Message content\n            role: Message role (user/assistant)\n            \n        Returns:\n            Possibly modified message\n        \"\"\"\n        if not hasattr(self, \"message_hooks\") or not self.message_hooks:\n            return message\n            \n        modified_message = message\n        \n        # Apply each hook in registration order\n        for plugin_id, hook_function in self.message_hooks.items():\n            try:\n                result = hook_function(modified_message, role)\n                if result is not None:\n                    modified_message = result\n            except Exception as e:\n                self.log(f\"[Chat Panel] Error in message hook for plugin {plugin_id}: {e}\")\n        \n        return modified_message",
  "D:\\AI\\IrintAI Assistant\\ui\\panels\\model_panel.py": "\"\"\"\nModel panel UI component for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport threading\nfrom typing import Callable, Dict, List, Any, Optional\nimport queue\nimport re\n\n\n# Import model status constants\nfrom core.model_manager import MODEL_STATUS, RECOMMENDED_MODELS\n\nclass ModelPanel:\n    \"\"\"Model management panel for installing and managing AI models\"\"\"\n    \n    def __init__(self, parent, model_manager, logger: Callable, on_model_selected: Callable):\n        \"\"\"\n        Initialize the model panel\n        \n        Args:\n            parent: Parent widget\n            model_manager: ModelManager instance\n            logger: Logging function\n            on_model_selected: Callback for model selection\n        \"\"\"\n        self.parent = parent\n        self.model_manager = model_manager\n        self.log = logger\n        self.on_model_selected_callback = on_model_selected\n        \n        # Model categories\n        self.model_categories = {\n            \"Conversation\": [\"llama3:8b\", \"mistral:7b-instruct\", \"openchat:3.5\"],\n            \"Roleplay\": [\"mythomax\", \"nous-hermes:13b\", \"airoboros-l2\"],\n            \"Coding\": [\"codellama:7b-instruct\", \"deepseek-coder\", \"wizardcoder:15b\"],\n            \"Reason\": [\"gemma:7b-instruct\", \"phi-2\", \"zephyr:beta\"]\n        }\n        \n        # Create the main frame\n        self.frame = ttk.Frame(parent)\n        \n        # Create thread-safe queue for UI updates\n        self.update_queue = queue.Queue()\n        # Start queue processor\n        self.process_queue()\n\n        # Initialize UI components\n        self.initialize_ui()\n        \n        # Fetch models\n        self.refresh_model_list()\n    \n    def initialize_ui(self):\n        \"\"\"Initialize the UI components\"\"\"        \n        # Create notebook for tabbed interface\n        self.notebook = ttk.Notebook(self.frame)\n        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create Local Models tab\n        self.local_models_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.local_models_frame, text=\"Local Models\")\n        \n        # Create API Models tab\n        self.api_models_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.api_models_frame, text=\"API Models\")\n        \n        # Create Model Settings tab\n        self.settings_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.settings_frame, text=\"Model Settings\")\n          \n        # Setup local models tab (existing functionality)\n        self.setup_local_models_tab()\n        \n        # Setup API models tab (new functionality)\n        self.setup_api_models_tab()\n        \n        # Setup Model Settings tab\n        self.setup_settings_tab()\n        \n        # Create progress bar\n        self.create_progress_bar()\n        \n        # Initialize plugin extensions\n        self.initialize_plugin_extensions()\n          \n    def setup_local_models_tab(self):\n        \"\"\"Setup the local models tab with existing functionality\"\"\"\n        # Create the various panel sections in the local models tab\n        \n        # Use common parent for all sections\n        parent_frame = self.local_models_frame\n        \n        # Create model selection section\n        self.create_model_selection(parent=parent_frame)\n        \n        # Create model management section\n        self.create_model_management(parent=parent_frame)\n        \n        # Create model information section\n        self.create_model_info(parent=parent_frame)\n\n    def initialize_plugin_extensions(self):\n        \"\"\"Initialize plugin extensions for the model panel\"\"\"\n        # Dictionaries for plugin extensions\n        self.plugin_model_providers = {}  # Custom model providers\n        self.plugin_model_configs = {}    # Custom model configurations\n        self.plugin_ui_extensions = {}    # UI extensions\n        self.plugin_actions = {}          # Custom model actions\n        \n        # Create plugin extension frames\n        self.plugin_frame = ttk.LabelFrame(self.frame, text=\"Plugin Extensions\")\n        \n        # Add plugin action menu\n        self.create_plugin_action_menu()\n        \n        # Register with plugin manager if available\n        if hasattr(self.parent, \"plugin_manager\"):\n            plugin_manager = self.parent.plugin_manager\n            \n            # Register for plugin events\n            plugin_manager.register_event_handler(\"model_panel\", \"plugin_activated\", \n                                                 self.on_plugin_activated)\n            plugin_manager.register_event_handler(\"model_panel\", \"plugin_deactivated\", \n                                                 self.on_plugin_deactivated)\n            plugin_manager.register_event_handler(\"model_panel\", \"plugin_unloaded\", \n                                                 self.on_plugin_unloaded)\n            \n            # Get all active plugins and register their extensions\n            active_plugins = plugin_manager.get_active_plugins()\n            for plugin_id, plugin in active_plugins.items():\n                self.register_plugin_extension(plugin_id, plugin)\n    \n    def create_model_selection(self, parent=None):\n        \"\"\"Create the model selection section\"\"\"\n        # Use provided parent or default to self.frame\n        parent_frame = parent if parent else self.frame\n        selection_frame = ttk.LabelFrame(parent_frame, text=\"Model Selection\")\n        selection_frame.pack(fill=tk.X, padx=10, pady=10, anchor=tk.N)\n        \n        # Create model filter section\n        filter_frame = ttk.Frame(selection_frame)\n        filter_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(filter_frame, text=\"Filter by Category:\").pack(side=tk.LEFT)\n        \n        # Category dropdown\n        self.category_var = tk.StringVar(value=\"All\")\n        self.category_dropdown = ttk.Combobox(\n            filter_frame,\n            textvariable=self.category_var,\n            values=[\"All\"] + list(self.model_categories.keys()),\n            state=\"readonly\",\n            width=15\n        )\n        self.category_dropdown.pack(side=tk.LEFT, padx=5)\n        self.category_dropdown.bind(\"<<ComboboxSelected>>\", self.on_category_selected)\n        \n        # Search entry\n        ttk.Label(filter_frame, text=\"Search:\").pack(side=tk.LEFT, padx=(20, 5))\n        self.search_var = tk.StringVar()\n        search_entry = ttk.Entry(filter_frame, textvariable=self.search_var, width=20)\n        search_entry.pack(side=tk.LEFT, padx=5)\n        search_entry.bind(\"<KeyRelease>\", self.on_search_changed)\n        \n        # Main model selection section\n        model_frame = ttk.Frame(selection_frame)\n        model_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Create a list view with multiple columns\n        columns = (\"Name\", \"Size\", \"Status\", \"Context\")\n        self.model_tree = ttk.Treeview(\n            model_frame,\n            columns=columns,\n            show=\"headings\",\n            selectmode=\"browse\",\n            height=10\n        )\n        \n        # Configure columns\n        self.model_tree.heading(\"Name\", text=\"Model Name\")\n        self.model_tree.heading(\"Size\", text=\"Size\")\n        self.model_tree.heading(\"Status\", text=\"Status\")\n        self.model_tree.heading(\"Context\", text=\"Context\")\n        \n        self.model_tree.column(\"Name\", width=200, anchor=tk.W)\n        self.model_tree.column(\"Size\", width=80, anchor=tk.CENTER)\n        self.model_tree.column(\"Status\", width=100, anchor=tk.CENTER)\n        self.model_tree.column(\"Context\", width=100, anchor=tk.CENTER)\n        \n        # Add scrollbar\n        scrollbar = ttk.Scrollbar(model_frame, orient=\"vertical\", command=self.model_tree.yview)\n        self.model_tree.configure(yscrollcommand=scrollbar.set)\n        \n        # Pack the tree and scrollbar\n        self.model_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        # Bind selection event\n        self.model_tree.bind(\"<<TreeviewSelect>>\", self.on_model_selected)\n        \n        # Buttons below the tree\n        button_frame = ttk.Frame(selection_frame)\n        button_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Refresh Model List\",\n            command=self.refresh_model_list\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Select Model\",\n            command=self.select_current_model,\n            style=\"Accent.TButton\"\n        ).pack(side=tk.RIGHT, padx=5)    \n        \n    def create_model_management(self, parent=None):\n        \"\"\"Create the model management section\"\"\"\n\n        # Use provided parent or default to self.frame\n        parent_frame = parent if parent else self.frame\n        mgmt_frame = ttk.LabelFrame(parent_frame, text=\"Model Management\")\n        mgmt_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Actions section\n        actions_frame = ttk.Frame(mgmt_frame)\n        actions_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Install button\n        self.install_button = ttk.Button(\n            actions_frame,\n            text=\"Install Selected Model\",\n            command=self.install_selected_model\n        )\n        self.install_button.pack(side=tk.LEFT, padx=5)\n        \n        # Uninstall button\n        self.uninstall_button = ttk.Button(\n            actions_frame,\n            text=\"Uninstall Selected Model\",\n            command=self.uninstall_selected_model\n        )\n        self.uninstall_button.pack(side=tk.LEFT, padx=5)\n        \n        # Start/Stop buttons\n        self.start_button = ttk.Button(\n            actions_frame,\n            text=\"Start Selected Model\",\n            command=self.start_selected_model\n        )\n        self.start_button.pack(side=tk.LEFT, padx=5)\n        \n        self.stop_button = ttk.Button(\n            actions_frame,\n            text=\"Stop Running Model\",\n            command=self.stop_running_model\n        )\n        self.stop_button.pack(side=tk.LEFT, padx=5)\n        \n        # Path info section\n        path_frame = ttk.Frame(mgmt_frame)\n        path_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(path_frame, text=\"Model Path:\").pack(side=tk.LEFT)\n        \n        self.path_var = tk.StringVar(value=self.model_manager.model_path)\n        path_label = ttk.Label(path_frame, textvariable=self.path_var, foreground=\"blue\")\n        path_label.pack(side=tk.LEFT, padx=5)\n        \n        # Open folder button\n        ttk.Button(\n            path_frame,\n            text=\"Open Folder\",\n            command=self.open_model_folder\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        # Create menu for plugin-provided model actions\n        self.create_plugin_action_menu()\n        \n    def create_plugin_action_menu(self):\n        \"\"\"Create menu for plugin-provided model actions\"\"\"\n        # Find appropriate frame to add menu\n        actions_frame = None\n        for child in self.frame.winfo_children():\n            if isinstance(child, ttk.LabelFrame) and child.cget(\"text\") == \"Model Management\":\n                # Get the first child frame which should be the actions frame\n                actions_frame = child.winfo_children()[0]\n                break\n                \n        if not actions_frame:\n            return\n            \n        # Create a menubutton for plugin actions\n        self.plugin_action_button = ttk.Menubutton(\n            actions_frame,\n            text=\"Plugin Actions\",\n            direction=\"below\"\n        )\n        self.plugin_action_button.pack(side=tk.RIGHT, padx=5)\n        \n        # Create the dropdown menu\n        self.plugin_action_menu = tk.Menu(self.plugin_action_button, tearoff=0)\n        self.plugin_action_button[\"menu\"] = self.plugin_action_menu\n        \n        # Add placeholder when empty\n        self.plugin_action_menu.add_command(\n            label=\"No plugin actions available\",\n            state=tk.DISABLED\n        )\n    \n    def create_model_info(self, parent=None):\n        \"\"\"Create the model information section\"\"\"\n        # Use provided parent or default to self.frame\n        parent_frame = parent if parent else self.frame\n        info_frame = ttk.LabelFrame(parent_frame, text=\"Model Information\")\n        info_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Model details\n        details_frame = ttk.Frame(info_frame)\n        details_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Two-column layout for details\n        left_frame = ttk.Frame(details_frame)\n        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        right_frame = ttk.Frame(details_frame)\n        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)\n        \n        # Left column - Basic info\n        ttk.Label(left_frame, text=\"Selected Model:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)\n        self.selected_name_var = tk.StringVar(value=\"None\")\n        ttk.Label(left_frame, textvariable=self.selected_name_var, font=(\"Helvetica\", 10, \"bold\")).grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(left_frame, text=\"Status:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)\n        self.selected_status_var = tk.StringVar(value=\"None\")\n        ttk.Label(left_frame, textvariable=self.selected_status_var).grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(left_frame, text=\"Size:\").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)\n        self.selected_size_var = tk.StringVar(value=\"Unknown\")\n        ttk.Label(left_frame, textvariable=self.selected_size_var).grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        # Right column - Additional info\n        ttk.Label(right_frame, text=\"Context Length:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)\n        self.selected_context_var = tk.StringVar(value=\"Unknown\")\n        ttk.Label(right_frame, textvariable=self.selected_context_var).grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(right_frame, text=\"Category:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)\n        self.selected_category_var = tk.StringVar(value=\"Unknown\")\n        ttk.Label(right_frame, textvariable=self.selected_category_var).grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(right_frame, text=\"8-bit Mode:\").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)\n        self.selected_8bit_var = tk.StringVar(value=\"Not Recommended\")\n        ttk.Label(right_frame, textvariable=self.selected_8bit_var).grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        # Description section\n        ttk.Label(info_frame, text=\"Description:\").pack(anchor=tk.W, padx=10, pady=(10, 0))\n        \n        self.description_text = tk.Text(info_frame, height=4, wrap=tk.WORD, font=(\"Helvetica\", 9))\n        self.description_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n        self.description_text.config(state=tk.DISABLED)\n        \n    def create_progress_bar(self):\n        \"\"\"Create the progress bar\"\"\"\n        progress_frame = ttk.Frame(self.frame)\n        progress_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        # Progress bar\n        self.progress_var = tk.DoubleVar(value=0.0)\n        self.progress_mode = tk.StringVar(value=\"determinate\")\n        \n        self.progress_bar = ttk.Progressbar(\n            progress_frame,\n            variable=self.progress_var,\n            mode=self.progress_mode.get(),\n            length=100\n        )\n        self.progress_bar.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Status text\n        self.status_var = tk.StringVar(value=\"Ready\")\n        status_label = ttk.Label(progress_frame, textvariable=self.status_var)\n        status_label.pack(anchor=tk.W, padx=5)\n        \n    def refresh_model_list(self):\n        \"\"\"Refresh the model list\"\"\"\n        # Clear the current tree\n        for item in self.model_tree.get_children():\n            self.model_tree.delete(item)\n            \n        # Show progress\n        self.progress_mode.set(\"indeterminate\")\n        self.progress_bar.config(mode=\"indeterminate\")\n        self.progress_bar.start()\n        self.status_var.set(\"Fetching models...\")\n        \n        # Start a thread to fetch models\n        threading.Thread(\n            target=self._fetch_models_thread,\n            daemon=True\n        ).start()\n        \n    def _fetch_models_thread(self):\n        \"\"\"Fetch models in a background thread\"\"\"\n        try:\n            # Get locally installed models\n            installed_models = self.model_manager.detect_models()\n            \n            # Fetch remote models\n            all_models = self.model_manager.fetch_available_models()\n            \n            # Add plugin-provided models\n            plugin_models = self._get_plugin_models()\n            \n            # Merge lists, prioritizing plugin models if there are duplicates\n            if plugin_models:\n                # Create a dictionary with model name as key\n                model_dict = {model[\"name\"]: model for model in all_models}\n                \n                # Update or add plugin models\n                for model in plugin_models:\n                    model_dict[model[\"name\"]] = model\n                    \n                # Convert back to list\n                all_models = list(model_dict.values())\n            \n            # Queue UI update instead of direct call\n            self.update_queue.put((self._update_model_tree, [all_models], {}))\n        except Exception as e:\n            self.log(f\"[Error] Failed to fetch models: {e}\")\n            self.update_queue.put((self.status_var.set, [f\"Error: {str(e)}\"], {}))\n        finally:\n            # Queue progress bar reset\n            self.update_queue.put((self._reset_progress_bar, [], {}))\n            \n    def _get_plugin_models(self):\n        \"\"\"\n        Get models from plugin providers\n        \n        Returns:\n            List of model dictionaries\n        \"\"\"\n        plugin_models = []\n        \n        # Skip if no providers\n        if not hasattr(self, \"plugin_model_providers\"):\n            return plugin_models\n            \n        # Call each provider\n        for provider_id, provider_func in self.plugin_model_providers.items():\n            try:\n                # Get models from this provider\n                models = provider_func()\n                \n                if models and isinstance(models, list):\n                    # Add provider info to each model\n                    for model in models:\n                        if isinstance(model, dict) and \"name\" in model:\n                            # Add provider ID\n                            model[\"provider\"] = provider_id\n                            plugin_models.append(model)\n            except Exception as e:\n                self.log(f\"[Error] Plugin model provider {provider_id} failed: {e}\")\n                \n        return plugin_models\n\n    def _update_model_tree(self, models_list):\n        \"\"\"\n        Update the model tree with fetched models\n        \n        Args:\n            models_list: List of model dictionaries\n        \"\"\"\n        # Clear the current tree\n        for item in self.model_tree.get_children():\n            self.model_tree.delete(item)\n            \n        # Add models to the tree\n        for model in models_list:\n            name = model[\"name\"]\n            size = model[\"size\"] if \"size\" in model else \"Unknown\"\n            installed = model.get(\"installed\", False)\n            \n            # Get status\n            status = self.model_manager.model_statuses.get(name, MODEL_STATUS[\"NOT_INSTALLED\"])\n            \n            # Get additional info for recommended models\n            context = \"Unknown\"\n            if name in RECOMMENDED_MODELS:\n                context = RECOMMENDED_MODELS[name][\"context\"]\n                \n            # Add to tree\n            self.model_tree.insert(\n                \"\", \n                tk.END, \n                values=(name, size, status, context),\n                tags=(\"installed\" if installed else \"available\",)\n            )\n            \n        # Configure tag appearance\n        self.model_tree.tag_configure(\"installed\", background=\"#e6f3ff\")\n        \n        # Select the first item if available\n        if self.model_tree.get_children():\n            first_item = self.model_tree.get_children()[0]\n            self.model_tree.selection_set(first_item)\n            self.on_model_selected()\n            \n        # Update status\n        self.status_var.set(f\"Found {len(models_list)} models\")\n        \n    def _reset_progress_bar(self):\n        \"\"\"Reset the progress bar\"\"\"\n        self.progress_bar.stop()\n        self.progress_mode.set(\"determinate\")\n        self.progress_bar.config(mode=\"determinate\")\n        self.progress_var.set(0)\n        \n    def on_category_selected(self, event):\n        \"\"\"Handle category selection\"\"\"\n        category = self.category_var.get()\n        self._filter_models()\n        \n    def on_search_changed(self, event):\n        \"\"\"Handle search text changes\"\"\"\n        self._filter_models()\n        \n    def _filter_models(self):\n        \"\"\"Filter models based on category and search text\"\"\"\n        category = self.category_var.get()\n        search_text = self.search_var.get().lower()\n        \n        # Get all items\n        all_items = self.model_tree.get_children()\n        \n        # Show all items first\n        for item in all_items:\n            self.model_tree.item(item, tags=self.model_tree.item(item, \"tags\"))\n            \n        # Filter by category\n        if category != \"All\":\n            category_models = self.model_categories.get(category, [])\n            for item in all_items:\n                values = self.model_tree.item(item, \"values\")\n                model_name = values[0]\n                \n                if model_name not in category_models:\n                    self.model_tree.detach(item)\n                    \n        # Filter by search text\n        if search_text:\n            # Get current items (after category filter)\n            current_items = self.model_tree.get_children()\n            \n            for item in current_items:\n                values = self.model_tree.item(item, \"values\")\n                model_name = values[0].lower()\n                \n                if search_text not in model_name:\n                    self.model_tree.detach(item)\n                    \n        # Reattach all items that match both filters\n        for item in all_items:\n            values = self.model_tree.item(item, \"values\")\n            model_name = values[0]\n            \n            # Check category\n            category_match = (category == \"All\") or (model_name in self.model_categories.get(category, []))\n            \n            # Check search\n            search_match = (not search_text) or (search_text in model_name.lower())\n            \n            if category_match and search_match:\n                try:\n                    # Try to reattach if detached\n                    self.model_tree.move(item, \"\", tk.END)\n                except:\n                    pass\n                    \n    def on_model_selected(self, event=None):\n        \"\"\"Handle model selection in the tree\"\"\"\n        selection = self.model_tree.selection()\n        if not selection:\n            return\n            \n        # Get model info\n        item = selection[0]\n        values = self.model_tree.item(item, \"values\")\n        \n        model_name = values[0]\n        model_size = values[1]\n        model_status = values[2]\n        model_context = values[3]\n        \n        # Update selected model info\n        self.selected_name_var.set(model_name)\n        self.selected_status_var.set(model_status)\n        self.selected_size_var.set(model_size)\n        self.selected_context_var.set(model_context)\n        \n        # Find category\n        category = \"Unknown\"\n        for cat, models in self.model_categories.items():\n            if model_name in models:\n                category = cat\n                break\n                \n        self.selected_category_var.set(category)\n        \n        # Check if 8-bit mode is recommended\n        needs_8bit = \"13b\" in model_name or \"70b\" in model_name\n        self.selected_8bit_var.set(\"Recommended\" if needs_8bit else \"Not Needed\")\n        \n        # Update description\n        self.description_text.config(state=tk.NORMAL)\n        self.description_text.delete(1.0, tk.END)\n        \n        if model_name in RECOMMENDED_MODELS:\n            description = RECOMMENDED_MODELS[model_name][\"note\"]\n            if needs_8bit:\n                description += \"\\nThis model requires 8-bit mode for optimal performance.\"\n                \n            self.description_text.insert(tk.END, description)\n        else:\n            self.description_text.insert(tk.END, \"No detailed information available for this model.\")\n            \n        self.description_text.config(state=tk.DISABLED)\n        \n        # Update button states\n        if model_status == MODEL_STATUS[\"INSTALLED\"]:\n            self.install_button.config(state=tk.DISABLED)\n            self.uninstall_button.config(state=tk.NORMAL)\n            self.start_button.config(state=tk.NORMAL)\n        elif model_status == MODEL_STATUS[\"NOT_INSTALLED\"]:\n            self.install_button.config(state=tk.NORMAL)\n            self.uninstall_button.config(state=tk.DISABLED)\n            self.start_button.config(state=tk.DISABLED)\n        elif model_status == MODEL_STATUS[\"RUNNING\"]:\n            self.install_button.config(state=tk.DISABLED)\n            self.uninstall_button.config(state=tk.DISABLED)\n            self.start_button.config(state=tk.DISABLED)\n            self.stop_button.config(state=tk.NORMAL)\n        else:\n            # Installing, uninstalling, etc.\n            self.install_button.config(state=tk.DISABLED)\n            self.uninstall_button.config(state=tk.DISABLED)\n            self.start_button.config(state=tk.DISABLED)\n            \n    def select_current_model(self):\n        \"\"\"Select the current model for use\"\"\"\n        selection = self.model_tree.selection()\n        if not selection:\n            return\n            \n        # Get model name\n        item = selection[0]\n        values = self.model_tree.item(item, \"values\")\n        model_name = values[0]\n        \n        # Update the model manager\n        self.model_manager.current_model = model_name\n        \n        # Call the callback\n        if self.on_model_selected_callback:\n            self.on_model_selected_callback(model_name)\n            \n        # Update status\n        self.status_var.set(f\"Selected model: {model_name}\")\n        \n    def install_selected_model(self):\n        \"\"\"Install the selected model\"\"\"\n        selection = self.model_tree.selection()\n        if not selection:\n            return\n            \n        # Get model name\n        item = selection[0]\n        values = self.model_tree.item(item, \"values\")\n        model_name = values[0]\n        \n        # Check if already installed\n        status = self.model_manager.model_statuses.get(model_name, MODEL_STATUS[\"NOT_INSTALLED\"])\n        if status == MODEL_STATUS[\"INSTALLED\"]:\n            messagebox.showinfo(\"Already Installed\", f\"Model '{model_name}' is already installed\")\n            return\n            \n        # Confirm installation\n        result = messagebox.askyesno(\n            \"Confirm Installation\", \n            f\"Do you want to install model '{model_name}'?\\n\\n\"\n            f\"This may require significant disk space.\",\n            icon=messagebox.WARNING\n        )\n        \n        if not result:\n            return\n            \n        # Update progress bar and status\n        self.progress_mode.set(\"indeterminate\")\n        self.progress_bar.config(mode=\"indeterminate\")\n        self.progress_bar.start()\n        self.status_var.set(f\"Installing {model_name}...\")\n        \n        # Install the model\n        self.model_manager.install_model(model_name, self._update_progress)\n        \n        # Update tree item\n        self.model_tree.item(\n            item, \n            values=(model_name, values[1], MODEL_STATUS[\"INSTALLING\"], values[3])\n        )\n        \n        # Disable buttons during installation\n        self.install_button.config(state=tk.DISABLED)\n        self.uninstall_button.config(state=tk.DISABLED)\n        self.start_button.config(state=tk.DISABLED)\n        \n    def uninstall_selected_model(self):\n        \"\"\"Uninstall the selected model\"\"\"\n        selection = self.model_tree.selection()\n        if not selection:\n            return\n            \n        # Get model name\n        item = selection[0]\n        values = self.model_tree.item(item, \"values\")\n        model_name = values[0]\n        \n        # Check if installed\n        status = self.model_manager.model_statuses.get(model_name, MODEL_STATUS[\"NOT_INSTALLED\"])\n        if status == MODEL_STATUS[\"NOT_INSTALLED\"]:\n            messagebox.showinfo(\"Not Installed\", f\"Model '{model_name}' is not installed\")\n            return\n            \n        # Check if model is running\n        if self.model_manager.model_process and self.model_manager.model_process.poll() is None:\n            # Ask to stop the model first\n            result = messagebox.askyesno(\n                \"Model Running\", \n                f\"Model '{model_name}' is currently running. Stop it before uninstalling?\",\n                icon=messagebox.WARNING\n            )\n            \n            if result:\n                self.model_manager.stop_model()\n            else:\n                return\n                \n        # Confirm uninstallation\n        result = messagebox.askyesno(\n            \"Confirm Uninstallation\", \n            f\"Do you want to uninstall model '{model_name}'?\\n\\n\"\n            f\"This will free up disk space but you will need to download it again if needed.\",\n            icon=messagebox.WARNING\n        )\n        \n        if not result:\n            return\n            \n        # Update progress bar and status\n        self.progress_mode.set(\"indeterminate\")\n        self.progress_bar.config(mode=\"indeterminate\")\n        self.progress_bar.start()\n        self.status_var.set(f\"Uninstalling {model_name}...\")\n        \n        # Uninstall the model\n        self.model_manager.uninstall_model(model_name)\n        \n        # Update tree item\n        self.model_tree.item(\n            item, \n            values=(model_name, values[1], MODEL_STATUS[\"UNINSTALLING\"], values[3])\n        )\n        \n        # Disable buttons during uninstallation\n        self.install_button.config(state=tk.DISABLED)\n        self.uninstall_button.config(state=tk.DISABLED)\n        self.start_button.config(state=tk.DISABLED)\n        \n    def get_model_config(self, model_name):\n        \"\"\"\n        Get model configuration including any plugin customizations\n        \n        Args:\n            model_name: Name of the model\n            \n        Returns:\n            Dictionary with model configuration\n        \"\"\"\n        # Start with default configuration\n        config = self.model_manager.get_model_config(model_name)\n        if config is None:\n            config = {}\n        \n        # Apply plugin configurations if any\n        if hasattr(self, \"plugin_model_configs\"):\n            # Find specific configurations for this model\n            for config_id, config_func in self.plugin_model_configs.items():\n                try:\n                    # Check if this config applies to this model\n                    model_part = config_id.split(\".\", 1)[1]  # Get part after plugin ID\n                    if model_part == \"*\" or model_part == model_name:\n                        # Apply configuration\n                        plugin_config = config_func(model_name, config.copy())\n                        if plugin_config and isinstance(plugin_config, dict):\n                            # Update configuration\n                            config.update(plugin_config)\n                            \n                except Exception as e:\n                    self.log(f\"[Error] Model config {config_id} failed: {e}\")\n        \n        # Filter out parameters that shouldn't be passed to Ollama's command line\n        # Only allow known Ollama parameters\n        valid_ollama_params = [\"temperature\", \"context\", \"threads\", \"gpu\", \"seed\"]\n        filtered_config = {}\n        \n        for key, value in config.items():\n            if key in valid_ollama_params:\n                filtered_config[key] = value\n            else:\n                # Log that we're ignoring this parameter\n                if hasattr(self, \"log\"):\n                    self.log(f\"[Warning] Ignoring parameter for Ollama: {key}\")\n                    \n        return filtered_config\n    \n    def start_selected_model(self):\n        \"\"\"Start the selected model\"\"\"\n        selection = self.model_tree.selection()\n        if not selection:\n            return\n            \n        # Get model name\n        item = selection[0]\n        values = self.model_tree.item(item, \"values\")\n        model_name = values[0]\n        \n        # Check if already running\n        if self.model_manager.model_process and self.model_manager.model_process.poll() is None:\n            result = messagebox.askyesno(\n                \"Model Already Running\", \n                f\"Another model is already running. Stop it and start '{model_name}' instead?\",\n                icon=messagebox.WARNING\n            )\n                \n            if result:\n                self.model_manager.stop_model()\n            else:\n                return\n                \n        # Update progress bar and status\n        self.progress_mode.set(\"indeterminate\")\n        self.progress_bar.config(mode=\"indeterminate\")\n        self.progress_bar.start()\n        self.status_var.set(f\"Starting {model_name}...\")\n        \n        # Event callback for model events\n        def on_model_event(event_type, data):\n            if event_type == \"started\":\n                self.frame.after(0, lambda: self._update_model_status(model_name, MODEL_STATUS[\"RUNNING\"]))\n                self.frame.after(0, lambda: self._reset_progress_bar())\n                self.frame.after(0, lambda: self.status_var.set(f\"{model_name} is running\"))\n            elif event_type == \"stopped\":\n                self.frame.after(0, lambda: self._update_model_status(model_name, MODEL_STATUS[\"INSTALLED\"]))\n                self.frame.after(0, lambda: self._reset_progress_bar())\n                self.frame.after(0, lambda: self.status_var.set(f\"{model_name} stopped\"))\n            elif event_type == \"error\":\n                self.frame.after(0, lambda: self._update_model_status(model_name, MODEL_STATUS[\"ERROR\"]))\n                self.frame.after(0, lambda: self._reset_progress_bar())\n                self.frame.after(0, lambda: self.status_var.set(f\"Error: {data}\"))\n                \n        # Get model configuration with plugin customizations\n        model_config = self.get_model_config(model_name)\n        \n        # Start the model with config\n        success = self.model_manager.start_model(model_name, on_model_event, model_config)\n        \n        if success:\n            # Update tree item\n            self.model_tree.item(\n                item, \n                values=(model_name, values[1], MODEL_STATUS[\"LOADING\"], values[3])\n            )\n                \n            # Disable buttons during loading\n            self.install_button.config(state=tk.DISABLED)\n            self.uninstall_button.config(state=tk.DISABLED)\n            self.start_button.config(state=tk.DISABLED)\n            self.stop_button.config(state=tk.NORMAL)\n                \n            # Select this model for use\n            self.select_current_model()\n        else:\n            # Reset progress bar and status\n            self._reset_progress_bar()\n            self.status_var.set(f\"Failed to start {model_name}\")\n            \n    def stop_running_model(self):\n        \"\"\"Stop the running model\"\"\"\n        # Check if model is running\n        if not self.model_manager.model_process or self.model_manager.model_process.poll() is not None:\n            messagebox.showinfo(\"No Model Running\", \"No model is currently running\")\n            return\n            \n        # Update progress bar and status\n        self.progress_mode.set(\"indeterminate\")\n        self.progress_bar.config(mode=\"indeterminate\")\n        self.progress_bar.start()\n        self.status_var.set(\"Stopping model...\")\n        \n        # Stop the model\n        success = self.model_manager.stop_model()\n        \n        if success:\n            # Reset progress bar and status\n            self._reset_progress_bar()\n            self.status_var.set(\"Model stopped\")\n            \n            # Reset button states\n            self.stop_button.config(state=tk.DISABLED)\n            \n            # Update tree items\n            self._refresh_tree_status()\n        else:\n            # Reset progress bar and status\n            self._reset_progress_bar()\n            self.status_var.set(\"Failed to stop model\")\n            \n    def _update_progress(self, value):\n        \"\"\"\n        Update progress bar value\n        \n        Args:\n            value: Progress value (0-100)\n        \"\"\"\n        # Ensure we're in determinate mode\n        if self.progress_mode.get() != \"determinate\":\n            self.progress_bar.stop()\n            self.progress_mode.set(\"determinate\")\n            self.progress_bar.config(mode=\"determinate\")\n            \n        # Update the value\n        self.progress_var.set(value)\n        \n    def _update_model_status(self, model_name, status):\n        \"\"\"\n        Update the status of a model in the tree\n        \n        Args:\n            model_name: Name of the model\n            status: New status\n        \"\"\"\n        # Find the item with this model name\n        for item in self.model_tree.get_children():\n            values = self.model_tree.item(item, \"values\")\n            if values[0] == model_name:\n                # Update the status\n                self.model_tree.item(\n                    item, \n                    values=(values[0], values[1], status, values[3])\n                )\n                \n                # If this is the selected item, update the info panel\n                if item in self.model_tree.selection():\n                    self.selected_status_var.set(status)\n                    \n                # Update button states\n                self.on_model_selected()\n                break\n                \n    def _refresh_tree_status(self):\n        \"\"\"Refresh the status of all models in the tree\"\"\"\n        for item in self.model_tree.get_children():\n            values = self.model_tree.item(item, \"values\")\n            model_name = values[0]\n            \n            # Get current status\n            status = self.model_manager.model_statuses.get(model_name, MODEL_STATUS[\"NOT_INSTALLED\"])\n            \n            # Update the item\n            self.model_tree.item(\n                item, \n                values=(model_name, values[1], status, values[3])\n            )\n            \n        # Update selected item\n        self.on_model_selected()\n        \n    def open_model_folder(self):\n        \"\"\"Open the model folder in file explorer\"\"\"\n        import os\n        import subprocess\n        import sys\n        \n        model_path = self.model_manager.model_path\n        \n        try:\n            if not os.path.exists(model_path):\n                os.makedirs(model_path, exist_ok=True)\n                \n            # Open folder based on OS\n            if os.name == 'nt':  # Windows\n                os.startfile(model_path)\n            elif os.name == 'posix':  # macOS, Linux\n                subprocess.run(['open' if sys.platform == 'darwin' else 'xdg-open', model_path])\n                \n            self.log(f\"[Opened] Model folder: {model_path}\")\n        except Exception as e:\n            self.log(f\"[Error] Cannot open model folder: {e}\")\n            messagebox.showerror(\"Error\", f\"Cannot open model folder: {e}\")\n    \n    def process_queue(self):\n        \"\"\"Process queued UI update requests from threads\"\"\"\n        try:\n            while True:\n                # Get task without waiting\n                item = self.update_queue.get_nowait()\n                try:\n                    # Check if item is a function or a tuple\n                    if callable(item):\n                        # Just a function, call it directly\n                        item()\n                    else:\n                        # Must be a tuple with a callable as the first item\n                        if isinstance(item, tuple) and len(item) > 0 and callable(item[0]):\n                            if len(item) == 3:\n                                # Format: (task, args, kwargs)\n                                task, args, kwargs = item\n                                task(*args, **kwargs)\n                            elif len(item) == 2:\n                                # Format: (task, args)\n                                task, args = item\n                                task(*args)\n                            else:\n                                # Just task\n                                item[0]()\n                        else:\n                            # Log the error\n                            self.log(f\"[Error] Invalid queue item format: {item}\")\n                except Exception as e:\n                    self.log(f\"[Error] Error in queued task: {e}\")\n                self.update_queue.task_done()\n        except queue.Empty:\n            # Queue is empty, schedule next check\n            pass\n        finally:\n            # Schedule next queue check\n            self.frame.after(100, self.process_queue)\n            \n    def execute_plugin_action(self, action_id):\n        \"\"\"\n        Execute a plugin-provided model action\n        \n        Args:\n            action_id: ID of the action to execute\n        \"\"\"\n        if action_id not in self.plugin_actions:\n            return\n            \n        # Get selected model\n        selection = self.model_tree.selection()\n        if not selection:\n            messagebox.showinfo(\"No Model Selected\", \"Please select a model first\")\n            return\n            \n        # Get model name\n        item = selection[0]\n        values = self.model_tree.item(item, \"values\")\n        model_name = values[0]\n        \n        try:\n            # Execute the action\n            action_func = self.plugin_actions[action_id][\"function\"]\n            result = action_func(model_name, self)\n            \n            # Show result if provided\n            if result and isinstance(result, str):\n                messagebox.showinfo(\"Action Result\", result)\n                \n            self.log(f\"[Model Panel] Executed action {action_id} on model {model_name}\")\n            \n        except Exception as e:\n            messagebox.showerror(\"Error\", str(e))\n            self.log(f\"[Model Panel] Error executing action {action_id}: {e}\")\n\n    def register_plugin_extension(self, plugin_id, plugin):\n        \"\"\"\n        Register plugin extensions for the model panel\n        \n        Args:\n            plugin_id: Plugin identifier\n            plugin: Plugin instance\n        \"\"\"\n        # Skip if plugin doesn't have model extensions\n        if not hasattr(plugin, \"get_model_extensions\"):\n            return\n            \n        try:\n            # Get extensions from plugin\n            extensions = plugin.get_model_extensions()\n            \n            if not extensions or not isinstance(extensions, dict):\n                return\n                \n            # Register model providers\n            if \"model_providers\" in extensions and isinstance(extensions[\"model_providers\"], dict):\n                for name, provider_func in extensions[\"model_providers\"].items():\n                    if callable(provider_func):\n                        self.plugin_model_providers[f\"{plugin_id}.{name}\"] = provider_func\n                \n            # Register model configurations\n            if \"model_configs\" in extensions and isinstance(extensions[\"model_configs\"], dict):\n                for model_name, config_func in extensions[\"model_configs\"].items():\n                    if callable(config_func):\n                        self.plugin_model_configs[f\"{plugin_id}.{model_name}\"] = config_func\n                        \n            # Register model actions\n            if \"model_actions\" in extensions and isinstance(extensions[\"model_actions\"], dict):\n                for action_name, action_func in extensions[\"model_actions\"].items():\n                    if callable(action_func):\n                        self.plugin_actions[f\"{plugin_id}.{action_name}\"] = {\n                            \"function\": action_func,\n                            \"label\": action_name.replace(\"_\", \" \").title()\n                        }\n            \n            # Register UI extensions\n            if \"ui_extensions\" in extensions and isinstance(extensions[\"ui_extensions\"], list):\n                self.add_plugin_ui_extensions(plugin_id, extensions[\"ui_extensions\"])\n                \n            # Update UI to reflect new extensions            \n            self.update_plugin_action_menu()\n            \n            # Refresh model list to include custom models if any\n            if \"model_providers\" in extensions:\n                self.refresh_model_list()\n            \n            self.log(f\"[Model Panel] Registered extensions from plugin: {plugin_id}\")\n            \n        except Exception as e:\n            self.log(f\"[Model Panel] Error registering extensions from plugin {plugin_id}: {e}\")\n\n    def unregister_plugin_extension(self, plugin_id):\n        \"\"\"\n        Unregister plugin extensions\n        \n        Args:\n            plugin_id: Plugin identifier\n        \"\"\"\n        # Remove model providers\n        providers_to_remove = [k for k in self.plugin_model_providers if k.startswith(f\"{plugin_id}.\")]\n        for provider_id in providers_to_remove:\n            del self.plugin_model_providers[provider_id]\n        \n        # Remove model configs\n        configs_to_remove = [k for k in self.plugin_model_configs if k.startswith(f\"{plugin_id}.\")]\n        for config_id in configs_to_remove:\n            del self.plugin_model_configs[config_id]\n        \n        # Remove actions\n        actions_to_remove = [k for k in self.plugin_actions if k.startswith(f\"{plugin_id}.\")]\n        for action_id in actions_to_remove:\n            del self.plugin_actions[action_id]\n        \n        # Remove UI extensions\n        if plugin_id in self.plugin_ui_extensions:\n            for extension in self.plugin_ui_extensions[plugin_id]:\n                if extension.winfo_exists():\n                    extension.destroy()\n            del self.plugin_ui_extensions[plugin_id]\n        \n        # Update UI to reflect removed extensions\n        self.update_plugin_action_menu()\n        \n        # Hide plugin frame if no more extensions\n        if not any(self.plugin_ui_extensions.values()) and self.plugin_frame.winfo_ismapped():\n            self.plugin_frame.pack_forget()\n            \n        # Refresh model list if we removed model providers\n        if any(provider.startswith(f\"{plugin_id}.\") for provider in providers_to_remove):\n            self.refresh_model_list()\n        \n        self.log(f\"[Model Panel] Unregistered extensions from plugin: {plugin_id}\")\n\n    def add_plugin_ui_extensions(self, plugin_id, extensions):\n        \"\"\"\n        Add plugin UI extensions to the model panel\n        \n        Args:\n            plugin_id: Plugin identifier\n            extensions: List of UI extension widgets\n        \"\"\"\n        # Skip if no extensions\n        if not extensions:\n            return\n        \n        # Create container for this plugin if needed\n        if plugin_id not in self.plugin_ui_extensions:\n            self.plugin_ui_extensions[plugin_id] = []\n        \n        # Add each extension\n        for extension in extensions:\n            if isinstance(extension, tk.Widget):\n                # Add to plugin frame\n                extension.pack(in_=self.plugin_frame, fill=tk.X, padx=5, pady=2)\n                \n                # Add to our tracking list\n                self.plugin_ui_extensions[plugin_id].append(extension)\n        \n        # Show the plugin frame if not already visible\n        if not self.plugin_frame.winfo_ismapped() and any(self.plugin_ui_extensions.values()):\n            self.plugin_frame.pack(fill=tk.X, padx=10, pady=10, before=self.frame.winfo_children()[2])\n\n    def update_plugin_action_menu(self):\n        \"\"\"Update the plugin action menu with registered actions\"\"\"\n        # Skip if menu doesn't exist\n        if not hasattr(self, \"plugin_action_menu\"):\n            return\n            \n        # Clear existing items\n        self.plugin_action_menu.delete(0, tk.END)\n        \n        # Add plugin actions\n        if self.plugin_actions:\n            for action_id, action_info in sorted(self.plugin_actions.items(), key=lambda x: x[1][\"label\"]):\n                # Add to menu\n                self.plugin_action_menu.add_command(\n                    label=action_info[\"label\"],\n                    command=lambda aid=action_id: self.execute_plugin_action(aid)\n                )\n        else:\n            # Add placeholder\n            self.plugin_action_menu.add_command(\n                label=\"No plugin actions available\",\n                state=tk.DISABLED\n            )\n\n    def on_plugin_activated(self, plugin_id, plugin_instance):\n        \"\"\"\n        Handle plugin activation event\n        \n        Args:\n            plugin_id: ID of activated plugin\n            plugin_instance: Plugin instance\n        \"\"\"\n        # Register model extensions for newly activated plugin\n        self.register_plugin_extension(plugin_id, plugin_instance)\n\n    def on_plugin_deactivated(self, plugin_id):\n        \"\"\"\n        Handle plugin deactivation event\n        \n        Args:\n            plugin_id: ID of deactivated plugin\n        \"\"\"\n        # Unregister model extensions\n        self.unregister_plugin_extension(plugin_id)\n\n    def on_plugin_unloaded(self, plugin_id):\n        \"\"\"\n        Handle plugin unloading event\n        \n        Args:\n            plugin_id: ID of unloaded plugin\n        \"\"\"\n        # Ensure extensions are unregistered\n        self.unregister_plugin_extension(plugin_id)\n\n    def setup_api_models_tab(self):\n        \"\"\"Setup the API models tab for configuring external API-based models\"\"\"\n        # Create main container frame\n        api_frame = ttk.Frame(self.api_models_frame)\n        api_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create API provider selection section\n        provider_frame = ttk.LabelFrame(api_frame, text=\"API Provider\")\n        provider_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Provider selection\n        ttk.Label(provider_frame, text=\"Select Provider:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.api_provider_var = tk.StringVar(value=\"OpenAI\")\n        provider_combo = ttk.Combobox(\n            provider_frame,\n            textvariable=self.api_provider_var,\n            values=[\"OpenAI\", \"Anthropic\", \"Azure OpenAI\", \"Custom Endpoint\"],\n            state=\"readonly\",\n            width=20\n        )\n        provider_combo.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)\n        provider_combo.bind(\"<<ComboboxSelected>>\", self.on_api_provider_changed)\n        \n        # API Key section\n        key_frame = ttk.LabelFrame(api_frame, text=\"API Authentication\")\n        key_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(key_frame, text=\"API Key:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.api_key_var = tk.StringVar()\n        self.api_key_entry = ttk.Entry(key_frame, textvariable=self.api_key_var, width=40, show=\"*\")\n        self.api_key_entry.grid(row=0, column=1, sticky=tk.W + tk.E, padx=5, pady=5)\n        \n        show_key_frame = ttk.Frame(key_frame)\n        show_key_frame.grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)\n        \n        # Show/Hide API key toggle\n        self.show_key_var = tk.BooleanVar(value=False)\n        show_key_check = ttk.Checkbutton(\n            show_key_frame, \n            text=\"Show Key\", \n            variable=self.show_key_var,\n            command=self.toggle_show_api_key\n        )\n        show_key_check.pack(side=tk.LEFT)\n        \n        # For Azure and Custom: endpoint URL\n        self.endpoint_frame = ttk.Frame(key_frame)\n        self.endpoint_frame.grid(row=1, column=0, columnspan=3, sticky=tk.W + tk.E, padx=5, pady=5)\n        \n        ttk.Label(self.endpoint_frame, text=\"Endpoint URL:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.endpoint_var = tk.StringVar(value=\"https://api.openai.com/v1\")\n        endpoint_entry = ttk.Entry(self.endpoint_frame, textvariable=self.endpoint_var, width=40)\n        endpoint_entry.grid(row=0, column=1, sticky=tk.W + tk.E, padx=5, pady=5)\n        \n        # Initially hide endpoint frame for providers that don't need it\n        self.update_endpoint_visibility()\n        \n        # Model selection section\n        model_frame = ttk.LabelFrame(api_frame, text=\"Model Selection\")\n        model_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(model_frame, text=\"Select Model:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.api_model_var = tk.StringVar()\n        self.api_model_combo = ttk.Combobox(\n            model_frame,\n            textvariable=self.api_model_var,\n            state=\"readonly\",\n            width=30\n        )\n        self.api_model_combo.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # Fill model dropdown based on selected provider\n        self.update_api_model_list()\n        \n        # Configuration options\n        config_frame = ttk.LabelFrame(api_frame, text=\"API Configuration\")\n        config_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Temperature\n        ttk.Label(config_frame, text=\"Temperature:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.temperature_var = tk.DoubleVar(value=0.7)\n        temperature_slider = ttk.Scale(\n            config_frame,\n            from_=0.0,\n            to=1.0,\n            orient=tk.HORIZONTAL,\n            variable=self.temperature_var,\n            length=200\n        )\n        temperature_slider.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        temp_value_label = ttk.Label(config_frame, textvariable=self.temperature_var)\n        temp_value_label.grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)\n        \n        # Max tokens\n        ttk.Label(config_frame, text=\"Max Tokens:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.max_tokens_var = tk.IntVar(value=1024)\n        max_tokens_entry = ttk.Spinbox(\n            config_frame,\n            from_=1,\n            to=32000,\n            textvariable=self.max_tokens_var,\n            width=10\n        )\n        max_tokens_entry.grid(row=1, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # Action buttons\n        button_frame = ttk.Frame(api_frame)\n        button_frame.pack(fill=tk.X, padx=5, pady=10)\n        \n        # Test connection button\n        ttk.Button(\n            button_frame,\n            text=\"Test Connection\",\n            command=self.test_api_connection\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Save button\n        ttk.Button(\n            button_frame,\n            text=\"Save Configuration\",\n            command=self.save_api_configuration,\n            style=\"Accent.TButton\"\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        # Use this model button\n        ttk.Button(\n            button_frame,\n            text=\"Use This Model\",\n            command=self.use_api_model\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        # Load saved API configuration if available\n        self.load_api_configuration()\n        \n    def on_api_provider_changed(self, event=None):\n        \"\"\"Handle API provider selection changes\"\"\"\n        provider = self.api_provider_var.get()\n        self.log(f\"[Models] API provider changed to {provider}\")\n        \n        # Update visibility of endpoint URL field\n        self.update_endpoint_visibility()\n        \n        # Update model list based on provider\n        self.update_api_model_list()\n        \n    def update_endpoint_visibility(self):\n        \"\"\"Show/hide endpoint URL field based on selected provider\"\"\"\n        provider = self.api_provider_var.get()\n        \n        if provider in [\"Azure OpenAI\", \"Custom Endpoint\"]:\n            self.endpoint_frame.grid()\n            \n            # Set default endpoint for Azure\n            if provider == \"Azure OpenAI\" and self.endpoint_var.get() == \"https://api.openai.com/v1\":\n                self.endpoint_var.set(\"https://{resource}.openai.azure.com/\")\n        else:\n            self.endpoint_frame.grid_remove()\n            \n            # Reset to default OpenAI endpoint\n            if provider == \"OpenAI\":\n                self.endpoint_var.set(\"https://api.openai.com/v1\")\n            elif provider == \"Anthropic\":\n                self.endpoint_var.set(\"https://api.anthropic.com\")\n    \n    def update_api_model_list(self):\n        \"\"\"Update the model dropdown based on selected provider\"\"\"\n        provider = self.api_provider_var.get()\n        models = []\n        \n        if provider == \"OpenAI\":\n            models = [\n                \"gpt-3.5-turbo\", \n                \"gpt-3.5-turbo-16k\", \n                \"gpt-4\",\n                \"gpt-4-turbo\", \n                \"gpt-4-32k\",\n                \"gpt-4o\"\n            ]\n        elif provider == \"Anthropic\":\n            models = [\n                \"claude-3-opus-20240229\", \n                \"claude-3-sonnet-20240229\",\n                \"claude-3-haiku-20240307\",\n                \"claude-2.1\", \n                \"claude-2.0\", \n                \"claude-instant-1.2\"\n            ]\n        elif provider == \"Azure OpenAI\":\n            models = [\n                \"gpt-35-turbo\",\n                \"gpt-4\",\n                \"gpt-4-turbo\"\n            ]\n        elif provider == \"Custom Endpoint\":\n            models = [\"custom-model\"]\n            \n        # Update combobox values\n        self.api_model_combo[\"values\"] = models\n        \n        # Set default value if list is not empty\n        if models and not self.api_model_var.get() in models:\n            self.api_model_var.set(models[0])\n            \n    def toggle_show_api_key(self):\n        \"\"\"Toggle API key visibility\"\"\"\n        if self.show_key_var.get():\n            self.api_key_entry.config(show=\"\")\n        else:\n            self.api_key_entry.config(show=\"*\")\n            \n    def save_api_configuration(self):\n        \"\"\"Save API configuration to config file\"\"\"\n        if not hasattr(self.model_manager, 'config') or not self.model_manager.config:\n            messagebox.showerror(\"Error\", \"Configuration manager is not available\")\n            return\n            \n        config = self.model_manager.config\n        \n        # Create API configuration\n        api_config = {\n            \"provider\": self.api_provider_var.get(),\n            \"model\": self.api_model_var.get(),\n            \"endpoint\": self.endpoint_var.get(),\n            \"temperature\": self.temperature_var.get(),\n            \"max_tokens\": self.max_tokens_var.get()\n        }\n        \n        # Save API key securely (consider using environment variables or a keyring)\n        if self.api_key_var.get().strip():\n            api_config[\"api_key\"] = self.api_key_var.get().strip()\n              # Update config\n        config.set(\"api_models\", api_config)\n        config.save_config()\n        \n        self.log(\"[Models] API configuration saved\")\n        messagebox.showinfo(\"Success\", \"API configuration has been saved\")\n        \n    def load_api_configuration(self):\n        \"\"\"Load API configuration from config file\"\"\"\n        if not hasattr(self.model_manager, 'config') or not self.model_manager.config:\n            self.log(\"[Models] Config manager not available, using default API settings\")\n            return\n            \n        config = self.model_manager.config\n        api_config = config.get(\"api_models\", {})\n        \n        if api_config:\n            # Set provider\n            if \"provider\" in api_config and api_config[\"provider\"] in [\"OpenAI\", \"Anthropic\", \"Azure OpenAI\", \"Custom Endpoint\"]:\n                self.api_provider_var.set(api_config[\"provider\"])\n                \n            # Set endpoint\n            if \"endpoint\" in api_config:\n                self.endpoint_var.set(api_config[\"endpoint\"])\n                \n            # Update UI based on provider\n            self.update_endpoint_visibility()\n            self.update_api_model_list()\n            \n            # Set model\n            if \"model\" in api_config:\n                # Check if model exists in current list\n                if api_config[\"model\"] in self.api_model_combo[\"values\"]:\n                    self.api_model_var.set(api_config[\"model\"])\n            \n            # Set temperature\n            if \"temperature\" in api_config:\n                self.temperature_var.set(float(api_config[\"temperature\"]))\n                \n            # Set max tokens\n            if \"max_tokens\" in api_config:\n                self.max_tokens_var.set(int(api_config[\"max_tokens\"]))\n                \n            # Set API key if available\n            if \"api_key\" in api_config:\n                self.api_key_var.set(api_config[\"api_key\"])\n                \n    def test_api_connection(self):\n        \"\"\"Test connection to the selected API provider\"\"\"\n        provider = self.api_provider_var.get()\n        model = self.api_model_var.get()\n        api_key = self.api_key_var.get().strip()\n        \n        if not api_key:\n            messagebox.showerror(\"Error\", \"API key is required\")\n            return\n            \n        self.log(f\"[Models] Testing connection to {provider} API...\")\n        \n        # Show testing indicator\n        messagebox.showinfo(\"Testing\", f\"Testing connection to {provider} API...\")\n        \n        # Implement actual API testing here\n        # This would typically involve making a simple API call to validate credentials\n        \n        # For now, we'll just simulate a successful test\n        self.log(f\"[Models] Successfully connected to {provider} API\")\n        messagebox.showinfo(\"Success\", f\"Successfully connected to {provider} API\")\n        \n    def use_api_model(self):\n        \"\"\"Set the current API model as the active model\"\"\"\n        provider = self.api_provider_var.get()\n        model = self.api_model_var.get()\n        api_key = self.api_key_var.get().strip()\n        \n        if not api_key:\n            messagebox.showerror(\"Error\", \"API key is required\")\n            return\n            \n        # First save the configuration\n        self.save_api_configuration()\n        \n        # Format model identifier with provider prefix\n        api_model_id = f\"api:{provider}:{model}\"\n        \n        # Call callback to notify parent about model selection\n        if self.on_model_selected_callback:\n            self.log(f\"[Models] Selected API model: {api_model_id}\")\n            self.on_model_selected_callback(api_model_id)\n            messagebox.showinfo(\"Model Selected\", f\"{provider} model '{model}' has been selected\")\n            \n    def setup_settings_tab(self):\n        \"\"\"Setup the Model Settings tab for configuring model parameters\"\"\"\n        # Create main container frame with padding\n        settings_container = ttk.Frame(self.settings_frame, padding=(10, 10, 10, 10))\n        settings_container.pack(fill=tk.BOTH, expand=True)\n        \n        # Create header\n        ttk.Label(\n            settings_container, \n            text=\"Model Settings\", \n            font=(\"\", 14, \"bold\")\n        ).pack(anchor=tk.W, pady=(0, 10))\n        \n        # Create sections for settings\n        self._create_settings_sections(settings_container)\n        \n        # Buttons at bottom\n        button_frame = ttk.Frame(settings_container)\n        button_frame.pack(fill=tk.X, pady=10)\n        \n        # Reset button\n        reset_button = ttk.Button(\n            button_frame,\n            text=\"Reset to Defaults\",\n            command=self.reset_settings\n        )\n        reset_button.pack(side=tk.LEFT, padx=5)\n        \n        # Apply button\n        apply_button = ttk.Button(\n            button_frame,\n            text=\"Apply Settings\",\n            command=self.apply_settings,\n            style=\"Accent.TButton\"\n        )\n        apply_button.pack(side=tk.RIGHT, padx=5)\n        \n        # Load current settings\n        self.load_current_settings()\n    \n    def _create_settings_sections(self, parent_frame):\n        \"\"\"Create all settings sections in the given parent frame\n        \n        Args:\n            parent_frame: Parent frame to contain settings sections\n        \"\"\"\n        # 1. General Settings Section\n        general_frame = ttk.LabelFrame(parent_frame, text=\"General Settings\")\n        general_frame.pack(fill=tk.X, padx=5, pady=10)\n        \n        general_grid = ttk.Frame(general_frame)\n        general_grid.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Temperature setting\n        ttk.Label(general_grid, text=\"Temperature:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.temperature_var = tk.DoubleVar(value=0.7)\n        temperature_scale = ttk.Scale(\n            general_grid,\n            from_=0.0,\n            to=1.5,\n            orient=tk.HORIZONTAL,\n            variable=self.temperature_var,\n            length=200\n        )\n        temperature_scale.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        temp_value = ttk.Label(general_grid, textvariable=self.temperature_var)\n        temp_value.grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)\n        \n        ttk.Label(\n            general_grid, \n            text=\"Controls randomness: lower is more deterministic, higher is more creative\",\n            font=(\"\", 8),\n            foreground=\"gray\"\n        ).grid(row=0, column=3, sticky=tk.W, padx=5, pady=5)\n        \n        # Top-p setting\n        ttk.Label(general_grid, text=\"Top-p:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.top_p_var = tk.DoubleVar(value=0.9)\n        top_p_scale = ttk.Scale(\n            general_grid,\n            from_=0.0,\n            to=1.0,\n            orient=tk.HORIZONTAL,\n            variable=self.top_p_var,\n            length=200\n        )\n        top_p_scale.grid(row=1, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        top_p_value = ttk.Label(general_grid, textvariable=self.top_p_var)\n        top_p_value.grid(row=1, column=2, sticky=tk.W, padx=5, pady=5)\n        \n        ttk.Label(\n            general_grid, \n            text=\"Controls diversity: 0.9 means consider tokens comprising the top 90% probability mass\",\n            font=(\"\", 8),\n            foreground=\"gray\"\n        ).grid(row=1, column=3, sticky=tk.W, padx=5, pady=5)\n        \n        # Max tokens setting\n        ttk.Label(general_grid, text=\"Max Tokens:\").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.max_tokens_var = tk.IntVar(value=2048)\n        max_tokens_entry = ttk.Spinbox(\n            general_grid,\n            from_=1,\n            to=32000,\n            textvariable=self.max_tokens_var,\n            width=8\n        )\n        max_tokens_entry.grid(row=2, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        ttk.Label(\n            general_grid, \n            text=\"Maximum number of tokens to generate in the response\",\n            font=(\"\", 8),\n            foreground=\"gray\"\n        ).grid(row=2, column=3, sticky=tk.W, padx=5, pady=5)\n        \n        # 2. Memory Settings Section\n        memory_frame = ttk.LabelFrame(parent_frame, text=\"Memory Settings\")\n        memory_frame.pack(fill=tk.X, padx=5, pady=10)\n        \n        memory_grid = ttk.Frame(memory_frame)\n        memory_grid.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Memory mode\n        ttk.Label(memory_grid, text=\"Memory Mode:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.memory_mode_var = tk.StringVar(value=\"Auto\")\n        memory_mode_combo = ttk.Combobox(\n            memory_grid,\n            textvariable=self.memory_mode_var,\n            values=[\"Off\", \"Basic\", \"Auto\", \"Advanced\"],\n            state=\"readonly\",\n            width=15\n        )\n        memory_mode_combo.grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)\n        memory_mode_combo.bind(\"<<ComboboxSelected>>\", self.on_memory_mode_changed)\n        \n        ttk.Label(\n            memory_grid, \n            text=\"Determines how context from previous conversations is used\",\n            font=(\"\", 8),\n            foreground=\"gray\"\n        ).grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)\n        \n        # Context window size\n        ttk.Label(memory_grid, text=\"Context Window:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.context_window_var = tk.StringVar(value=\"4096\")\n        context_window_combo = ttk.Combobox(\n            memory_grid,\n            textvariable=self.context_window_var,\n            values=[\"2048\", \"4096\", \"8192\", \"16384\", \"32768\"],\n            width=15\n        )\n        context_window_combo.grid(row=1, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        ttk.Label(\n            memory_grid, \n            text=\"Maximum context size in tokens (depends on model capability)\",\n            font=(\"\", 8),\n            foreground=\"gray\"\n        ).grid(row=1, column=2, sticky=tk.W, padx=5, pady=5)\n        \n        # 3. Performance Settings Section\n        perf_frame = ttk.LabelFrame(parent_frame, text=\"Performance Settings\")\n        perf_frame.pack(fill=tk.X, padx=5, pady=10)\n        \n        perf_grid = ttk.Frame(perf_frame)\n        perf_grid.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Use 8-bit quantization\n        self.use_8bit_var = tk.BooleanVar(value=False)\n        use_8bit_check = ttk.Checkbutton(\n            perf_grid,\n            text=\"Use 8-bit Quantization\",\n            variable=self.use_8bit_var,\n            command=self.on_quantization_changed\n        )\n        use_8bit_check.grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        ttk.Label(\n            perf_grid, \n            text=\"Reduces VRAM usage but may slightly reduce quality\",\n            font=(\"\", 8),\n            foreground=\"gray\"\n        ).grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # Specify VRAM limit\n        self.limit_vram_var = tk.BooleanVar(value=False)\n        limit_vram_check = ttk.Checkbutton(\n            perf_grid,\n            text=\"Limit VRAM Usage:\",\n            variable=self.limit_vram_var,\n            command=self.on_vram_limit_changed\n        )\n        limit_vram_check.grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        self.vram_limit_var = tk.StringVar(value=\"4\")\n        vram_limit_combo = ttk.Combobox(\n            perf_grid,\n            textvariable=self.vram_limit_var,\n            values=[\"4\", \"8\", \"16\", \"24\", \"32\"],\n            width=5\n        )\n        vram_limit_combo.grid(row=1, column=1, sticky=tk.W, padx=5, pady=5)\n        ttk.Label(perf_grid, text=\"GB\").grid(row=1, column=2, sticky=tk.W)\n        \n        # 4. System Prompt Section\n        prompt_frame = ttk.LabelFrame(parent_frame, text=\"System Prompt\")\n        prompt_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=10)\n        \n        prompt_inner = ttk.Frame(prompt_frame)\n        prompt_inner.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        ttk.Label(\n            prompt_inner,\n            text=\"System prompt defines the AI's behavior and capabilities:\"\n        ).pack(anchor=tk.W)\n        \n        # Create system prompt dropdown for presets\n        preset_frame = ttk.Frame(prompt_inner)\n        preset_frame.pack(fill=tk.X, pady=5)\n        \n        ttk.Label(preset_frame, text=\"Preset:\").pack(side=tk.LEFT, padx=5)\n        \n        self.preset_var = tk.StringVar(value=\"Custom\")\n        preset_combo = ttk.Combobox(\n            preset_frame,\n            textvariable=self.preset_var,\n            values=[\"Helpful Assistant\", \"Creative Writer\", \"Coding Expert\", \"Scientific Advisor\", \"Custom\"],\n            state=\"readonly\",\n            width=20\n        )\n        preset_combo.pack(side=tk.LEFT, padx=5)\n        preset_combo.bind(\"<<ComboboxSelected>>\", self.on_preset_selected)\n        \n        # System prompt text area\n        self.system_prompt_text = tk.Text(prompt_inner, height=5, wrap=tk.WORD)\n        self.system_prompt_text.pack(fill=tk.BOTH, expand=True, pady=5)\n        self.system_prompt_text.insert(\"1.0\", \"You are a helpful, creative, and knowledgeable assistant.\")\n    \n    def load_current_settings(self):\n        \"\"\"Load current model settings from config\"\"\"\n        if hasattr(self.model_manager, 'config') and self.model_manager.config:\n            config = self.model_manager.config\n            \n            # General settings\n            self.temperature_var.set(config.get(\"temperature\", 0.7))\n            self.top_p_var.set(config.get(\"top_p\", 0.9))\n            self.max_tokens_var.set(config.get(\"max_tokens\", 2048))\n            \n            # Memory settings\n            self.memory_mode_var.set(config.get(\"memory_mode\", \"Auto\"))\n            self.context_window_var.set(str(config.get(\"context_window\", 4096)))\n            \n            # Performance settings\n            self.use_8bit_var.set(config.get(\"model.use_8bit\", False))\n            self.limit_vram_var.set(config.get(\"limit_vram\", False))\n            self.vram_limit_var.set(str(config.get(\"vram_limit\", 4)))\n            \n            # System prompt\n            system_prompt = config.get(\"system_prompt\", \"\")\n            if system_prompt:\n                self.system_prompt_text.delete(\"1.0\", tk.END)\n                self.system_prompt_text.insert(\"1.0\", system_prompt)\n    \n    def reset_settings(self):\n        \"\"\"Reset settings to default values\"\"\"\n        # General settings\n        self.temperature_var.set(0.7)\n        self.top_p_var.set(0.9)\n        self.max_tokens_var.set(2048)\n        \n        # Memory settings\n        self.memory_mode_var.set(\"Auto\")\n        self.context_window_var.set(\"4096\")\n        \n        # Performance settings\n        self.use_8bit_var.set(False)\n        self.limit_vram_var.set(False)\n        self.vram_limit_var.set(\"4\")\n        \n        # System prompt\n        self.system_prompt_text.delete(\"1.0\", tk.END)\n        self.system_prompt_text.insert(\"1.0\", \"You are a helpful, creative, and knowledgeable assistant.\")\n        \n        self.log(\"[Settings] Reset settings to defaults\")\n    \n    def apply_settings(self, close_dialog=None):\n        \"\"\"Apply model settings to config\n        \n        Args:\n            close_dialog: Optional dialog to close after applying settings\n        \"\"\"\n        if hasattr(self.model_manager, 'config') and self.model_manager.config:\n            config = self.model_manager.config\n            \n            # General settings\n            config.set(\"temperature\", self.temperature_var.get())\n            config.set(\"top_p\", self.top_p_var.get())\n            config.set(\"max_tokens\", self.max_tokens_var.get())\n            \n            # Memory settings\n            config.set(\"memory_mode\", self.memory_mode_var.get())\n            config.set(\"context_window\", int(self.context_window_var.get()))\n            \n            # Performance settings\n            config.set(\"model.use_8bit\", self.use_8bit_var.get())\n            config.set(\"limit_vram\", self.limit_vram_var.get())\n            config.set(\"vram_limit\", int(self.vram_limit_var.get()))\n              # System prompt\n            system_prompt = self.system_prompt_text.get(\"1.0\", tk.END).strip()\n            config.set(\"system_prompt\", system_prompt)\n            \n            # Save config\n            config.save_config()\n            \n            # Apply to model manager if needed\n            self.model_manager.use_8bit = self.use_8bit_var.get()\n            \n            # Log\n            self.log(\"[Settings] Applied model settings\")\n            \n            # Show confirmation\n            messagebox.showinfo(\"Settings Applied\", \"Model settings have been applied successfully.\")\n            \n            # Close dialog if provided\n            if close_dialog:\n                close_dialog.destroy()\n        else:\n            self.log(\"[Settings] Error: Config manager not available\")\n            messagebox.showerror(\"Error\", \"Configuration manager is not available\")\n    \n    def on_memory_mode_changed(self, event=None):\n        \"\"\"Handle memory mode change\"\"\"\n        mode = self.memory_mode_var.get()\n        self.log(f\"[Settings] Memory mode changed to {mode}\")\n        \n        # If a chat engine is available, update its memory mode\n        if hasattr(self.model_manager, 'chat_engine') and self.model_manager.chat_engine:\n            self.model_manager.chat_engine.set_memory_mode(mode)\n    \n    def on_quantization_changed(self):\n        \"\"\"Handle quantization setting change\"\"\"\n        use_8bit = self.use_8bit_var.get()\n        self.log(f\"[Settings] 8-bit quantization set to {use_8bit}\")\n        \n        # Show warning if turned on\n        if use_8bit:\n            import tkinter.messagebox as messagebox\n            messagebox.showwarning(\n                \"Quantization Enabled\", \n                \"8-bit quantization will take effect the next time a model is loaded. \"\n                \"This reduces VRAM usage but may slightly reduce output quality.\"\n            )\n    \n    def on_vram_limit_changed(self):\n        \"\"\"Handle VRAM limit setting change\"\"\"\n        limit_vram = self.limit_vram_var.get()\n        self.log(f\"[Settings] VRAM limit set to {limit_vram}\")\n        \n        # Find all comboboxes in the parent frame and update their state\n        for widget in self.frame.winfo_children():\n            if isinstance(widget, ttk.Combobox) and \"vram_limit\" in str(widget):\n                widget.config(state='readonly' if limit_vram else 'disabled')\n    \n    def on_preset_selected(self, event=None):\n        \"\"\"Handle preset selection\"\"\"\n        preset = self.preset_var.get()\n        self.log(f\"[Settings] Preset selected: {preset}\")\n        \n        # Clear current system prompt\n        self.system_prompt_text.delete(\"1.0\", tk.END)\n        \n        # Set preset prompt\n        if preset == \"Helpful Assistant\":\n            self.system_prompt_text.insert(\"1.0\", \"You are a helpful, creative, and knowledgeable assistant.\")\n        elif preset == \"Creative Writer\":\n            self.system_prompt_text.insert(\"1.0\", \"You are a creative writer with a flair for storytelling and vivid descriptions.\")\n        elif preset == \"Coding Expert\":\n            self.system_prompt_text.insert(\"1.0\", \"You are a programming expert who provides clear, concise code with thorough explanations.\")\n        elif preset == \"Scientific Advisor\":\n            self.system_prompt_text.insert(\"1.0\", \"You are a scientific advisor who provides accurate information with supporting evidence and citations.\")\n        elif preset == \"Custom\":\n            self.system_prompt_text.insert(\"1.0\", \"\")\n        \n    def get_frame(self):\n        \"\"\"Return the main frame of the model panel\"\"\"\n        return self.frame\n    \n    def _update_download_progress(self, percentage):\n        \"\"\"Update the UI with download progress\"\"\"\n        # Update progress bar to determinate mode if not already\n        if self.progress_mode.get() == \"indeterminate\":\n            self.progress_bar.stop()\n            self.progress_mode.set(\"determinate\")\n            self.progress_bar.config(mode=\"determinate\")\n            \n        # Set progress value\n        self.progress_bar.configure(value=percentage)\n        \n        # Update status text\n        self.status_var.set(f\"Downloading model: {percentage:.1f}%\")\n        \n        # Log progress at certain intervals to avoid flooding logs\n        if int(percentage) % 10 == 0:  # Log every 10%\n            self.log(f\"[Ollama] Download progress: {percentage:.1f}%\")",
  "D:\\AI\\IrintAI Assistant\\plugins\\personality_plugin\\bridge.py": "class PersonalityBridge:\n    \"\"\"\n    Bridge between the Personality Plugin and Irintai core system\n    \n    Provides fallback implementations and adaptation layer to ensure\n    the plugin works across different versions of the core system.\n    \"\"\"\n    \n    def __init__(self, core_system):\n        \"\"\"\n        Initialize the bridge\n        \n        Args:\n            core_system: Reference to Irintai core system\n        \"\"\"\n        self.core_system = core_system\n        self._patched = False\n        \n    def ensure_compatibility(self):\n        \"\"\"\n        Ensure the core system is compatible with the plugin\n        \n        Adds any missing hooks or functionality required by the plugin.\n        \"\"\"\n        if self._patched:\n            return\n            \n        # Patch chat engine if needed\n        if hasattr(self.core_system, \"chat_engine\"):\n            self._patch_chat_engine()\n            \n        # Patch memory system if needed\n        if hasattr(self.core_system, \"memory_system\"):\n            self._patch_memory_system()\n            \n        self._patched = True\n        \n    def _patch_chat_engine(self):\n        \"\"\"\n        Patch the chat engine to ensure it supports message modification\n        \"\"\"\n        chat_engine = self.core_system.chat_engine\n        \n        # Add message modifiers list if not present\n        if not hasattr(chat_engine, \"_message_modifiers\"):\n            chat_engine._message_modifiers = []\n            \n        # Add register_message_modifier method if not present\n        if not hasattr(chat_engine, \"register_message_modifier\"):\n            def register_message_modifier(modifier_function):\n                if not hasattr(chat_engine, \"_message_modifiers\"):\n                    chat_engine._message_modifiers = []\n                chat_engine._message_modifiers.append(modifier_function)\n                \n            chat_engine.register_message_modifier = register_message_modifier\n            \n        # Add unregister_message_modifier method if not present\n        if not hasattr(chat_engine, \"unregister_message_modifier\"):\n            def unregister_message_modifier(modifier_function):\n                if hasattr(chat_engine, \"_message_modifiers\"):\n                    if modifier_function in chat_engine._message_modifiers:\n                        chat_engine._message_modifiers.remove(modifier_function)\n                        \n            chat_engine.unregister_message_modifier = unregister_message_modifier\n            \n        # Patch send_message method to apply modifiers if not already patched\n        if not hasattr(chat_engine, \"_original_send_message\"):\n            # Save original method\n            chat_engine._original_send_message = chat_engine.send_message\n            \n            # Create patched method\n            def send_message_patched(content, on_response=None):\n                # Process the message through modifiers\n                if hasattr(chat_engine, \"_message_modifiers\"):\n                    for modifier in chat_engine._message_modifiers:\n                        try:\n                            content = modifier(content, \"user\")\n                        except Exception as e:\n                            # Log error but continue\n                            if hasattr(chat_engine, \"log\"):\n                                chat_engine.log(f\"Error in message modifier: {e}\", \"ERROR\")\n                \n                # Call original method\n                result = chat_engine._original_send_message(content, on_response)\n                \n                # Process response if it's a string\n                if isinstance(result, str) and hasattr(chat_engine, \"_message_modifiers\"):\n                    modified_result = result\n                    for modifier in chat_engine._message_modifiers:\n                        try:\n                            modified_result = modifier(modified_result, \"assistant\")\n                        except Exception as e:\n                            # Log error but continue\n                            if hasattr(chat_engine, \"log\"):\n                                chat_engine.log(f\"Error in message modifier: {e}\", \"ERROR\")\n                    return modified_result\n                \n                return result\n                \n            # Replace method\n            chat_engine.send_message = send_message_patched\n    \n    def _patch_memory_system(self):\n        \"\"\"\n        Patch the memory system to ensure it supports adding personality data\n        \"\"\"\n        memory_system = self.core_system.memory_system\n        \n        # Add add_to_index method if not present\n        if not hasattr(memory_system, \"add_to_index\"):\n            def add_to_index(docs, metadata):\n                if hasattr(memory_system, \"log\"):\n                    memory_system.log(\"Memory system does not support adding to index\", \"WARNING\")\n                return False\n                \n            memory_system.add_to_index = add_to_index\n\n    def get_system_prompt_hook(self):\n        \"\"\"\n        Returns a function that can modify the system prompt\n        \n        Returns:\n            Function to modify system prompts\n        \"\"\"\n        def modify_system_prompt(original_prompt, personality_plugin):\n            \"\"\"\n            Modify the system prompt based on active personality profile\n            \n            Args:\n                original_prompt: The original system prompt\n                personality_plugin: Reference to the personality plugin instance\n                \n            Returns:\n                Modified system prompt\n            \"\"\"\n            try:\n                active_profile = personality_plugin.get_active_profile()\n                \n                if not active_profile:\n                    return original_prompt\n                    \n                # Apply style modifiers to the prompt\n                modified_prompt = original_prompt\n                \n                # Add style instructions based on profile\n                style_modifiers = active_profile.get(\"style_modifiers\", {})\n                if style_modifiers:\n                    # Convert modifiers to natural language descriptions\n                    style_descriptions = []\n                    \n                    if style_modifiers.get(\"formality\", 0.5) > 0.7:\n                        style_descriptions.append(\"formal and professional\")\n                    elif style_modifiers.get(\"formality\", 0.5) < 0.3:\n                        style_descriptions.append(\"casual and conversational\")\n                        \n                    if style_modifiers.get(\"complexity\", 0.5) > 0.7:\n                        style_descriptions.append(\"using sophisticated language\")\n                    elif style_modifiers.get(\"complexity\", 0.5) < 0.3:\n                        style_descriptions.append(\"using simple, clear language\")\n                        \n                    if style_modifiers.get(\"empathy\", 0.5) > 0.7:\n                        style_descriptions.append(\"empathetic and understanding\")\n                    \n                    if style_modifiers.get(\"directness\", 0.5) > 0.7:\n                        style_descriptions.append(\"direct and straightforward\")\n                    elif style_modifiers.get(\"directness\", 0.5) < 0.3:\n                        style_descriptions.append(\"tactful and diplomatic\")\n                        \n                    if style_modifiers.get(\"humor\", 0.5) > 0.7:\n                        style_descriptions.append(\"with occasional humor\")\n                        \n                    if style_modifiers.get(\"creativity\", 0.5) > 0.7:\n                        style_descriptions.append(\"creative and imaginative\")\n                    elif style_modifiers.get(\"creativity\", 0.5) < 0.3:\n                        style_descriptions.append(\"factual and precise\")\n                        \n                    if style_modifiers.get(\"conciseness\", 0.5) > 0.7:\n                        style_descriptions.append(\"concise and to the point\")\n                    elif style_modifiers.get(\"conciseness\", 0.5) < 0.3:\n                        style_descriptions.append(\"with detailed explanations\")\n                    \n                    # Add style instructions to prompt\n                    if style_descriptions:\n                        style_text = \", \".join(style_descriptions)\n                        if not modified_prompt.endswith('.'):\n                            modified_prompt += '.'\n                        modified_prompt += f\" Communicate in a style that is {style_text}.\"\n                \n                # Add prefix if available\n                prefix = active_profile.get(\"prefix\", \"\")\n                if prefix and not modified_prompt.startswith(prefix):\n                    modified_prompt = prefix + modified_prompt\n                \n                # Add suffix if available\n                suffix = active_profile.get(\"suffix\", \"\")\n                if suffix and not modified_prompt.endswith(suffix):\n                    modified_prompt = modified_prompt + suffix\n                \n                return modified_prompt\n                \n            except Exception as e:\n                # Log error but return original prompt\n                if hasattr(self.core_system, \"log\"):\n                    self.core_system.log(f\"Error modifying system prompt: {e}\", \"ERROR\")\n                return original_prompt\n                \n        return modify_system_prompt\n\n    def register_with_memory(self, personality_plugin):\n        \"\"\"\n        Register personality data with the memory system\n        \n        Args:\n            personality_plugin: Reference to personality plugin instance\n            \n        Returns:\n            True if registered successfully, False otherwise\n        \"\"\"\n        try:\n            if not hasattr(self.core_system, \"memory_system\"):\n                return False\n                \n            memory_system = self.core_system.memory_system\n            \n            # Get the active profile\n            active_profile = personality_plugin.get_active_profile()\n            if not active_profile:\n                return False\n            \n            # Format profile data as text\n            profile_text = f\"ACTIVE PERSONALITY PROFILE: {active_profile.get('name', 'Unknown')}\\n\\n\"\n            profile_text += f\"Description: {active_profile.get('description', '')}\\n\"\n            \n            # Add style information\n            profile_text += \"\\nStyle characteristics:\\n\"\n            style_modifiers = active_profile.get(\"style_modifiers\", {})\n            for name, value in style_modifiers.items():\n                profile_text += f\"- {name}: {value:.1f}\\n\"\n            \n            # Create metadata\n            metadata = {\n                \"source\": \"personality_plugin\",\n                \"category\": \"assistant_configuration\",\n                \"subject\": \"personality_profile\",\n                \"profile_name\": active_profile.get(\"name\", \"Unknown\"),\n                \"text\": profile_text,\n                \"timestamp\": self._get_timestamp(),\n                \"importance\": 0.8  # High importance to ensure it's retrieved\n            }\n            \n            # Add to memory system\n            return memory_system.add_to_index([profile_text], [metadata])\n            \n        except Exception as e:\n            if hasattr(self.core_system, \"log\"):\n                self.core_system.log(f\"Error registering with memory: {e}\", \"ERROR\")\n            return False\n\n    def _get_timestamp(self):\n        \"\"\"\n        Get the current timestamp in the format used by the system\n        \n        Returns:\n            Timestamp string\n        \"\"\"\n        import time\n        return time.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def apply_personality_to_config(self, personality_plugin):\n        \"\"\"\n        Apply personality settings to the core configuration\n        \n        Args:\n            personality_plugin: Reference to personality plugin instance\n            \n        Returns:\n            True if applied successfully, False otherwise\n        \"\"\"\n        try:\n            if not hasattr(self.core_system, \"config_manager\"):\n                return False\n                \n            config_manager = self.core_system.config_manager\n            \n            # Get active profile\n            active_profile = personality_plugin.get_active_profile()\n            if not active_profile:\n                return False\n            \n            # Get formatting preferences\n            formatting = active_profile.get(\"formatting\", {})\n            \n            # Apply configuration changes\n            config_updates = {\n                \"personality\": {\n                    \"active_profile\": active_profile.get(\"name\", \"\"),\n                    \"use_markdown\": formatting.get(\"use_markdown\", True),\n                    \"emphasize_key_points\": formatting.get(\"emphasize_key_points\", False),\n                    \"paragraph_structure\": formatting.get(\"paragraph_structure\", \"standard\")\n                }\n            }\n            \n            # Update configuration using category setter if available\n            if hasattr(config_manager, \"set_category\"):\n                config_manager.set_category(\"personality\", config_updates[\"personality\"])\n            else:\n                # Fall back to individual settings\n                for key, value in config_updates[\"personality\"].items():\n                    full_key = f\"personality.{key}\"\n                    config_manager.set(full_key, value)\n            \n            return True\n            \n        except Exception as e:\n            if hasattr(self.core_system, \"log\"):\n                self.core_system.log(f\"Error applying personality to config: {e}\", \"ERROR\")\n            return False\n\n    def register_ui_hooks(self, personality_plugin):\n        \"\"\"\n        Register hooks for UI integration\n        \n        Args:\n            personality_plugin: Reference to personality plugin instance\n            \n        Returns:\n            True if hooks registered successfully, False otherwise\n        \"\"\"\n        try:\n            # Check if event system exists\n            if not hasattr(self.core_system, \"event_system\"):\n                if hasattr(self.core_system, \"plugin_manager\"):\n                    # Use plugin manager's event system if available\n                    plugin_manager = self.core_system.plugin_manager\n                    if hasattr(plugin_manager, \"trigger_event\"):\n                        # Register to necessary events\n                        plugin_manager.register_event_handler(\n                            \"personality_plugin\", \n                            \"chat_message_sent\", \n                            lambda **kwargs: self._on_message_sent(kwargs.get(\"message\", \"\"), personality_plugin)\n                        )\n                        \n                        plugin_manager.register_event_handler(\n                            \"personality_plugin\", \n                            \"ui_refresh\", \n                            lambda **kwargs: self._on_ui_refresh(personality_plugin)\n                        )\n                        \n                        return True\n                \n                # No event system available\n                return False\n                        \n            # Use core event system directly if available\n            event_system = self.core_system.event_system\n            \n            # Register handlers\n            event_system.register_handler(\n                \"chat_message_sent\", \n                lambda message: self._on_message_sent(message, personality_plugin)\n            )\n            \n            event_system.register_handler(\n                \"ui_refresh\",\n                lambda: self._on_ui_refresh(personality_plugin)\n            )\n            \n            return True\n            \n        except Exception as e:\n            if hasattr(self.core_system, \"log\"):\n                self.core_system.log(f\"Error registering UI hooks: {e}\", \"ERROR\")\n            return False\n\n    def _on_message_sent(self, message, personality_plugin):\n        \"\"\"\n        Handle chat message sent event\n        \n        Args:\n            message: Message text\n            personality_plugin: Reference to personality plugin instance\n        \"\"\"\n        try:\n            # Skip if auto-remember is disabled\n            if not personality_plugin.get_config().get(\"auto_remember\", True):\n                return\n                \n            # Register the current personality with memory\n            self.register_with_memory(personality_plugin)\n        except Exception as e:\n            if hasattr(self.core_system, \"log\"):\n                self.core_system.log(f\"Error in message handler: {e}\", \"ERROR\")\n\n    def _on_ui_refresh(self, personality_plugin):\n        \"\"\"\n        Handle UI refresh event\n        \n        Args:\n            personality_plugin: Reference to personality plugin instance\n        \"\"\"\n        try:\n            # Update any UI-related state\n            if hasattr(personality_plugin, \"refresh_ui\") and callable(personality_plugin.refresh_ui):\n                personality_plugin.refresh_ui()\n        except Exception as e:\n            if hasattr(self.core_system, \"log\"):\n                self.core_system.log(f\"Error in UI refresh handler: {e}\", \"ERROR\")\n\n    def create_message_modifier(self, personality_plugin):\n        \"\"\"\n        Create a message modifier function for the chat engine\n        \n        Args:\n            personality_plugin: Reference to personality plugin instance\n            \n        Returns:\n            Message modifier function\n        \"\"\"\n        def message_modifier(content, role):\n            \"\"\"\n            Modify messages based on active personality profile\n            \n            Args:\n                content: Message content\n                role: Message role (user/assistant)\n                \n            Returns:\n                Modified message content\n            \"\"\"\n            try:\n                # Only modify assistant messages\n                if role != \"assistant\":\n                    return content\n                    \n                # Get active profile\n                active_profile = personality_plugin.get_active_profile()\n                if not active_profile:\n                    return content\n                    \n                # Apply style transformations from helpers\n                from plugins.personality_plugin.core.helpers import apply_style_transforms\n                return apply_style_transforms(content, active_profile)\n                \n            except Exception as e:\n                # Log error but return original content\n                if hasattr(self.core_system, \"log\"):\n                    self.core_system.log(f\"Error in message modifier: {e}\", \"ERROR\")\n                return content\n                    \n        return message_modifier",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\system_diagnostic.py": "\"\"\"\nSystem Diagnostic Module for IrintAI Assistant\n\nThis module provides diagnostics for the system environment including:\n- Python version and dependencies\n- System resources (CPU, memory, disk)\n- Operating system information\n- Network connectivity\n\"\"\"\nimport os\nimport sys\nimport platform\nimport psutil\nimport socket\nimport subprocess\nimport pkg_resources\nimport importlib\nfrom urllib.request import urlopen\nfrom urllib.error import URLError\nimport threading\nimport time\n\nclass SystemDiagnostic:\n    \"\"\"Diagnostic tool for system environment checks\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the system diagnostic module\"\"\"\n        self.results = {}\n        \n    def log(self, message):\n        \"\"\"Simple print-based logging for diagnostics\"\"\"\n        print(f\"[SYSTEM DIAG] {message}\")\n        \n    def check_python_version(self):\n        \"\"\"Check Python version and compatibility\"\"\"\n        self.log(\"Checking Python version...\")\n        python_version = sys.version\n        version_info = sys.version_info\n        \n        # Check if Python version is compatible (expecting 3.8+)\n        min_version = (3, 8)\n        is_compatible = version_info >= min_version\n        \n        if is_compatible:\n            status = \"Success\"\n            message = f\"Python {python_version.split()[0]} is compatible (>= 3.8)\"\n        else:\n            status = \"Failure\"\n            message = f\"Python {python_version.split()[0]} is not compatible. Version 3.8 or higher is required.\"\n            \n        self.results[\"python_version\"] = {\n            \"status\": status,\n            \"message\": message,\n            \"version\": python_version.split()[0]\n        }\n        \n        self.log(f\"Python version check: {status}\")\n        return is_compatible\n        \n    def check_dependencies(self):\n        \"\"\"Check required Python dependencies\"\"\"\n        self.log(\"Checking Python dependencies...\")\n        \n        # Define required packages\n        required_packages = [\n            \"requests\", \"numpy\", \"tkinter\", \"json\", \"threading\",\n            \"psutil\", \"importlib\", \"os\", \"sys\", \"socket\", \"time\",\n            \"datetime\", \"platform\", \"subprocess\", \"urllib\"\n        ]\n        \n        results = {}\n        for package in required_packages:\n            try:\n                # Handle special cases\n                if package == \"tkinter\":\n                    import tkinter\n                    version = \"installed\"\n                elif package in [\"os\", \"sys\", \"json\", \"threading\", \"socket\", \"time\", \"datetime\", \"platform\", \"subprocess\", \"urllib\"]:\n                    # Standard library modules don't have a clear version\n                    importlib.import_module(package)\n                    version = \"standard library\"\n                else:\n                    # For pip-installed packages\n                    dist = pkg_resources.get_distribution(package)\n                    version = dist.version\n                    \n                results[package] = {\n                    \"status\": \"Success\",\n                    \"version\": version\n                }\n            except (pkg_resources.DistributionNotFound, ImportError):\n                results[package] = {\n                    \"status\": \"Failure\",\n                    \"message\": f\"Package {package} is not installed\"\n                }\n        \n        # Count successes and failures\n        success_count = sum(1 for pkg in results.values() if pkg[\"status\"] == \"Success\")\n        failure_count = len(results) - success_count\n        \n        if failure_count == 0:\n            self.results[\"dependencies\"] = {\n                \"status\": \"Success\",\n                \"message\": f\"All {len(required_packages)} required dependencies are installed\",\n                \"details\": results\n            }\n        else:\n            self.results[\"dependencies\"] = {\n                \"status\": \"Failure\",\n                \"message\": f\"{failure_count} required dependencies are missing\",\n                \"details\": results\n            }\n            \n        self.log(f\"Dependency check: {success_count} OK, {failure_count} missing\")\n        return failure_count == 0\n    \n    def check_system_resources(self):\n        \"\"\"Check system resources (CPU, memory, disk)\"\"\"\n        self.log(\"Checking system resources...\")\n        \n        # CPU information\n        cpu_count = psutil.cpu_count(logical=True)\n        cpu_usage = psutil.cpu_percent(interval=1)\n        \n        # Memory information (in GB)\n        memory = psutil.virtual_memory()\n        memory_total = memory.total / (1024 ** 3)\n        memory_available = memory.available / (1024 ** 3)\n        memory_used = memory.used / (1024 ** 3)\n        memory_percent = memory.percent\n        \n        # Disk information\n        disk = psutil.disk_usage('/')\n        disk_total = disk.total / (1024 ** 3)\n        disk_free = disk.free / (1024 ** 3)\n        disk_used = disk.used / (1024 ** 3)\n        disk_percent = disk.percent\n        \n        # Evaluate CPU, memory, disk status\n        cpu_status = \"Success\" if cpu_usage < 90 else \"Warning\"\n        memory_status = \"Success\"\n        if memory_percent > 95:\n            memory_status = \"Failure\"\n        elif memory_percent > 85:\n            memory_status = \"Warning\"\n        \n        disk_status = \"Success\"\n        if disk_percent > 95:\n            disk_status = \"Failure\"\n        elif disk_percent > 85:\n            disk_status = \"Warning\"\n            \n        # Determine overall resource status\n        statuses = [cpu_status, memory_status, disk_status]\n        if \"Failure\" in statuses:\n            overall_status = \"Failure\"\n        elif \"Warning\" in statuses:\n            overall_status = \"Warning\"\n        else:\n            overall_status = \"Success\"\n        \n        self.results[\"system_resources\"] = {\n            \"status\": overall_status,\n            \"message\": f\"CPU: {cpu_usage}% used, Memory: {memory_percent}% used, Disk: {disk_percent}% used\",\n            \"details\": {\n                \"cpu\": {\n                    \"status\": cpu_status,\n                    \"count\": cpu_count,\n                    \"usage_percent\": cpu_usage\n                },\n                \"memory\": {\n                    \"status\": memory_status,\n                    \"total_gb\": round(memory_total, 2),\n                    \"available_gb\": round(memory_available, 2),\n                    \"used_gb\": round(memory_used, 2),\n                    \"percent\": memory_percent\n                },\n                \"disk\": {\n                    \"status\": disk_status,\n                    \"total_gb\": round(disk_total, 2),\n                    \"free_gb\": round(disk_free, 2),\n                    \"used_gb\": round(disk_used, 2),\n                    \"percent\": disk_percent\n                }\n            }\n        }\n        \n        self.log(f\"System resources check: {overall_status}\")\n        return overall_status == \"Success\"\n    \n    def check_os_info(self):\n        \"\"\"Check operating system information\"\"\"\n        self.log(\"Checking OS information...\")\n        \n        os_name = platform.system()\n        os_release = platform.release()\n        os_version = platform.version()\n        architecture = platform.machine()\n        \n        self.results[\"os_info\"] = {\n            \"status\": \"Success\",\n            \"message\": f\"OS: {os_name} {os_release}, Architecture: {architecture}\",\n            \"details\": {\n                \"name\": os_name,\n                \"release\": os_release,\n                \"version\": os_version,\n                \"architecture\": architecture\n            }\n        }\n        \n        self.log(\"OS information check: Success\")\n        return True\n    \n    def check_network_connectivity(self):\n        \"\"\"Check network connectivity to key resources\"\"\"\n        self.log(\"Checking network connectivity...\")\n        \n        # Define key resources to check\n        resources = [\n            {\"name\": \"Google DNS\", \"host\": \"8.8.8.8\", \"port\": 53},\n            {\"name\": \"Internet\", \"url\": \"https://www.google.com\"},\n            {\"name\": \"Ollama Hub\", \"url\": \"https://ollama.ai\"},\n            {\"name\": \"GitHub\", \"url\": \"https://api.github.com\"}\n        ]\n        \n        results = {}\n        connection_failures = 0\n        \n        # Check socket connections\n        for resource in resources:\n            if \"host\" in resource and \"port\" in resource:\n                host = resource[\"host\"]\n                port = resource[\"port\"]\n                name = resource[\"name\"]\n                try:\n                    socket_timeout = 3\n                    socket.create_connection((host, port), timeout=socket_timeout)\n                    results[name] = {\n                        \"status\": \"Success\",\n                        \"message\": f\"Connected to {name} ({host}:{port})\"\n                    }\n                except (socket.timeout, socket.error) as e:\n                    connection_failures += 1\n                    results[name] = {\n                        \"status\": \"Failure\",\n                        \"message\": f\"Failed to connect to {name} ({host}:{port}): {str(e)}\"\n                    }\n            \n            # Check HTTP connections\n            elif \"url\" in resource:\n                url = resource[\"url\"]\n                name = resource[\"name\"]\n                try:\n                    urlopen(url, timeout=5)\n                    results[name] = {\n                        \"status\": \"Success\",\n                        \"message\": f\"Connected to {name} ({url})\"\n                    }\n                except URLError as e:\n                    connection_failures += 1\n                    results[name] = {\n                        \"status\": \"Failure\",\n                        \"message\": f\"Failed to connect to {name} ({url}): {str(e)}\"\n                    }\n        \n        # Determine overall network status\n        if connection_failures == 0:\n            status = \"Success\"\n            message = \"All network connectivity tests passed\"\n        elif connection_failures < len(resources):\n            status = \"Warning\"\n            message = f\"{connection_failures} of {len(resources)} network connectivity tests failed\"\n        else:\n            status = \"Failure\"\n            message = \"All network connectivity tests failed\"\n        \n        self.results[\"network_connectivity\"] = {\n            \"status\": status,\n            \"message\": message,\n            \"details\": results\n        }\n        \n        self.log(f\"Network connectivity check: {status} ({connection_failures} failures)\")\n        return status != \"Failure\"\n    def check_ollama_installation(self):\n        \"\"\"Check if Ollama is installed and get its version\"\"\"\n        self.log(\"Checking Ollama installation...\")\n        \n        try:\n            # Try to run the ollama command to get version\n            # Try multiple version command formats since different Ollama versions use different commands\n            commands = [\n                [\"ollama\", \"--version\"],  # New Ollama format\n                [\"ollama\", \"version\"],     # Old format\n                [\"ollama\", \"-v\"]           # Another common format\n            ]\n            \n            for cmd in commands:\n                try:\n                    process = subprocess.run(\n                        cmd,\n                        capture_output=True,\n                        text=True,\n                        encoding='utf-8',\n                        errors='replace',\n                        timeout=5\n                    )\n                except (subprocess.SubprocessError, FileNotFoundError):\n                    # Try the next command if this one fails\n                    continue\n            \n            if process.returncode == 0:\n                version = process.stdout.strip()\n                self.results[\"ollama_installation\"] = {\n                    \"status\": \"Success\",\n                    \"message\": f\"Ollama is installed: {version}\",\n                    \"version\": version\n                }\n                self.log(f\"Ollama installation check: Success ({version})\")\n                return True\n            else:\n                self.results[\"ollama_installation\"] = {\n                    \"status\": \"Failure\",\n                    \"message\": f\"Error checking Ollama version: {process.stderr.strip()}\"\n                }\n                self.log(\"Ollama installation check: Failure (command failed)\")\n                return False\n                \n        except FileNotFoundError:\n            self.results[\"ollama_installation\"] = {\n                \"status\": \"Failure\",\n                \"message\": \"Ollama is not installed or not in PATH\"\n            }\n            self.log(\"Ollama installation check: Failure (not installed)\")\n            return False\n        except subprocess.TimeoutExpired:\n            self.results[\"ollama_installation\"] = {\n                \"status\": \"Failure\",\n                \"message\": \"Timeout while checking Ollama version\"\n            }\n            self.log(\"Ollama installation check: Failure (timeout)\")\n            return False\n        except Exception as e:\n            self.results[\"ollama_installation\"] = {\n                \"status\": \"Failure\",\n                \"message\": f\"Error checking Ollama installation: {str(e)}\"\n            }\n            self.log(f\"Ollama installation check: Failure ({str(e)})\")\n            return False\n    \n    def run_all_checks(self):\n        \"\"\"Run all system diagnostic checks\"\"\"\n        self.log(\"Starting system diagnostics...\")\n        start_time = time.time()\n        \n        # Run checks\n        self.check_python_version()\n        self.check_dependencies()\n        self.check_system_resources()\n        self.check_os_info()\n        self.check_network_connectivity()\n        self.check_ollama_installation()\n        \n        elapsed_time = time.time() - start_time\n        self.log(f\"System diagnostics completed in {elapsed_time:.2f} seconds\")\n        return self.results\n",
  "D:\\AI\\IrintAI Assistant\\ui\\__init__.py": "\"\"\"\nUI module initialization for Irintai assistant\n\"\"\"\n# Import all UI components for easy access\nfrom ui.panels.chat_panel import ChatPanel\nfrom ui.panels.model_panel import ModelPanel\nfrom ui.panels.memory_panel import MemoryPanel\nfrom ui.panels.config_panel import ConfigPanel\nfrom ui.log_viewer import LogViewer\nfrom ui.panels.plugin_panel import PluginPanel\nfrom ui.main_window import MainWindow\nfrom ui.panels.resource_monitor_panel import ResourceMonitorPanel\nfrom plugins.plugin_config_panel import PluginConfigPanel\n\n__all__ = [\n    'MainWindow',\n    'ChatPanel',\n    'ModelPanel',\n    'MemoryPanel',\n    'ConfigPanel',\n    'LogViewer',\n    'PluginPanel',\n    'ResourceMonitorPanel',\n    'PluginConfigPanel']",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\diagnostic_suite.py": "\"\"\"\nIrintAI Assistant Diagnostic Suite\n\nThis module provides a comprehensive diagnostic suite for the IrintAI Assistant,\nallowing users to diagnose various components of the system.\n\"\"\"\nimport os\nimport sys\nimport json\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport threading\nimport time\nfrom datetime import datetime\n\n# Add project root to sys.path to allow importing core modules\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nif project_root not in sys.path:\n    sys.path.insert(0, project_root)\n\ntry:\n    from core.config_manager import ConfigManager\n    from utils.logger import IrintaiLogger\n    from diagnostics.ollama_panel_diagnostic import OllamaPanelDiagnostic\n    from diagnostics.system_diagnostic import SystemDiagnostic\n    from diagnostics.config_diagnostic import ConfigDiagnostic\n    from diagnostics.plugin_diagnostic import PluginDiagnostic\n    from diagnostics.memory_diagnostic import MemoryDiagnostic\n    from diagnostics.network_diagnostic import NetworkDiagnostic\nexcept ImportError as e:\n    print(f\"Error importing required modules: {e}\")\n    print(\"Please ensure the script is run from the project root or the PYTHONPATH is set correctly.\")\n    sys.exit(1)\n\n# Setup logger for diagnostics\nlogger = IrintaiLogger('diagnostic_suite', 'diagnostic_suite.log')\n\nclass DiagnosticSuite:\n    \"\"\"Main controller for the IrintAI Assistant diagnostic suite\"\"\"\n    def __init__(self, config_path='data/config.json'):\n        \"\"\"Initialize the diagnostic suite with configuration\"\"\"\n        self.config_path = config_path\n        self.config_manager = ConfigManager(config_path)\n        self.results = {}\n        self.diagnostic_modules = {}\n        self.initialize_modules()\n        \n    def initialize_modules(self):\n        \"\"\"Initialize all diagnostic modules\"\"\"\n        # Initialize each diagnostic module\n        try:\n            self.diagnostic_modules['system'] = SystemDiagnostic()\n            self.diagnostic_modules['config'] = ConfigDiagnostic(self.config_path)\n            self.diagnostic_modules['ollama'] = OllamaPanelDiagnostic(self.config_path)\n            self.diagnostic_modules['plugin'] = PluginDiagnostic(self.config_path)\n            self.diagnostic_modules['memory'] = MemoryDiagnostic(self.config_path)\n            self.diagnostic_modules['network'] = NetworkDiagnostic(self.config_path)\n            self.diagnostic_modules['network'] = NetworkDiagnostic(self.config_path)\n            logger.info(\"All diagnostic modules initialized successfully\")\n        except Exception as e:\n            logger.error(f\"Error initializing diagnostic modules: {e}\")\n            raise\n    \n    def run_all_diagnostics(self):\n        \"\"\"Run all diagnostic modules and collect results\"\"\"\n        logger.info(\"Starting comprehensive diagnostic suite\")\n        start_time = time.time()\n        \n        # Run each module's diagnostics\n        for module_name, module in self.diagnostic_modules.items():\n            try:\n                logger.info(f\"Running {module_name} diagnostics\")\n                module.run_all_checks()\n                self.results[module_name] = module.results\n            except Exception as e:\n                logger.error(f\"Error running {module_name} diagnostics: {e}\")\n                self.results[module_name] = {'error': str(e)}\n        \n        elapsed_time = time.time() - start_time\n        logger.info(f\"All diagnostics completed in {elapsed_time:.2f} seconds\")\n        return self.results\n    \n    def run_specific_diagnostic(self, module_name):\n        \"\"\"Run a specific diagnostic module\"\"\"\n        if module_name not in self.diagnostic_modules:\n            logger.error(f\"Diagnostic module {module_name} not found\")\n            return False\n        \n        try:\n            module = self.diagnostic_modules[module_name]\n            module.run_all_checks()\n            self.results[module_name] = module.results\n            return self.results[module_name]\n        except Exception as e:\n            logger.error(f\"Error running {module_name} diagnostics: {e}\")\n            self.results[module_name] = {'error': str(e)}\n            return self.results[module_name]\n    \n    def get_summary(self):\n        \"\"\"Get a summary of all diagnostic results\"\"\"\n        if not self.results:\n            return \"No diagnostics have been run yet.\"\n            \n        summary = {\n            \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"overall_status\": \"Success\",\n            \"module_status\": {},\n            \"error_count\": 0,\n            \"warning_count\": 0,\n            \"success_count\": 0\n        }\n        \n        for module_name, results in self.results.items():\n            module_status = \"Success\"\n            error_count = 0\n            warning_count = 0\n            success_count = 0\n            \n            for check, result in results.items():\n                if isinstance(result, dict) and 'status' in result:\n                    status = result['status'].lower()\n                    if status == 'failure':\n                        module_status = \"Failure\"\n                        error_count += 1\n                        summary[\"error_count\"] += 1\n                    elif status == 'warning':\n                        if module_status != \"Failure\":  # Don't downgrade from failure\n                            module_status = \"Warning\"\n                        warning_count += 1\n                        summary[\"warning_count\"] += 1\n                    elif status == 'success':\n                        success_count += 1\n                        summary[\"success_count\"] += 1\n            \n            summary[\"module_status\"][module_name] = {\n                \"status\": module_status,\n                \"error_count\": error_count,\n                \"warning_count\": warning_count,\n                \"success_count\": success_count\n            }\n            \n            # Update overall status\n            if module_status == \"Failure\" and summary[\"overall_status\"] != \"Failure\":\n                summary[\"overall_status\"] = \"Failure\"\n            elif module_status == \"Warning\" and summary[\"overall_status\"] == \"Success\":\n                summary[\"overall_status\"] = \"Warning\"\n        \n        return summary\n    \n    def export_results(self, filepath=None):\n        \"\"\"Export diagnostic results to a JSON file\"\"\"\n        if not filepath:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filepath = os.path.join(project_root, 'diagnostics', f'diagnostic_results_{timestamp}.json')\n        \n        try:\n            with open(filepath, 'w') as f:\n                json.dump({\n                    \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    \"summary\": self.get_summary(),\n                    \"detailed_results\": self.results\n                }, f, indent=2)\n            logger.info(f\"Diagnostic results exported to {filepath}\")\n            return filepath\n        except Exception as e:\n            logger.error(f\"Error exporting diagnostic results: {e}\")\n            return None\n    \n    def print_results(self):\n        \"\"\"Print diagnostic results to console\"\"\"\n        summary = self.get_summary()\n        if isinstance(summary, str):\n            print(summary)\n            return\n            \n        print(\"\\n===== IrintAI Assistant Diagnostic Results =====\")\n        print(f\"Timestamp: {summary['timestamp']}\")\n        print(f\"Overall Status: {summary['overall_status']}\")\n        print(f\"Success: {summary['success_count']} | Warnings: {summary['warning_count']} | Errors: {summary['error_count']}\")\n        print(\"=\" * 50)\n        \n        for module_name, results in self.results.items():\n            module_status = summary[\"module_status\"].get(module_name, {})\n            status_str = module_status.get(\"status\", \"Unknown\")\n            print(f\"\\n--- {module_name.upper()} DIAGNOSTICS: {status_str} ---\")\n            \n            for check, result in results.items():\n                if isinstance(result, dict) and 'status' in result:\n                    status = result['status']\n                    message = result.get('message', 'No details')\n                    print(f\"[{status.upper()}] {check.replace('_', ' ').title()}\")\n                    print(f\"  {message}\")\n            \n        print(\"\\n===== End of Diagnostic Report =====\")\n\n\nclass DiagnosticGUI:\n    \"\"\"GUI for the IrintAI Assistant Diagnostic Suite\"\"\"\n    \n    def __init__(self, master):\n        \"\"\"Initialize the diagnostic GUI\"\"\"\n        self.master = master\n        master.title(\"IrintAI Assistant Diagnostic Suite\")\n        master.geometry(\"800x600\")\n        \n        # Initialize diagnostic suite\n        self.diagnostic_suite = DiagnosticSuite()\n        \n        # Set up the main notebook\n        self.notebook = ttk.Notebook(master)\n        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)\n          # Create main tabs\n        self.overview_frame = ttk.Frame(self.notebook)\n        self.system_frame = ttk.Frame(self.notebook)\n        self.config_frame = ttk.Frame(self.notebook)\n        self.ollama_frame = ttk.Frame(self.notebook)\n        self.plugin_frame = ttk.Frame(self.notebook)\n        self.memory_frame = ttk.Frame(self.notebook)\n        self.network_frame = ttk.Frame(self.notebook)\n        \n        # Add tabs to notebook\n        self.notebook.add(self.overview_frame, text=\"Overview\")\n        self.notebook.add(self.system_frame, text=\"System\")\n        self.notebook.add(self.config_frame, text=\"Configuration\")\n        self.notebook.add(self.ollama_frame, text=\"Ollama\")\n        self.notebook.add(self.plugin_frame, text=\"Plugins\")\n        self.notebook.add(self.memory_frame, text=\"Memory\")\n        self.notebook.add(self.network_frame, text=\"Network\")\n        \n        # Setup overview tab\n        self.setup_overview_tab()\n          # Setup diagnostic module tabs\n        self.setup_system_tab()\n        self.setup_config_tab()\n        self.setup_ollama_tab()\n        self.setup_plugin_tab()\n        self.setup_memory_tab()\n        self.setup_network_tab()\n    \n    def setup_overview_tab(self):\n        \"\"\"Set up the overview tab\"\"\"\n        # Top frame for controls\n        control_frame = ttk.Frame(self.overview_frame)\n        control_frame.pack(fill='x', pady=10)\n        \n        # Buttons\n        run_all_button = ttk.Button(control_frame, text=\"Run All Diagnostics\", \n                                   command=self.run_all_diagnostics)\n        run_all_button.pack(side='left', padx=5)\n        \n        export_button = ttk.Button(control_frame, text=\"Export Results\", \n                                  command=self.export_results)\n        export_button.pack(side='left', padx=5)\n        \n        # Status frame\n        status_frame = ttk.LabelFrame(self.overview_frame, text=\"System Status\")\n        status_frame.pack(fill='x', padx=10, pady=5)\n        \n        # Status indicators using treeview for better formatting\n        self.status_tree = ttk.Treeview(status_frame, columns=(\"Module\", \"Status\", \"Success\", \"Warnings\", \"Errors\"),\n                                       show=\"headings\", height=6)\n        self.status_tree.heading(\"Module\", text=\"Module\")\n        self.status_tree.heading(\"Status\", text=\"Status\")\n        self.status_tree.heading(\"Success\", text=\"Success\")\n        self.status_tree.heading(\"Warnings\", text=\"Warnings\")\n        self.status_tree.heading(\"Errors\", text=\"Errors\")\n        \n        self.status_tree.column(\"Module\", width=150)\n        self.status_tree.column(\"Status\", width=100)\n        self.status_tree.column(\"Success\", width=80, anchor='center')\n        self.status_tree.column(\"Warnings\", width=80, anchor='center')\n        self.status_tree.column(\"Errors\", width=80, anchor='center')\n        \n        self.status_tree.pack(fill='both', expand=True, padx=5, pady=5)\n        \n        # Results text area\n        results_frame = ttk.LabelFrame(self.overview_frame, text=\"Summary\")\n        results_frame.pack(fill='both', expand=True, padx=10, pady=5)\n        \n        self.summary_text = tk.Text(results_frame, wrap='word', height=10)\n        self.summary_text.pack(fill='both', expand=True, padx=5, pady=5)\n        \n    def setup_system_tab(self):\n        \"\"\"Set up the system diagnostics tab\"\"\"\n        # Controls\n        control_frame = ttk.Frame(self.system_frame)\n        control_frame.pack(fill='x', pady=10)\n        \n        run_button = ttk.Button(control_frame, text=\"Run System Diagnostics\", \n                               command=lambda: self.run_specific_diagnostic('system'))\n        run_button.pack(side='left', padx=5)\n        \n        # Results treeview\n        self.system_tree = ttk.Treeview(self.system_frame, columns=(\"Check\", \"Status\", \"Message\"),\n                                       show=\"headings\")\n        self.system_tree.heading(\"Check\", text=\"Check\")\n        self.system_tree.heading(\"Status\", text=\"Status\")\n        self.system_tree.heading(\"Message\", text=\"Message\")\n        \n        self.system_tree.column(\"Check\", width=150)\n        self.system_tree.column(\"Status\", width=80)\n        self.system_tree.column(\"Message\", width=400)\n        \n        self.system_tree.pack(fill='both', expand=True, padx=10, pady=5)\n    \n    def setup_config_tab(self):\n        \"\"\"Set up the configuration diagnostics tab\"\"\"\n        # Controls\n        control_frame = ttk.Frame(self.config_frame)\n        control_frame.pack(fill='x', pady=10)\n        \n        run_button = ttk.Button(control_frame, text=\"Run Config Diagnostics\", \n                               command=lambda: self.run_specific_diagnostic('config'))\n        run_button.pack(side='left', padx=5)\n        \n        # Results treeview\n        self.config_tree = ttk.Treeview(self.config_frame, columns=(\"Check\", \"Status\", \"Message\"),\n                                       show=\"headings\")\n        self.config_tree.heading(\"Check\", text=\"Check\")\n        self.config_tree.heading(\"Status\", text=\"Status\")\n        self.config_tree.heading(\"Message\", text=\"Message\")\n        \n        self.config_tree.column(\"Check\", width=150)\n        self.config_tree.column(\"Status\", width=80)\n        self.config_tree.column(\"Message\", width=400)\n        \n        self.config_tree.pack(fill='both', expand=True, padx=10, pady=5)\n    \n    def setup_ollama_tab(self):\n        \"\"\"Set up the Ollama diagnostics tab\"\"\"\n        # Controls\n        control_frame = ttk.Frame(self.ollama_frame)\n        control_frame.pack(fill='x', pady=10)\n        \n        run_button = ttk.Button(control_frame, text=\"Run Ollama Diagnostics\", \n                               command=lambda: self.run_specific_diagnostic('ollama'))\n        run_button.pack(side='left', padx=5)\n        \n        # Results treeview\n        self.ollama_tree = ttk.Treeview(self.ollama_frame, columns=(\"Check\", \"Status\", \"Message\"),\n                                       show=\"headings\")\n        self.ollama_tree.heading(\"Check\", text=\"Check\")\n        self.ollama_tree.heading(\"Status\", text=\"Status\")\n        self.ollama_tree.heading(\"Message\", text=\"Message\")\n        \n        self.ollama_tree.column(\"Check\", width=150)\n        self.ollama_tree.column(\"Status\", width=80)\n        self.ollama_tree.column(\"Message\", width=400)\n        \n        self.ollama_tree.pack(fill='both', expand=True, padx=10, pady=5)\n    \n    def setup_plugin_tab(self):\n        \"\"\"Set up the plugin diagnostics tab\"\"\"\n        # Controls\n        control_frame = ttk.Frame(self.plugin_frame)\n        control_frame.pack(fill='x', pady=10)\n        \n        run_button = ttk.Button(control_frame, text=\"Run Plugin Diagnostics\", \n                               command=lambda: self.run_specific_diagnostic('plugin'))\n        run_button.pack(side='left', padx=5)\n        \n        # Results treeview\n        self.plugin_tree = ttk.Treeview(self.plugin_frame, columns=(\"Check\", \"Status\", \"Message\"),\n                                       show=\"headings\")\n        self.plugin_tree.heading(\"Check\", text=\"Check\")\n        self.plugin_tree.heading(\"Status\", text=\"Status\")\n        self.plugin_tree.heading(\"Message\", text=\"Message\")\n        \n        self.plugin_tree.column(\"Check\", width=150)\n        self.plugin_tree.column(\"Status\", width=80)\n        self.plugin_tree.column(\"Message\", width=400)\n        \n        self.plugin_tree.pack(fill='both', expand=True, padx=10, pady=5)\n    \n    def setup_memory_tab(self):\n        \"\"\"Set up the memory diagnostics tab\"\"\"\n        # Controls\n        control_frame = ttk.Frame(self.memory_frame)\n        control_frame.pack(fill='x', pady=10)\n        \n        run_button = ttk.Button(control_frame, text=\"Run Memory Diagnostics\", \n                               command=lambda: self.run_specific_diagnostic('memory'))\n        run_button.pack(side='left', padx=5)\n        \n        # Results treeview\n        self.memory_tree = ttk.Treeview(self.memory_frame, columns=(\"Check\", \"Status\", \"Message\"),\n                                       show=\"headings\")\n        self.memory_tree.heading(\"Check\", text=\"Check\")\n        self.memory_tree.heading(\"Status\", text=\"Status\")\n        self.memory_tree.heading(\"Message\", text=\"Message\")\n        \n        self.memory_tree.column(\"Check\", width=150)\n        self.memory_tree.column(\"Status\", width=80)\n        self.memory_tree.column(\"Message\", width=400)\n        \n        self.memory_tree.pack(fill='both', expand=True, padx=10, pady=5)\n    \n    def setup_network_tab(self):\n        \"\"\"Set up the network diagnostics tab\"\"\"\n        # Controls\n        control_frame = ttk.Frame(self.network_frame)\n        control_frame.pack(fill='x', pady=10)\n        \n        run_button = ttk.Button(control_frame, text=\"Run Network Diagnostics\", \n                               command=lambda: self.run_specific_diagnostic('network'))\n        run_button.pack(side='left', padx=5)\n        \n        # Results treeview\n        self.network_tree = ttk.Treeview(self.network_frame, columns=(\"Check\", \"Status\", \"Message\"),\n                                       show=\"headings\")\n        self.network_tree.heading(\"Check\", text=\"Check\")\n        self.network_tree.heading(\"Status\", text=\"Status\")\n        self.network_tree.heading(\"Message\", text=\"Message\")\n        \n        self.network_tree.column(\"Check\", width=150)\n        self.network_tree.column(\"Status\", width=80)\n        self.network_tree.column(\"Message\", width=400)\n        \n        self.network_tree.pack(fill='both', expand=True, padx=10, pady=5)\n    \n    def run_all_diagnostics(self):\n        \"\"\"Run all diagnostics and update UI\"\"\"\n        # Disable all buttons during diagnostic run\n        for child in self.master.winfo_children():\n            if isinstance(child, ttk.Button):\n                child.configure(state='disabled')\n                \n        # Update status\n        self.summary_text.delete(1.0, tk.END)\n        self.summary_text.insert(tk.END, \"Running diagnostics...\\n\")\n        \n        # Run diagnostics in a separate thread to avoid freezing UI\n        threading.Thread(target=self._run_all_diagnostics, daemon=True).start()\n    \n    def _run_all_diagnostics(self):\n        \"\"\"Thread target for running all diagnostics\"\"\"\n        try:\n            # Clear previous results\n            self.status_tree.delete(*self.status_tree.get_children())\n            \n            # Run diagnostics\n            self.diagnostic_suite.run_all_diagnostics()\n            \n            # Update UI on the main thread\n            self.master.after(0, self._update_ui_after_diagnostics)\n        except Exception as e:\n            # Handle exceptions\n            self.master.after(0, lambda: messagebox.showerror(\"Error\", f\"An error occurred: {e}\"))\n            # Re-enable buttons\n            self.master.after(0, self._enable_buttons)\n    \n    def _update_ui_after_diagnostics(self):\n        \"\"\"Update UI with diagnostic results\"\"\"\n        # Get summary\n        summary = self.diagnostic_suite.get_summary()\n        \n        # Update summary text\n        self.summary_text.delete(1.0, tk.END)\n        self.summary_text.insert(tk.END, f\"Diagnostics completed at {summary['timestamp']}\\n\")\n        self.summary_text.insert(tk.END, f\"Overall Status: {summary['overall_status']}\\n\")\n        self.summary_text.insert(tk.END, f\"Success: {summary['success_count']} | Warnings: {summary['warning_count']} | Errors: {summary['error_count']}\\n\\n\")\n        \n        # Update status tree\n        self.status_tree.delete(*self.status_tree.get_children())\n        for module_name, module_status in summary[\"module_status\"].items():\n            status = module_status[\"status\"]\n            success = module_status[\"success_count\"]\n            warnings = module_status[\"warning_count\"]\n            errors = module_status[\"error_count\"]\n            \n            tag = \"normal\"\n            if status == \"Failure\":\n                tag = \"error\"\n            elif status == \"Warning\":\n                tag = \"warning\"\n                \n            self.status_tree.insert(\"\", \"end\", values=(module_name, status, success, warnings, errors), tags=(tag,))\n        \n        # Setup tags for coloring\n        self.status_tree.tag_configure(\"error\", background=\"#FFCCCC\")\n        self.status_tree.tag_configure(\"warning\", background=\"#FFFFCC\")\n          # Update module-specific tabs\n        self._update_module_tab(self.system_tree, 'system')\n        self._update_module_tab(self.config_tree, 'config')\n        self._update_module_tab(self.ollama_tree, 'ollama')\n        self._update_module_tab(self.plugin_tree, 'plugin')\n        self._update_module_tab(self.memory_tree, 'memory')\n        self._update_module_tab(self.network_tree, 'network')\n        \n        # Re-enable buttons\n        self._enable_buttons()\n    \n    def _update_module_tab(self, tree, module_name):\n        \"\"\"Update a specific module's tab with results\"\"\"\n        # Clear existing results\n        tree.delete(*tree.get_children())\n        \n        # Get results for this module\n        results = self.diagnostic_suite.results.get(module_name, {})\n        \n        # Add results to tree\n        for check, result in results.items():\n            if isinstance(result, dict) and 'status' in result:\n                status = result['status']\n                message = result.get('message', 'No details')\n                \n                tag = \"normal\"\n                if status.lower() == \"failure\":\n                    tag = \"error\"\n                elif status.lower() == \"warning\":\n                    tag = \"warning\"\n                \n                tree.insert(\"\", \"end\", values=(check.replace('_', ' ').title(), status, message), tags=(tag,))\n        \n        # Setup tags for coloring\n        tree.tag_configure(\"error\", background=\"#FFCCCC\")\n        tree.tag_configure(\"warning\", background=\"#FFFFCC\")\n    \n    def _enable_buttons(self):\n        \"\"\"Re-enable all buttons\"\"\"\n        for child in self.master.winfo_children():\n            if isinstance(child, ttk.Button):\n                child.configure(state='normal')\n    def run_specific_diagnostic(self, module_name):\n        \"\"\"Run a specific diagnostic module and update its tab\"\"\"\n        # Get the corresponding treeview\n        tree_map = {\n            'system': self.system_tree,\n            'config': self.config_tree,\n            'ollama': self.ollama_tree,\n            'plugin': self.plugin_tree,\n            'memory': self.memory_tree,\n            'network': self.network_tree\n        }\n        \n        tree = tree_map.get(module_name)\n        if not tree:\n            messagebox.showerror(\"Error\", f\"Unknown module: {module_name}\")\n            return\n        \n        # Clear tree\n        tree.delete(*tree.get_children())\n        \n        # Disable buttons\n        for child in self.master.winfo_children():\n            if isinstance(child, ttk.Button):\n                child.configure(state='disabled')\n        \n        # Run diagnostic in thread\n        threading.Thread(\n            target=self._run_specific_diagnostic,\n            args=(module_name, tree),\n            daemon=True\n        ).start()\n    \n    def _run_specific_diagnostic(self, module_name, tree):\n        \"\"\"Thread target for running a specific diagnostic\"\"\"\n        try:\n            # Run diagnostic\n            results = self.diagnostic_suite.run_specific_diagnostic(module_name)\n            \n            # Update UI on main thread\n            self.master.after(0, lambda: self._update_specific_tab(module_name, tree, results))\n        except Exception as e:\n            # Handle exceptions\n            self.master.after(0, lambda: messagebox.showerror(\"Error\", f\"An error occurred: {e}\"))\n        finally:\n            # Re-enable buttons\n            self.master.after(0, self._enable_buttons)\n    \n    def _update_specific_tab(self, module_name, tree, results):\n        \"\"\"Update a specific tab with diagnostic results\"\"\"\n        # Clear tree\n        tree.delete(*tree.get_children())\n        \n        # Add results\n        for check, result in results.items():\n            if isinstance(result, dict) and 'status' in result:\n                status = result['status']\n                message = result.get('message', 'No details')\n                \n                tag = \"normal\"\n                if status.lower() == \"failure\":\n                    tag = \"error\"\n                elif status.lower() == \"warning\":\n                    tag = \"warning\"\n                \n                tree.insert(\"\", \"end\", values=(check.replace('_', ' ').title(), status, message), tags=(tag,))\n        \n        # Setup tags for coloring\n        tree.tag_configure(\"error\", background=\"#FFCCCC\")\n        tree.tag_configure(\"warning\", background=\"#FFFFCC\")\n        \n        # Also update overview if it exists\n        if hasattr(self, 'status_tree') and module_name in self.diagnostic_suite.results:\n            self._update_overview_for_module(module_name)\n    \n    def _update_overview_for_module(self, module_name):\n        \"\"\"Update overview tab for a specific module\"\"\"\n        # Get summary\n        summary = self.diagnostic_suite.get_summary()\n        \n        # Update module in status tree\n        for item in self.status_tree.get_children():\n            values = self.status_tree.item(item, 'values')\n            if values and values[0] == module_name:\n                self.status_tree.delete(item)\n                break\n        \n        # Add updated module status\n        module_status = summary[\"module_status\"].get(module_name, {})\n        status = module_status.get(\"status\", \"Unknown\")\n        success = module_status.get(\"success_count\", 0)\n        warnings = module_status.get(\"warning_count\", 0)\n        errors = module_status.get(\"error_count\", 0)\n        \n        tag = \"normal\"\n        if status == \"Failure\":\n            tag = \"error\"\n        elif status == \"Warning\":\n            tag = \"warning\"\n            \n        self.status_tree.insert(\"\", \"end\", values=(module_name, status, success, warnings, errors), tags=(tag,))\n    \n    def export_results(self):\n        \"\"\"Export diagnostic results to file\"\"\"\n        if not self.diagnostic_suite.results:\n            messagebox.showinfo(\"Info\", \"No diagnostic results to export. Please run diagnostics first.\")\n            return\n            \n        filepath = self.diagnostic_suite.export_results()\n        if filepath:\n            messagebox.showinfo(\"Success\", f\"Diagnostic results exported to:\\n{filepath}\")\n        else:\n            messagebox.showerror(\"Error\", \"Failed to export diagnostic results\")\n\n\ndef run_diagnostics_cli():\n    \"\"\"Run diagnostics in command line mode\"\"\"\n    print(\"=== IrintAI Assistant Diagnostic Suite ===\")\n    config_file = os.path.join(project_root, 'data', 'config.json')\n    \n    # Create and run diagnostics\n    suite = DiagnosticSuite(config_path=config_file)\n    suite.run_all_diagnostics()\n    suite.print_results()\n    \n    # Export results\n    filepath = suite.export_results()\n    if filepath:\n        print(f\"\\nDiagnostic results exported to: {filepath}\")\n    \n    return 0\n\ndef run_diagnostics_gui():\n    \"\"\"Run diagnostics in GUI mode\"\"\"\n    root = tk.Tk()\n    app = DiagnosticGUI(root)\n    root.mainloop()\n    return 0\n\nif __name__ == \"__main__\":\n    # Check if GUI mode requested\n    import argparse\n    parser = argparse.ArgumentParser(description=\"IrintAI Assistant Diagnostic Suite\")\n    parser.add_argument('--gui', action='store_true', help='Run in GUI mode')\n    parser.add_argument('--cli', action='store_true', help='Run in CLI mode')\n    args = parser.parse_args()\n    \n    # Default to GUI mode if no arguments provided\n    if not args.cli and (args.gui or len(sys.argv) == 1):\n        sys.exit(run_diagnostics_gui())\n    else:\n        sys.exit(run_diagnostics_cli())\n",
  "D:\\AI\\IrintAI Assistant\\ui\\log_viewer.py": "\"\"\"\nLog viewer UI component for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, filedialog, messagebox, scrolledtext\nimport time\nimport threading\nfrom typing import Optional, Callable, List, Dict, Any\n\nclass LogViewer:\n    \"\"\"Enhanced log viewer with filtering and auto-refresh capabilities\"\"\"\n    \n    def __init__(self, parent, logger):\n        \"\"\"\n        Initialize the log viewer\n        \n        Args:\n            parent: Parent widget\n            logger: IrintaiLogger instance\n        \"\"\"\n        self.parent = parent\n        self.logger = logger\n        \n        # Create top-level window\n        self.window = tk.Toplevel(parent)\n        self.window.title(\"Irintai Log Viewer\")\n        self.window.geometry(\"800x600\")\n        self.window.minsize(600, 400)\n        \n        # Set up auto-refresh\n        self.auto_refresh = tk.BooleanVar(value=True)\n        self.refresh_interval = 2000  # 2 seconds\n        \n        # Make log function available to plugins\n        self.log = logger.log if hasattr(logger, 'log') else print\n        \n        # Initialize UI components\n        self.initialize_ui()\n        \n        # Initial log display\n        self.update_log_display()\n        \n        # Start auto-refresh if enabled\n        self.schedule_refresh()\n        \n        # Handle window close\n        self.window.protocol(\"WM_DELETE_WINDOW\", self.on_close)\n        \n    def initialize_ui(self):\n        \"\"\"Initialize the UI components\"\"\"\n        # Create control frame\n        self.create_control_frame()\n        \n        # Create log display\n        self.create_log_display()\n        \n        # Create status bar\n        self.create_status_bar()\n        \n        # Initialize plugin extensions\n        self.initialize_plugin_extensions()\n\n    def initialize_plugin_extensions(self):\n        \"\"\"Initialize plugin extensions for the log viewer\"\"\"\n        # Dictionary for plugin components\n        self.plugin_log_processors = {}\n        self.plugin_log_filters = {}\n        self.plugin_log_exporters = {}\n        \n        # Menu for plugin filters (will be added to the UI)\n        self.filter_menu = None\n        \n        # Register for plugin events if plugin manager is available\n        if hasattr(self.parent, \"plugin_manager\"):\n            plugin_manager = self.parent.plugin_manager\n            \n            # Register for plugin events\n            plugin_manager.register_event_handler(\"log_viewer\", \"plugin_activated\", \n                                                 self.on_plugin_activated)\n            plugin_manager.register_event_handler(\"log_viewer\", \"plugin_deactivated\", \n                                                 self.on_plugin_deactivated)\n                                                 \n            # Get all active plugins and register their log extensions\n            active_plugins = plugin_manager.get_active_plugins()\n            for plugin_id, plugin in active_plugins.items():\n                self.register_plugin_extensions(plugin_id, plugin)\n                \n        # Create plugin filter menu button\n        self.add_plugin_filter_menu()\n        \n    def create_control_frame(self):\n        \"\"\"Create the control frame with filters and buttons\"\"\"\n        control_frame = ttk.Frame(self.window)\n        control_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Add auto-refresh toggle\n        ttk.Checkbutton(\n            control_frame, \n            text=\"Auto-refresh\", \n            variable=self.auto_refresh\n        ).pack(side=tk.LEFT)\n        \n        # Add refresh interval options\n        ttk.Label(control_frame, text=\"Interval:\").pack(side=tk.LEFT, padx=(10, 0))\n        \n        self.interval_var = tk.StringVar(value=\"2s\")\n        interval_dropdown = ttk.Combobox(\n            control_frame,\n            textvariable=self.interval_var,\n            values=[\"1s\", \"2s\", \"5s\", \"10s\"],\n            state=\"readonly\",\n            width=5\n        )\n        interval_dropdown.pack(side=tk.LEFT, padx=5)\n        interval_dropdown.bind(\"<<ComboboxSelected>>\", self.on_interval_changed)\n        \n        # Add filter options\n        ttk.Label(control_frame, text=\"Filter:\").pack(side=tk.LEFT, padx=(20, 5))\n        \n        self.filter_var = tk.StringVar(value=\"All\")\n        filter_dropdown = ttk.Combobox(\n            control_frame,\n            textvariable=self.filter_var,\n            values=[\"All\", \"Error\", \"Warning\", \"Info\", \"User\", \"Assistant\", \"Model\", \"System\"],\n            state=\"readonly\",\n            width=10\n        )\n        filter_dropdown.pack(side=tk.LEFT, padx=5)\n        filter_dropdown.bind(\"<<ComboboxSelected>>\", self.update_log_display)\n        \n        # Search input\n        ttk.Label(control_frame, text=\"Search:\").pack(side=tk.LEFT, padx=(20, 5))\n        \n        self.search_var = tk.StringVar()\n        search_entry = ttk.Entry(\n            control_frame,\n            textvariable=self.search_var,\n            width=15\n        )\n        search_entry.pack(side=tk.LEFT, padx=5)\n        search_entry.bind(\"<Return>\", self.update_log_display)\n        \n        ttk.Button(\n            control_frame,\n            text=\"Search\",\n            command=self.update_log_display\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Add buttons on the right\n        ttk.Button(\n            control_frame, \n            text=\"Refresh Now\", \n            command=self.update_log_display\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        ttk.Button(\n            control_frame, \n            text=\"Clear Viewer\", \n            command=self.clear_display\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        ttk.Button(\n            control_frame, \n            text=\"Save Logs\", \n            command=self.save_logs\n        ).pack(side=tk.RIGHT, padx=5)\n        \n    def create_log_display(self):\n        \"\"\"Create the log display area\"\"\"\n        # Create scrolled text widget\n        self.log_display = scrolledtext.ScrolledText(\n            self.window, \n            wrap=tk.WORD, \n            font=(\"Courier New\", 10)\n        )\n        self.log_display.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Configure text tags for different message types\n        self.log_display.tag_configure(\"error\", foreground=\"red\")\n        self.log_display.tag_configure(\"warning\", foreground=\"orange\")\n        self.log_display.tag_configure(\"info\", foreground=\"blue\")\n        self.log_display.tag_configure(\"http\", foreground=\"purple\")\n        self.log_display.tag_configure(\"model\", foreground=\"green\")\n        self.log_display.tag_configure(\"assistant\", foreground=\"purple\")\n        self.log_display.tag_configure(\"user\", foreground=\"darkblue\")\n        self.log_display.tag_configure(\"system\", foreground=\"darkgreen\")\n        self.log_display.tag_configure(\"timestamp\", foreground=\"gray\")\n        self.log_display.tag_configure(\"highlight\", background=\"yellow\")\n        \n    def create_status_bar(self):\n        \"\"\"Create the status bar\"\"\"\n        self.status_var = tk.StringVar(value=\"Log Viewer Ready\")\n        \n        self.status_bar = ttk.Label(\n            self.window, \n            textvariable=self.status_var, \n            relief=tk.SUNKEN, \n            anchor=tk.W\n        )\n        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)\n        \n    def update_log_display(self, event=None):\n        \"\"\"Update the log display with filtered content\"\"\"\n        try:\n            # Save current position\n            current_pos = self.log_display.yview()\n            \n            # Get filters\n            filter_type = self.filter_var.get()\n            plugin_filter = self.plugin_filter_var.get() if hasattr(self, \"plugin_filter_var\") else \"None\"\n            search_text = self.search_var.get().lower()\n            \n            # Get log content\n            if hasattr(self.logger, 'get_console_lines'):\n                # Use logger's filtering if available\n                if filter_type == \"All\":\n                    lines = self.logger.get_console_lines()\n                else:\n                    lines = self.logger.get_console_lines(filter_type)\n            else:\n                # Fallback to reading the log file\n                try:\n                    with open(self.logger.latest_log_file, \"r\", encoding=\"utf-8\", errors='replace') as log_file:\n                        lines = log_file.readlines()\n                except Exception as e:\n                    lines = [f\"Error reading log file: {e}\"]\n            \n            # Apply plugin filter if selected\n            if plugin_filter and plugin_filter != \"None\" and plugin_filter in self.plugin_log_filters:\n                filter_func = self.plugin_log_filters[plugin_filter]\n                try:\n                    lines = filter_func(lines)\n                except Exception as e:\n                    lines.append(f\"Error applying plugin filter: {e}\")\n            \n            # Apply search filter if needed\n            if search_text:\n                filtered_lines = []\n                for line in lines:\n                    if search_text in line.lower():\n                        filtered_lines.append(line)\n                lines = filtered_lines\n            \n            # Apply plugin processors to the lines\n            processed_lines = []\n            for line in lines:\n                # Apply each processor\n                current_line = line\n                for processor_id, processor_func in self.plugin_log_processors.items():\n                    try:\n                        result = processor_func(current_line)\n                        if result:  # Only update if processor returned a result\n                            current_line = result\n                    except Exception as e:\n                        # Skip failed processors but don't break the chain\n                        continue\n                \n                processed_lines.append(current_line)\n            \n            # Use processed lines\n            lines = processed_lines\n            \n            # Clear and insert new content\n            self.log_display.delete(1.0, tk.END)\n            \n            # Apply tags while inserting\n            for line in lines:\n                if not isinstance(line, str):\n                    line = str(line)\n                    \n                if \"[Error]\" in line or \"ERROR\" in line:\n                    self.log_display.insert(tk.END, line, \"error\")\n                elif \"[Warning]\" in line or \"WARNING\" in line:\n                    self.log_display.insert(tk.END, line, \"warning\")\n                elif \"[INFO]\" in line or \"[Info]\" in line:\n                    self.log_display.insert(tk.END, line, \"info\")\n                elif \"[HTTP]\" in line:\n                    self.log_display.insert(tk.END, line, \"http\")\n                elif \"[Model\" in line or \"[Starting Model]\" in line or \"[Stopped Model]\" in line:\n                    self.log_display.insert(tk.END, line, \"model\")\n                elif \"[Assistant]\" in line or \"[Irintai]\" in line:\n                    self.log_display.insert(tk.END, line, \"assistant\")\n                elif line.startswith(\"> \") or \"[User]\" in line:\n                    self.log_display.insert(tk.END, line, \"user\")\n                elif \"[System]\" in line:\n                    self.log_display.insert(tk.END, line, \"system\")\n                else:\n                    self.log_display.insert(tk.END, line)\n                \n                # Highlight search text if present\n                if search_text:\n                    self.highlight_text(search_text)\n            \n            # Update status\n            self.status_var.set(f\"Log updated: {time.strftime('%H:%M:%S')} - {len(lines)} lines\")\n            \n            # Restore view position if not at the end\n            if current_pos[1] < 1.0:\n                self.log_display.yview_moveto(current_pos[0])\n            else:\n                self.log_display.see(tk.END)  # Scroll to end if we were at the end\n                \n        except Exception as e:\n            self.status_var.set(f\"Error updating logs: {e}\")\n            \n    def highlight_text(self, text):\n        \"\"\"\n        Highlight all occurrences of text in the log display\n        \n        Args:\n            text: Text to highlight\n        \"\"\"\n        if not text:\n            return\n            \n        # Case insensitive search\n        text = text.lower()\n        \n        # Find all occurrences and highlight them\n        start_pos = '1.0'\n        while True:\n            # Find next occurrence\n            start_pos = self.log_display.search(\n                text, \n                start_pos, \n                tk.END, \n                nocase=True\n            )\n            \n            if not start_pos:\n                break\n                \n            # Calculate end position\n            end_pos = f\"{start_pos}+{len(text)}c\"\n            \n            # Add highlight tag\n            self.log_display.tag_add(\"highlight\", start_pos, end_pos)\n            \n            # Move to next position\n            start_pos = end_pos\n        \n    def clear_display(self):\n        \"\"\"Clear the log display\"\"\"\n        self.log_display.delete(1.0, tk.END)\n        self.status_var.set(\"Display cleared\")\n        \n    def save_logs(self):\n        \"\"\"Save displayed logs to a file\"\"\"\n        # Generate default filename\n        timestamp = time.strftime(\"%Y%m%d_%H%M%S\")\n        default_filename = f\"irintai_logs_{timestamp}.txt\"\n        \n        # Open save dialog\n        filename = filedialog.asksaveasfilename(\n            defaultextension=\".txt\",\n            filetypes=[(\"Text Files\", \"*.txt\"), (\"All Files\", \"*.*\")],\n            initialfile=default_filename\n        )\n        \n        if not filename:\n            return\n            \n        try:\n            # Get display content\n            content = self.log_display.get(1.0, tk.END)\n            \n            # Save to file\n            with open(filename, \"w\", encoding=\"utf-8\") as f:\n                f.write(f\"=== Irintai Log Export - {time.strftime('%Y-%m-%d %H:%M:%S')} ===\\n\\n\")\n                f.write(content)\n                \n            self.status_var.set(f\"Logs saved to {filename}\")\n        except Exception as e:\n            self.status_var.set(f\"Error saving logs: {e}\")\n            messagebox.showerror(\"Error\", f\"Failed to save logs: {e}\")\n            \n    def on_interval_changed(self, event):\n        \"\"\"Handle refresh interval changes\"\"\"\n        interval = self.interval_var.get()\n        \n        # Convert to milliseconds\n        if interval == \"1s\":\n            self.refresh_interval = 1000\n        elif interval == \"2s\":\n            self.refresh_interval = 2000\n        elif interval == \"5s\":\n            self.refresh_interval = 5000\n        elif interval == \"10s\":\n            self.refresh_interval = 10000\n            \n        # Restart refresh cycle if auto-refresh is enabled\n        if self.auto_refresh.get():\n            self.schedule_refresh()\n            \n    def schedule_refresh(self):\n        \"\"\"Schedule the next refresh based on current settings\"\"\"\n        # Cancel any pending refresh\n        if hasattr(self, 'refresh_job'):\n            self.window.after_cancel(self.refresh_job)\n            \n        # Schedule new refresh if auto-refresh is enabled\n        if self.auto_refresh.get() and self.window.winfo_exists():\n            self.refresh_job = self.window.after(\n                self.refresh_interval, \n                self.auto_refresh_callback\n            )\n            \n    def auto_refresh_callback(self):\n        \"\"\"Callback for auto-refresh\"\"\"\n        # Update the display\n        self.update_log_display()\n        \n        # Schedule next refresh\n        self.schedule_refresh()\n        \n    def on_close(self):\n        \"\"\"Handle window closing\"\"\"\n        # Cancel auto-refresh\n        if hasattr(self, 'refresh_job'):\n            self.window.after_cancel(self.refresh_job)\n            \n        # Destroy window\n        self.window.destroy()\n        \n    def add_plugin_filter_menu(self):\n        \"\"\"Add plugin filter menu to the control frame\"\"\"\n        # Skip if no control frame or already added\n        if not hasattr(self, \"filter_dropdown\") or self.filter_menu:\n            return\n            \n        # Create a menu button after the standard filter dropdown\n        control_frame = self.filter_dropdown.master\n        \n        ttk.Label(control_frame, text=\"Plugin Filters:\").pack(side=tk.LEFT, padx=(15, 5))\n        \n        # Create menu button for plugin filters\n        self.plugin_filter_var = tk.StringVar(value=\"None\")\n        self.filter_menu = ttk.Menubutton(\n            control_frame,\n            textvariable=self.plugin_filter_var,\n            direction=\"below\"\n        )\n        self.filter_menu.pack(side=tk.LEFT, padx=5)\n        \n        # Create the dropdown menu\n        self.plugin_menu = tk.Menu(self.filter_menu, tearoff=0)\n        self.filter_menu[\"menu\"] = self.plugin_menu\n        \n        # Add \"None\" option\n        self.plugin_menu.add_radiobutton(\n            label=\"None\",\n            variable=self.plugin_filter_var,\n            value=\"None\",\n            command=self.update_log_display\n        )\n        \n        # Update UI if we have any registered filters\n        self.update_plugin_filter_menu()\n        \n    def register_plugin_extensions(self, plugin_id, plugin):\n        \"\"\"\n        Register plugin extensions for the log viewer\n        \n        Args:\n            plugin_id: Plugin identifier\n            plugin: Plugin instance\n        \"\"\"\n        # Skip if plugin doesn't have log viewer extensions\n        if not hasattr(plugin, \"get_log_viewer_extensions\"):\n            return\n            \n        try:\n            # Get extensions from plugin\n            extensions = plugin.get_log_viewer_extensions()\n            \n            if not extensions or not isinstance(extensions, dict):\n                return\n                \n            # Register log processors\n            if \"log_processors\" in extensions and isinstance(extensions[\"log_processors\"], dict):\n                for name, processor_func in extensions[\"log_processors\"].items():\n                    if callable(processor_func):\n                        self.plugin_log_processors[f\"{plugin_id}.{name}\"] = processor_func\n                \n            # Register log filters\n            if \"log_filters\" in extensions and isinstance(extensions[\"log_filters\"], dict):\n                for filter_name, filter_func in extensions[\"log_filters\"].items():\n                    if callable(filter_func):\n                        self.plugin_log_filters[f\"{plugin_id}.{filter_name}\"] = filter_func\n                        \n            # Register log exporters\n            if \"log_exporters\" in extensions and isinstance(extensions[\"log_exporters\"], dict):\n                for exporter_name, exporter_func in extensions[\"log_exporters\"].items():\n                    if callable(exporter_func):\n                        self.plugin_log_exporters[f\"{plugin_id}.{exporter_name}\"] = exporter_func\n            \n            # Update UI to reflect new extensions            \n            self.update_plugin_filter_menu()\n            self.update_export_menu()\n            \n            self.log(f\"[LogViewer] Registered extensions from plugin: {plugin_id}\")\n            \n        except Exception as e:\n            self.log(f\"[LogViewer] Error registering extensions from plugin {plugin_id}: {e}\")\n\n    def unregister_plugin_extensions(self, plugin_id):\n        \"\"\"\n        Unregister plugin extensions\n        \n        Args:\n            plugin_id: Plugin identifier\n        \"\"\"\n        # Remove log processors\n        processors_to_remove = [k for k in self.plugin_log_processors if k.startswith(f\"{plugin_id}.\")]\n        for processor_id in processors_to_remove:\n            del self.plugin_log_processors[processor_id]\n        \n        # Remove log filters\n        filters_to_remove = [k for k in self.plugin_log_filters if k.startswith(f\"{plugin_id}.\")]\n        for filter_id in filters_to_remove:\n            del self.plugin_log_filters[filter_id]\n        \n        # Remove log exporters\n        exporters_to_remove = [k for k in self.plugin_log_exporters if k.startswith(f\"{plugin_id}.\")]\n        for exporter_id in exporters_to_remove:\n            del self.plugin_log_exporters[exporter_id]\n        \n        # Update UI to reflect removed extensions\n        self.update_plugin_filter_menu()\n        self.update_export_menu()\n        \n        self.log(f\"[LogViewer] Unregistered extensions from plugin: {plugin_id}\")\n\n    def on_plugin_activated(self, plugin_id, plugin_instance):\n        \"\"\"\n        Handle plugin activation event\n        \n        Args:\n            plugin_id: ID of activated plugin\n            plugin_instance: Plugin instance\n        \"\"\"\n        # Register log extensions for newly activated plugin\n        self.register_plugin_extensions(plugin_id, plugin_instance)\n\n    def on_plugin_deactivated(self, plugin_id):\n        \"\"\"\n        Handle plugin deactivation event\n        \n        Args:\n            plugin_id: ID of deactivated plugin\n        \"\"\"\n        # Unregister log extensions\n        self.unregister_plugin_extensions(plugin_id)\n\n    def update_plugin_filter_menu(self):\n        \"\"\"Update the plugin filter menu with registered filters\"\"\"\n        # Skip if no menu exists\n        if not self.filter_menu or not hasattr(self, \"plugin_menu\"):\n            return\n        \n        # Clear existing items (except \"None\" option)\n        menu = self.plugin_menu\n        menu.delete(1, tk.END)\n        \n        # Add registered filters\n        if self.plugin_log_filters:\n            for filter_id, filter_func in sorted(self.plugin_log_filters.items()):\n                # Get display name (remove plugin_id prefix)\n                display_name = filter_id.split(\".\", 1)[1] if \".\" in filter_id else filter_id\n                \n                # Add to menu\n                menu.add_radiobutton(\n                    label=display_name,\n                    variable=self.plugin_filter_var,\n                    value=filter_id,\n                    command=self.update_log_display\n                )\n        else:\n            # Add placeholder if no filters\n            menu.add_command(label=\"No plugin filters available\", state=tk.DISABLED)\n\n    def create_export_menu(self):\n        \"\"\"Create export menu with plugin options\"\"\"\n        # Create menu button in control frame\n        control_frame = self.log_display.master.nametowidget(self.log_display.master.winfo_parent())\n        \n        # Create a frame for the export/import options\n        if not hasattr(self, \"export_frame\"):\n            self.export_frame = ttk.Frame(control_frame)\n            self.export_frame.pack(side=tk.RIGHT, padx=5)\n        \n        # Create export button with dropdown\n        self.export_button = ttk.Menubutton(\n            self.export_frame,\n            text=\"Export\",\n            direction=\"below\"\n        )\n        self.export_button.pack(side=tk.LEFT, padx=5)\n        \n        # Create the dropdown menu\n        self.export_menu = tk.Menu(self.export_button, tearoff=0)\n        self.export_button[\"menu\"] = self.export_menu\n        \n        # Add standard export option\n        self.export_menu.add_command(\n            label=\"Export to Text File\",\n            command=self.save_logs\n        )\n        \n        # Add plugin exporters if any\n        self.update_export_menu()\n\n    def update_export_menu(self):\n        \"\"\"Update the export menu with plugin exporters\"\"\"\n        # Skip if menu doesn't exist\n        if not hasattr(self, \"export_menu\"):\n            self.create_export_menu()\n            return\n        \n        # Clear plugin exporters (keep standard options)\n        menu = self.export_menu\n        menu.delete(1, tk.END)\n        \n        # Add separator if we have plugin exporters\n        if self.plugin_log_exporters:\n            menu.add_separator()\n            \n            # Add each exporter\n            for exporter_id, exporter_func in sorted(self.plugin_log_exporters.items()):\n                # Get display name (remove plugin_id prefix)\n                display_name = exporter_id.split(\".\", 1)[1] if \".\" in exporter_id else exporter_id\n                \n                # Add to menu\n                menu.add_command(\n                    label=display_name,\n                    command=lambda eid=exporter_id: self.run_plugin_exporter(eid)\n                )\n                \n    def run_plugin_exporter(self, exporter_id):\n        \"\"\"\n        Run a plugin exporter\n        \n        Args:\n            exporter_id: ID of the exporter to run\n        \"\"\"\n        if exporter_id not in self.plugin_log_exporters:\n            self.status_var.set(f\"Error: Exporter {exporter_id} not found\")\n            return\n            \n        try:\n            # Get log content\n            content = self.log_display.get(1.0, tk.END)\n            \n            # Run exporter\n            exporter_func = self.plugin_log_exporters[exporter_id]\n            result = exporter_func(content, self.window)\n            \n            # Update status based on result\n            if result:\n                self.status_var.set(f\"Export completed: {result}\")\n            else:\n                self.status_var.set(f\"Export completed\")\n                \n        except Exception as e:\n            self.status_var.set(f\"Error during export: {e}\")\n            messagebox.showerror(\"Export Error\", str(e))",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\__init__.py": "\"\"\"\nOllama Hub Plugin for Irintai Assistant\n\nThis plugin provides integration with Ollama Hub, allowing users to browse,\ndownload, and manage Ollama models directly from the Irintai Assistant interface.\n\"\"\"\n\nimport os\nimport sys\nimport json\nimport importlib\nimport threading\nimport logging\nimport re\nimport time\nimport pkg_resources\nfrom typing import Dict, Any, Optional, Callable, List, Type, Union\nfrom plugins.ollama_hub.core.ollama_client import OllamaClient\n\nclass PluginDependencyError(Exception):\n    \"\"\"\n    Custom exception for plugin dependency issues\n    \"\"\"\n    pass\n\nclass PluginConfigurationError(Exception):\n    \"\"\"\n    Custom exception for plugin configuration errors\n    \"\"\"\n    pass\n\nclass IrintaiPlugin:\n    \"\"\"\n    Ollama Hub Plugin for Irintai Assistant\n    \n    Provides integration with Ollama model hub for:\n    - Browsing available Ollama models\n    - Downloading models from Ollama Hub\n    - Managing local Ollama models\n    - Using Ollama models with Irintai\n    \"\"\"\n    \n    # Plugin metadata\n    METADATA = {\n        \"name\": \"Ollama Hub\",\n        \"version\": \"1.0.0\",\n        \"description\": \"Browse, download, and manage Ollama models\",\n        \"author\": \"Irintai Team\",\n        \"email\": \"contact@irintai.org\",\n        \"license\": \"MIT\",\n        \"dependencies\": {\n            \"python\": \">=3.8\",\n            \"irintai\": \">=1.0.0\",\n            \"external_libs\": [\"requests\"]\n        },\n        \"capabilities\": [\"model_management\", \"ui_extension\"],\n        \"configuration_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"server_url\": {\n                    \"type\": \"string\",\n                    \"description\": \"Ollama server URL\",\n                    \"default\": \"http://localhost:11434\"\n                },                \"auto_connect\": {\n                    \"type\": \"boolean\",\n                    \"description\": \"Automatically connect to Ollama server on startup\",\n                    \"default\": True\n                }\n            },\n            \"required\": [\"server_url\"]\n        }\n    }\n    \n    # Plugin status constants\n    STATUS = {\n        \"UNINITIALIZED\": \"Not Initialized\",\n        \"INITIALIZING\": \"Initializing\",\n        \"ACTIVE\": \"Active\",\n        \"PAUSED\": \"Paused\",\n        \"ERROR\": \"Error\",\n        \"DISABLED\": \"Disabled\"\n    }\n    \n    def __init__(\n        self, \n        plugin_id: str,\n        core_system: Any,\n        config_path: Optional[str] = None,\n        logger: Optional[Callable] = None,\n        **kwargs\n    ):\n        \"\"\"\n        Initialize the Ollama Hub plugin\n        \n        Args:\n            plugin_id: Unique identifier for this plugin instance\n            core_system: Reference to Irintai core system\n            config_path: Path to plugin configuration\n            logger: Optional logging function\n            **kwargs: Additional initialization parameters\n        \"\"\"\n        # Plugin identity\n        self.plugin_id = plugin_id\n        \n        # Core system reference\n        self.core = core_system\n        \n        # Logging setup\n        self._logger = logger or getattr(core_system, 'logger', None) or self._default_logger\n        \n        # Configuration management\n        self._config_path = config_path or self._generate_config_path()\n        self._config: Dict[str, Any] = {}\n        self._state: Dict[str, Any] = {\n            \"status\": self.STATUS[\"UNINITIALIZED\"],\n            \"last_error\": None,\n            \"initialization_time\": None,\n            \"dependencies_loaded\": False,\n            \"connection_status\": \"Not connected\"\n        }\n        \n        # UI components\n        self.ui_components = {}\n        \n        # Thread safety\n        self._lock = threading.Lock()\n        \n        # Initialize plugin\n        self._initialize_plugin(**kwargs)\n    \n    def _default_logger(\n        self, \n        message: str, \n        level: str = \"INFO\"\n    ) -> None:\n        \"\"\"\n        Fallback logging method\n        \n        Args:\n            message: Log message\n            level: Logging level\n        \"\"\"\n        logging.basicConfig(\n            level=logging.INFO, \n            format='%(asctime)s - %(levelname)s: %(message)s'\n        )\n        \n        log_method = {\n            \"INFO\": logging.info,\n            \"WARNING\": logging.warning,\n            \"ERROR\": logging.error,\n            \"DEBUG\": logging.debug\n        }.get(level.upper(), logging.info)\n        \n        log_method(f\"[Ollama Hub] {message}\")\n    \n    def _generate_config_path(self) -> str:\n        \"\"\"\n        Generate default configuration path\n        \n        Returns:\n            Path to plugin configuration file\n        \"\"\"\n        return os.path.join(\n            \"data\", \n            \"plugins\", \n            \"ollama_hub\", \n            \"config.json\"\n        )\n    \n    def _initialize_plugin(self, **kwargs) -> None:\n        \"\"\"\n        Comprehensive plugin initialization\n        \n        Args:\n            **kwargs: Flexible initialization parameters\n        \"\"\"\n        try:\n            # Update state\n            self._state[\"status\"] = self.STATUS[\"INITIALIZING\"]\n            \n            # Validate and load dependencies\n            self._load_dependencies()\n            \n            # Load configuration\n            self._load_configuration(**kwargs)\n            \n            # Validate configuration\n            self._validate_configuration()\n            \n            # Perform plugin-specific initialization\n            self._setup_plugin_resources()\n            \n            # Mark initialization complete\n            self._state[\"status\"] = self.STATUS[\"ACTIVE\"]\n            self._state[\"initialization_time\"] = time.time()\n            \n            self.log(\n                f\"Plugin {self.METADATA['name']} initialized successfully\", \n                \"INFO\"\n            )\n        \n        except Exception as e:\n            # Handle initialization errors\n            self._state[\"status\"] = self.STATUS[\"ERROR\"]\n            self._state[\"last_error\"] = str(e)\n            \n            self.log(\n                f\"Plugin initialization failed: {e}\", \n                \"ERROR\"\n            )\n            \n            # Optionally raise for critical errors\n            raise\n    \n    def _load_dependencies(self) -> None:\n        \"\"\"\n        Load and validate plugin dependencies\n        \n        Raises:\n            PluginDependencyError: If dependencies cannot be loaded\n        \"\"\"\n        dependencies = self.METADATA.get(\"dependencies\", {})\n        \n        # Check Python version\n        python_req = dependencies.get(\"python\")\n        if python_req:\n            import sys\n            import pkg_resources\n            \n            if not pkg_resources.parse_version(\n                sys.version.split()[0]\n            ) >= pkg_resources.parse_version(python_req.replace(\">=\", \"\")):\n                raise PluginDependencyError(\n                    f\"Requires Python {python_req}, \"\n                    f\"current version: {sys.version.split()[0]}\"\n                )\n        \n        # Load external libraries\n        for lib in dependencies.get(\"external_libs\", []):\n            try:\n                importlib.import_module(lib)\n            except ImportError:\n                raise PluginDependencyError(\n                    f\"Missing required library: {lib}\"\n                )\n        \n        self._state[\"dependencies_loaded\"] = True\n    \n    def _load_configuration(self, **kwargs) -> None:\n        \"\"\"\n        Load and merge plugin configuration\n        \n        Args:\n            **kwargs: Additional configuration parameters\n        \"\"\"\n        try:\n            # Check if configuration file exists\n            if os.path.exists(self._config_path):\n                with open(self._config_path, 'r') as f:\n                    file_config = json.load(f)\n            else:\n                # Create default configuration\n                file_config = {}\n            \n            # Merge configurations\n            default_config = self._generate_default_config()\n            self._config = {**default_config, **file_config, **kwargs}\n            \n            # Ensure directory exists\n            os.makedirs(os.path.dirname(self._config_path), exist_ok=True)\n            \n            # Save merged configuration\n            with open(self._config_path, 'w') as f:\n                json.dump(self._config, f, indent=2)\n        \n        except (IOError, json.JSONDecodeError) as e:\n            self.log(\n                f\"Configuration loading error: {e}\", \n                \"ERROR\"\n            )\n            raise PluginConfigurationError(\n                f\"Failed to load configuration: {e}\"\n            )\n    \n    def _generate_default_config(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate default configuration based on metadata\n        \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        schema = self.METADATA.get(\"configuration_schema\", {})\n        default_config = {}\n        \n        # Generate defaults from schema\n        for prop, details in schema.get(\"properties\", {}).items():\n            default_config[prop] = details.get(\"default\")\n        \n        return default_config\n    \n    def _validate_configuration(self) -> None:\n        \"\"\"\n        Validate plugin configuration against schema\n        \n        Raises:\n            PluginConfigurationError: If configuration is invalid\n        \"\"\"\n        schema = self.METADATA.get(\"configuration_schema\", {})\n        \n        # Basic validation\n        for prop in schema.get(\"required\", []):\n            if prop not in self._config or self._config[prop] is None:\n                raise PluginConfigurationError(\n                    f\"Missing required configuration property: {prop}\"\n                )\n        \n        # Type checking\n        for prop, value in self._config.items():\n            if prop in schema.get(\"properties\", {}):\n                prop_schema = schema[\"properties\"][prop]\n                prop_type = prop_schema.get(\"type\")\n                \n                if prop_type == \"string\" and not isinstance(value, str):\n                    raise PluginConfigurationError(\n                        f\"Configuration property {prop} must be a string\"\n                    )\n                elif prop_type == \"boolean\" and not isinstance(value, bool):\n                    raise PluginConfigurationError(\n                        f\"Configuration property {prop} must be a boolean\"\n                    )\n    def _setup_plugin_resources(self) -> None:\n        \"\"\"\n        Set up plugin-specific resources\n        \"\"\"\n        # Import UI components to register\n        from plugins.ollama_hub.ui.ollama_tab import OllamaHubTab\n        \n        # Store UI components for activation\n        self.ui_components[\"ollama_tab\"] = OllamaHubTab\n        \n        # Create ollama client if present in core system\n        if hasattr(self.core, \"model_manager\") and hasattr(self.core.model_manager, \"ollama_client\"):\n            self.log(\"Using model_manager's ollama_client\", \"INFO\")\n            self.ollama_client = self.core.model_manager.ollama_client\n        elif hasattr(self.core, \"ollama_client\"):\n            self.log(\"Using core's ollama_client\", \"INFO\")\n            self.ollama_client = self.core.ollama_client\n        else:\n            # Try to import from core system with better error handling\n            self.log(\"Attempting to create new ollama client\", \"INFO\")\n            try:\n                import importlib.util\n                # Try finding the core module first\n                if importlib.util.find_spec(\"core.ollama_client\"):\n                    from plugins.ollama_hub.core.ollama_client import OllamaClient\n                    self.ollama_client = OllamaClient(logger=self.log)\n                    self.log(\"Created ollama client from core module\", \"INFO\")\n                else:\n                    self.ollama_client = OllamaClient(logger=self.log)\n                    self.log(\"Created ollama client from plugin module\", \"INFO\")\n            except ImportError as e:\n                self.log(f\"ImportError when creating ollama client: {e}\", \"ERROR\")\n                # Create our own client as last resort\n                try:\n                    self.ollama_client = OllamaClient(logger=self.log)\n                    self.log(\"Created ollama client from plugin module (fallback)\", \"INFO\")\n                except ImportError as e2:\n                    self.log(f\"Failed to create ollama client: {e2}\", \"ERROR\")\n                    raise PluginDependencyError(f\"Cannot create Ollama client: {e2}\")\n    \n    def log(self, message: str, level: str = \"INFO\") -> None:\n        \"\"\"\n        Log a message using the logger\n        \n        Args:\n            message: The message to log\n            level: The log level\n        \"\"\"\n        if self._logger:\n            self._logger(message, level)\n    \n    def activate(self) -> bool:\n        \"\"\"\n        Activate the plugin\n        \n        Returns:\n            Boolean indicating successful activation\n        \"\"\"\n        with self._lock:\n            # Check current status\n            if self._state[\"status\"] == self.STATUS[\"ACTIVE\"]:\n                self.log(\"Plugin already active\", \"WARNING\")\n                return True\n            \n            try:\n                # Perform activation logic\n                self._on_activate()\n                \n                # Update status\n                self._state[\"status\"] = self.STATUS[\"ACTIVE\"]\n                \n                self.log(\n                    f\"Plugin {self.METADATA['name']} activated\", \n                    \"INFO\"\n                )\n                return True\n            \n            except Exception as e:\n                # Handle activation errors\n                self._state[\"status\"] = self.STATUS[\"ERROR\"]\n                self._state[\"last_error\"] = str(e)\n                \n                self.log(\n                    f\"Plugin activation failed: {e}\", \n                    \"ERROR\"\n                )\n                return False\n    \n    def deactivate(self) -> bool:\n        \"\"\"\n        Deactivate the plugin\n        \n        Returns:\n            Boolean indicating successful deactivation\n        \"\"\"\n        with self._lock:\n            # Check current status\n            if self._state[\"status\"] in [\n                self.STATUS[\"UNINITIALIZED\"], \n                self.STATUS[\"DISABLED\"]\n            ]:\n                self.log(\"Plugin not active\", \"WARNING\")\n                return True\n            \n            try:\n                # Perform deactivation logic\n                self._on_deactivate()\n                \n                # Update status\n                self._state[\"status\"] = self.STATUS[\"DISABLED\"]\n                \n                self.log(\n                    f\"Plugin {self.METADATA['name']} deactivated\", \n                    \"INFO\"\n                )\n                return True\n            \n            except Exception as e:\n                # Handle deactivation errors\n                self._state[\"status\"] = self.STATUS[\"ERROR\"]\n                self._state[\"last_error\"] = str(e)\n                \n                self.log(\n                    f\"Plugin deactivation failed: {e}\", \n                    \"ERROR\"\n                )\n                return False\n    \n    def _on_activate(self) -> None:\n        \"\"\"\n        Plugin-specific activation logic\n        \"\"\"\n        # Auto-connect to Ollama server if configured\n        if self._config.get(\"auto_connect\", True):\n            threading.Thread(\n                target=self._connect_to_ollama_thread,\n                args=(self._config.get(\"server_url\", \"http://localhost:11434\"),),\n                daemon=True\n            ).start()\n    \n    def _on_deactivate(self) -> None:\n        \"\"\"\n        Plugin-specific deactivation logic\n        \"\"\"\n        # Clean up any resources\n        self._state[\"connection_status\"] = \"Not connected\"\n    \n    def update_configuration(\n        self, \n        **kwargs\n    ) -> bool:\n        \"\"\"\n        Update plugin configuration\n        \n        Args:\n            **kwargs: Configuration parameters to update\n        \n        Returns:\n            Boolean indicating successful configuration update\n        \"\"\"\n        with self._lock:\n            try:\n                # Merge new configuration\n                self._config.update(kwargs)\n                \n                # Validate updated configuration\n                self._validate_configuration()\n                \n                # Save updated configuration\n                with open(self._config_path, 'w') as f:\n                    json.dump(self._config, f, indent=2)\n                \n                # Optionally trigger reconfiguration\n                self._on_configuration_update()\n                \n                self.log(\n                    \"Plugin configuration updated\", \n                    \"INFO\"\n                )\n                return True\n            \n            except Exception as e:\n                self.log(\n                    f\"Configuration update failed: {e}\", \n                    \"ERROR\"\n                )\n                return False\n    \n    def _on_configuration_update(self) -> None:\n        \"\"\"\n        Handle configuration updates\n        \"\"\"\n        # Reconnect to Ollama server if URL changed\n        if self._state[\"status\"] == self.STATUS[\"ACTIVE\"]:\n            server_url = self._config.get(\"server_url\")\n            threading.Thread(\n                target=self._connect_to_ollama_thread,\n                args=(server_url,),\n                daemon=True\n            ).start()\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"\n        Get comprehensive plugin status\n        \n        Returns:\n            Dictionary with plugin status details\n        \"\"\"\n        return {\n            \"name\": self.METADATA[\"name\"],\n            \"version\": self.METADATA[\"version\"],\n            \"status\": self._state[\"status\"],\n            \"last_error\": self._state[\"last_error\"],\n            \"connection_status\": self._state.get(\"connection_status\", \"Not connected\"),\n            \"initialization_time\": self._state.get(\"initialization_time\"),\n            \"config_path\": self._config_path,\n            \"server_url\": self._config.get(\"server_url\")\n        }\n    \n    def get_actions(self) -> Dict[str, Callable]:\n        \"\"\"\n        Get the actions provided by this plugin for UI integration\n        \n        Returns:\n            Dictionary of action names to callable functions\n        \"\"\"\n        return {\n            \"Connect to Ollama\": self.connect_to_ollama,\n            \"Refresh Models\": self.fetch_ollama_models,\n        }\n    \n    def register_ui_components(self, ui_registry):\n        \"\"\"\n        Register UI components with the main application\n        \n        Args:\n            ui_registry: The UI component registry to register with\n        \"\"\"\n        if hasattr(ui_registry, 'register_tab'):\n            # Register our tab component\n            ui_registry.register_tab(\n                \"Model Panel\",\n                \"Ollama Hub\",\n                self.ui_components[\"ollama_tab\"],\n                {\"plugin_instance\": self}\n            )\n            \n            self.log(\"Registered UI components\", \"INFO\")\n    \n    def connect_to_ollama(self):\n        \"\"\"\n        Connect to the Ollama server using the configured URL\n        \"\"\"\n        server_url = self._config.get(\"server_url\", \"http://localhost:11434\")\n        self._state[\"connection_status\"] = \"Connecting...\"\n        \n        # Make connection attempt in a separate thread\n        threading.Thread(\n            target=self._connect_to_ollama_thread,\n            args=(server_url,),\n            daemon=True\n        ).start()\n    \n    def _connect_to_ollama_thread(self, url):\n        \"\"\"\n        Thread function for connecting to Ollama server\n        \n        Args:\n            url: The Ollama server URL to connect to\n        \"\"\"\n        try:\n            import requests\n            import json\n            \n            # Try to connect to Ollama server\n            response = requests.get(f\"{url}/api/tags\", timeout=5)\n            \n            if response.status_code == 200:\n                # Connection successful\n                self._state[\"connection_status\"] = \"Connected\"\n                self.log(f\"Connected to Ollama server at {url}\", \"INFO\")\n                \n                # Fetch models\n                self.fetch_ollama_models()\n            else:\n                # Connection failed\n                self._state[\"connection_status\"] = \"Connection failed\"\n                self.log(f\"Connection failed: Server returned {response.status_code}\", \"ERROR\")\n                \n        except Exception as e:\n            # Connection error\n            self._state[\"connection_status\"] = \"Connection failed\"\n            self.log(f\"Connection failed: {e}\", \"ERROR\")\n    \n    def fetch_ollama_models(self):\n        \"\"\"\n        Fetch available models from Ollama\n        \n        Returns:\n            Boolean indicating success and model data\n        \"\"\"\n        url = self._config.get(\"server_url\", \"http://localhost:11434\")\n        if self._state[\"connection_status\"] != \"Connected\":\n            self.log(\"Not connected to Ollama server\", \"WARNING\")\n            return False, {\"error\": \"Not connected to Ollama server\"}\n            \n        # Fetch models in a separate thread\n        threading.Thread(\n            target=self._fetch_ollama_models_thread,\n            args=(url,),\n            daemon=True\n        ).start()\n        \n        return True, {\"status\": \"Fetching models...\"}\n    \n    def _fetch_ollama_models_thread(self, url):\n        \"\"\"\n        Thread function for fetching Ollama models\n        \n        Args:\n            url: The Ollama server URL\n        \"\"\"\n        try:\n            # Get local models\n            self.log(\"Fetching locally installed models...\", \"INFO\")\n            success_local, local_data = self.ollama_client.list_models(remote=False)\n            local_models = {}\n            \n            if success_local:\n                for model in local_data.get('models', []):\n                    name = model.get('name', '')\n                    local_models[name] = model\n                self.log(f\"Found {len(local_models)} locally installed models\")\n            else:\n                error = local_data.get('error', 'Unknown error')\n                self.log(f\"Failed to fetch local models: {error}\", \"ERROR\")\n            \n            # Get remote models\n            self.log(\"Fetching remote models from Ollama Hub...\", \"INFO\")\n            success_remote, remote_data = self.ollama_client.list_models(remote=True)\n            library_models = []\n            \n            if success_remote:\n                remote_models = remote_data.get('models', [])\n                self.log(f\"Successfully fetched {len(remote_models)} remote models\", \"INFO\")\n                \n                for model in remote_models:\n                    name = model.get('name', '')\n                    \n                    # Extract parameter info from model name if possible\n                    parameters = model.get('parameters', '')\n                    if not parameters:\n                        param_match = re.search(r'(\\d+)b', name, re.IGNORECASE)\n                        parameters = f\"{param_match.group(1)}B\" if param_match else \"Unknown\"\n                    \n                    # Check if model is already downloaded\n                    is_local = name in local_models\n                    \n                    # Extract tags\n                    tags = model.get('tags', [])\n                    # If no tags but we can infer from name\n                    if not tags:\n                        if 'code' in name.lower() or 'coder' in name.lower():\n                            tags.append('code')\n                        if 'vision' in name.lower() or 'vl' in name.lower():\n                            tags.append('vision')\n                        if 'instruct' in name.lower():\n                            tags.append('instruct')\n                    \n                    library_models.append({\n                        'name': name,\n                        'description': \"Official Ollama model\", \n                        'parameters': parameters,\n                        'size': model.get('size', 'Unknown'),\n                        'is_local': is_local,\n                        'tags': tags\n                    })\n            else:\n                error = remote_data.get('error', 'Unknown error')\n                self.log(f\"Failed to fetch remote models: {error}\", \"ERROR\")\n                \n            # Notify UI components of model data update\n            self._notify_model_update(local_models, library_models)\n                \n        except Exception as e:\n            self.log(f\"Error fetching models: {e}\", \"ERROR\")\n    \n    def _notify_model_update(self, local_models, library_models):\n        \"\"\"\n        Notify UI components of model data update\n        \n        Args:\n            local_models: Dictionary of local models\n            library_models: List of library models\n        \"\"\"\n        # Use event system if available\n        if hasattr(self.core, 'event_bus'):\n            self.core.event_bus.publish(\n                f\"{self.plugin_id}.models_updated\",\n                {\n                    \"local_models\": local_models,\n                    \"library_models\": library_models\n                }\n            )\n    \n    def download_ollama_model(self, model_name):\n        \"\"\"\n        Download an Ollama model\n        \n        Args:\n            model_name: Name of the model to download\n            \n        Returns:\n            Boolean indicating if download was started\n        \"\"\"\n        if not model_name:\n            self.log(\"No model name provided for download\", \"ERROR\")\n            return False\n        \n        # Start download in a separate thread\n        threading.Thread(\n            target=self._download_ollama_model_thread,\n            args=(model_name,),\n            daemon=True\n        ).start()\n        \n        return True\n    \n    def _download_ollama_model_thread(self, model_name):\n        \"\"\"\n        Thread function for downloading an Ollama model\n        \n        Args:\n            model_name: Name of the model to download\n        \"\"\"\n        try:\n            # Define a progress callback for real-time updates\n            def progress_callback(percentage):\n                # Report progress\n                if hasattr(self.core, 'event_bus'):\n                    self.core.event_bus.publish(\n                        f\"{self.plugin_id}.download_progress\",\n                        {\n                            \"model\": model_name,\n                            \"percentage\": percentage\n                        }\n                    )\n\n            # Download the model with progress tracking\n            success, message = self.ollama_client.pull_model(\n                model_name,\n                progress_callback=progress_callback\n            )\n\n            # Update UI based on result\n            if success:\n                self.log(f\"Successfully downloaded model {model_name}\", \"INFO\")\n                # Refresh the model list\n                self.fetch_ollama_models()\n                \n                if hasattr(self.core, 'event_bus'):\n                    self.core.event_bus.publish(\n                        f\"{self.plugin_id}.model_downloaded\",\n                        {\n                            \"model\": model_name,\n                            \"success\": True\n                        }\n                    )\n            else:\n                self.log(f\"Failed to download model {model_name}: {message}\", \"ERROR\")\n                if hasattr(self.core, 'event_bus'):\n                    self.core.event_bus.publish(\n                        f\"{self.plugin_id}.model_downloaded\",\n                        {\n                            \"model\": model_name,\n                            \"success\": False,\n                            \"error\": message\n                        }\n                    )\n                    \n        except Exception as e:\n            self.log(f\"Error downloading model {model_name}: {e}\", \"ERROR\")\n            if hasattr(self.core, 'event_bus'):\n                self.core.event_bus.publish(\n                    f\"{self.plugin_id}.model_downloaded\",\n                    {\n                        \"model\": model_name,\n                        \"success\": False,\n                        \"error\": str(e)\n                    }\n                )\n    \n    def delete_ollama_model(self, model_name):\n        \"\"\"\n        Delete an Ollama model\n        \n        Args:\n            model_name: Name of the model to delete\n            \n        Returns:\n            Boolean indicating if deletion was started\n        \"\"\"\n        if not model_name:\n            self.log(\"No model name provided for deletion\", \"ERROR\")\n            return False\n        \n        # Start deletion in a separate thread\n        threading.Thread(\n            target=self._delete_ollama_model_thread,\n            args=(model_name,),\n            daemon=True\n        ).start()\n        \n        return True\n    \n    def _delete_ollama_model_thread(self, model_name):\n        \"\"\"\n        Thread function for deleting an Ollama model\n        \n        Args:\n            model_name: Name of the model to delete\n        \"\"\"\n        try:\n            # Delete the model\n            success, message = self.ollama_client.delete_model(model_name)\n            \n            # Update UI based on result\n            if success:\n                self.log(f\"Successfully deleted model {model_name}\", \"INFO\")\n                # Refresh the model list\n                self.fetch_ollama_models()\n                \n                if hasattr(self.core, 'event_bus'):\n                    self.core.event_bus.publish(\n                        f\"{self.plugin_id}.model_deleted\",\n                        {\n                            \"model\": model_name,\n                            \"success\": True\n                        }\n                    )\n            else:\n                self.log(f\"Failed to delete model {model_name}: {message}\", \"ERROR\")\n                if hasattr(self.core, 'event_bus'):\n                    self.core.event_bus.publish(\n                        f\"{self.plugin_id}.model_deleted\",\n                        {\n                            \"model\": model_name,\n                            \"success\": False,\n                            \"error\": message\n                        }\n                    )\n                    \n        except Exception as e:\n            self.log(f\"Error deleting model {model_name}: {e}\", \"ERROR\")\n            if hasattr(self.core, 'event_bus'):\n                self.core.event_bus.publish(\n                    f\"{self.plugin_id}.model_deleted\",\n                    {\n                        \"model\": model_name,\n                        \"success\": False,\n                        \"error\": str(e)\n                    }\n                )\n\n# Plugin registration information\nplugin_info = {\n    \"name\": \"Ollama Hub\",\n    \"description\": \"Browse, download, and manage Ollama models\",\n    \"version\": \"1.0.0\",\n    \"author\": \"Irintai Team\",\n    \"url\": \"https://irintai.org/plugins/ollama-hub\",\n    \"plugin_class\": IrintaiPlugin,\n    \"compatibility\": \"1.0.0\",\n    \"dependencies\": [],\n    \"tags\": [\"ollama\", \"models\", \"hub\", \"download\"]}",
  "D:\\AI\\IrintAI Assistant\\development\\examples\\plugin_example.py": "\"\"\"\nExample Plugin for Irintai Assistant\nDemonstrates the basic plugin structure and API usage\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport threading\nimport time\n\nclass IrintaiPlugin:\n    \"\"\"Example plugin demonstrating API usage\"\"\"\n    \n    def __init__(self, plugin_id, core_system):\n        \"\"\"\n        Initialize the plugin\n        \n        Args:\n            plugin_id: Unique identifier for this plugin\n            core_system: Dictionary of core system components\n        \"\"\"\n        self.plugin_id = plugin_id\n        self.core = core_system\n        \n        # Get logger for plugin-specific logging\n        self.logger = getattr(core_system, 'logger', None)\n        \n        # Track plugin state\n        self.active = False\n        self.background_thread = None\n        \n    def activate(self):\n        \"\"\"Called when the plugin is activated\"\"\"\n        if self.logger:\n            self.logger.log(f\"[{self.plugin_id}] Plugin activated\")\n            \n        # Register custom metrics if system_monitor is available\n        system_monitor = getattr(self.core, 'system_monitor', None)\n        if system_monitor:\n            system_monitor.register_plugin_metric(\n                self.plugin_id,\n                \"example_counter\",\n                self.get_counter_value,\n                {\n                    \"name\": \"Example Counter\",\n                    \"description\": \"A simple counter that increments over time\",\n                    \"format\": \"numeric\",\n                    \"unit\": \"ops\"\n                }\n            )\n        \n        # Subscribe to events if event_bus is available\n        event_bus = getattr(self.core, 'event_bus', None)\n        if event_bus:\n            event_bus.subscribe(\n                \"system.model_loaded\", \n                self.on_model_loaded,\n                self.plugin_id\n            )\n        \n        # Initialize plugin data\n        self.counter = 0\n        self.active = True\n        \n        # Start background thread\n        self.background_thread = threading.Thread(target=self.background_task, daemon=True)\n        self.background_thread.start()\n        \n        return True\n        \n    def deactivate(self):\n        \"\"\"Called when the plugin is deactivated\"\"\"\n        # Stop background thread\n        self.active = False\n        if self.background_thread:\n            self.background_thread.join(timeout=2.0)\n            \n        # Unregister from events\n        event_bus = getattr(self.core, 'event_bus', None)\n        if event_bus:\n            event_bus.unsubscribe_all(self.plugin_id)\n            \n        # Unregister custom metrics\n        system_monitor = getattr(self.core, 'system_monitor', None)\n        if system_monitor:\n            system_monitor.unregister_plugin(self.plugin_id)\n            \n        if self.logger:\n            self.logger.log(f\"[{self.plugin_id}] Plugin deactivated\")\n            \n        return True\n        \n    def get_actions(self):\n        \"\"\"\n        Return actions for the UI\n        \n        Returns:\n            Dictionary mapping action names to functions\n        \"\"\"\n        return {\n            \"Show Example Dialog\": self.show_dialog,\n            \"Reset Counter\": self.reset_counter,\n            \"Show Resource Usage\": self.show_resource_usage,\n            \"Publish Test Event\": self.publish_test_event\n        }\n        \n    def get_config_schema(self):\n        \"\"\"\n        Return configuration schema for the plugin\n        \n        Returns:\n            Dictionary defining configuration fields\n        \"\"\"\n        return {\n            \"update_interval\": {\n                \"type\": \"float\",\n                \"label\": \"Update Interval\",\n                \"description\": \"How often to update the counter (in seconds)\",\n                \"default\": 1.0\n            },\n            \"counter_increment\": {\n                \"type\": \"integer\",\n                \"label\": \"Counter Increment\",\n                \"description\": \"How much to increment the counter each time\",\n                \"default\": 1\n            },\n            \"enable_logging\": {\n                \"type\": \"boolean\",\n                \"label\": \"Enable Logging\",\n                \"description\": \"Log counter updates to the console\",\n                \"default\": False\n            },\n            \"text_color\": {\n                \"type\": \"color\",\n                \"label\": \"Text Color\",\n                \"description\": \"Color for text in the plugin dialog\",\n                \"default\": \"#007bff\"\n            }\n        }\n        \n    def on_config_changed(self, config):\n        \"\"\"\n        Called when plugin configuration changes\n        \n        Args:\n            config: New configuration dictionary\n        \"\"\"\n        if self.logger:\n            self.logger.log(f\"[{self.plugin_id}] Configuration updated: {config}\")\n            \n    def get_counter_value(self):\n        \"\"\"Get the current counter value for metrics\"\"\"\n        return self.counter\n        \n    def on_model_loaded(self, event_name, data, event_info):\n        \"\"\"\n        Event handler for model loading\n        \n        Args:\n            event_name: Name of the event\n            data: Event data\n            event_info: Additional event information\n        \"\"\"\n        if self.logger:\n            self.logger.log(f\"[{self.plugin_id}] Model loaded: {data.get('model_name')}\")\n            \n    def background_task(self):\n        \"\"\"Background task that runs while the plugin is active\"\"\"\n        while self.active:\n            try:\n                # Get configuration\n                config = getattr(self.core, 'config_manager', {})\n                if hasattr(config, 'get'):\n                    plugin_config = config.get(f\"plugins.{self.plugin_id}\", {})\n                    increment = plugin_config.get(\"counter_increment\", 1)\n                    interval = plugin_config.get(\"update_interval\", 1.0)\n                    enable_logging = plugin_config.get(\"enable_logging\", False)\n                else:\n                    increment = 1\n                    interval = 1.0\n                    enable_logging = False\n                \n                # Increment counter\n                self.counter += increment\n                \n                # Log if enabled\n                if enable_logging and self.logger:\n                    self.logger.log(f\"[{self.plugin_id}] Counter: {self.counter}\", \"DEBUG\")\n                    \n                # Sleep for the configured interval\n                time.sleep(interval)\n                \n            except Exception as e:\n                if self.logger:\n                    self.logger.log(f\"[{self.plugin_id}] Error in background task: {e}\", \"ERROR\")\n                time.sleep(1.0)  # Sleep on error to avoid tight loop\n                \n    def reset_counter(self):\n        \"\"\"Reset the counter to zero\"\"\"\n        self.counter = 0\n        if self.logger:\n            self.logger.log(f\"[{self.plugin_id}] Counter reset to 0\")\n            \n        # Show confirmation\n        messagebox.showinfo(\"Counter Reset\", \"The counter has been reset to 0.\")\n        \n    def publish_test_event(self):\n        \"\"\"Publish a test event\"\"\"\n        event_bus = getattr(self.core, 'event_bus', None)\n        if event_bus:\n            event_data = {\n                \"counter\": self.counter,\n                \"timestamp\": time.time(),\n                \"message\": \"This is a test event\"\n            }\n            \n            event_bus.publish(f\"{self.plugin_id}.test_event\", event_data)\n            \n            if self.logger:\n                self.logger.log(f\"[{self.plugin_id}] Published test event with counter={self.counter}\")\n                \n            # Show confirmation\n            messagebox.showinfo(\"Event Published\", f\"Test event published with counter={self.counter}\")\n        else:\n            messagebox.showwarning(\"Event Bus Unavailable\", \"The event bus is not available.\")\n            \n    def show_resource_usage(self):\n        \"\"\"Show resource usage in a dialog\"\"\"\n        system_monitor = getattr(self.core, 'system_monitor', None)\n        if not system_monitor:\n            messagebox.showwarning(\"System Monitor Unavailable\", \"The system monitor is not available.\")\n            return\n            \n        # Create dialog\n        dialog = tk.Toplevel()\n        dialog.title(\"Resource Usage\")\n        dialog.geometry(\"500x400\")\n        dialog.transient(tk.Tk.winfo_toplevel(tk._default_root))  # Make dialog transient to main window\n        \n        # Create frame with padding\n        frame = ttk.Frame(dialog, padding=10)\n        frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Add title\n        ttk.Label(frame, text=\"Current Resource Usage\", font=(\"\", 14, \"bold\")).pack(pady=(0, 10))\n        \n        # Create notebook for tabs\n        notebook = ttk.Notebook(frame)\n        notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # System tab\n        system_tab = ttk.Frame(notebook)\n        notebook.add(system_tab, text=\"System\")\n        \n        # Get system info\n        system_info = system_monitor.get_system_info()\n        \n        # Display system info\n        row = 0\n        ttk.Label(system_tab, text=\"CPU Usage:\").grid(row=row, column=0, sticky=tk.W, padx=5, pady=2)\n        ttk.Label(system_tab, text=f\"{system_info['cpu']['usage_percent']}%\").grid(row=row, column=1, sticky=tk.W)\n        \n        row += 1\n        ttk.Label(system_tab, text=\"RAM Usage:\").grid(row=row, column=0, sticky=tk.W, padx=5, pady=2)\n        ttk.Label(system_tab, text=f\"{system_info['ram']['usage_percent']}% ({system_info['ram']['used_gb']:.1f}/{system_info['ram']['total_gb']:.1f} GB)\").grid(row=row, column=1, sticky=tk.W)\n        \n        row += 1\n        ttk.Label(system_tab, text=\"GPU Usage:\").grid(row=row, column=0, sticky=tk.W, padx=5, pady=2)\n        ttk.Label(system_tab, text=f\"{system_info['gpu']['usage_percent']} ({system_info['gpu']['memory']})\").grid(row=row, column=1, sticky=tk.W)\n        \n        row += 1\n        ttk.Label(system_tab, text=\"Disk Usage:\").grid(row=row, column=0, sticky=tk.W, padx=5, pady=2)\n        ttk.Label(system_tab, text=f\"{system_info['disk']['usage_percent']}% ({system_info['disk']['free_gb']:.1f} GB free)\").grid(row=row, column=1, sticky=tk.W)\n        \n        # Plugin metrics tab\n        plugin_tab = ttk.Frame(notebook)\n        notebook.add(plugin_tab, text=\"Plugin Metrics\")\n        \n        # Get plugin metrics\n        plugin_metrics = system_monitor.get_plugin_metrics()\n        \n        if plugin_metrics:\n            # Create treeview for plugin metrics\n            columns = (\"Value\", \"Type\", \"Description\")\n            tree = ttk.Treeview(plugin_tab, columns=columns, show=\"headings\")\n            tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n            \n            # Configure columns\n            tree.heading(\"Value\", text=\"Value\")\n            tree.heading(\"Type\", text=\"Type\")\n            tree.heading(\"Description\", text=\"Description\")\n            \n            tree.column(\"Value\", width=100, anchor=tk.E)\n            tree.column(\"Type\", width=80, anchor=tk.CENTER)\n            tree.column(\"Description\", width=300, anchor=tk.W)\n            \n            # Add plugin metrics\n            for key, metric in plugin_metrics.items():\n                metadata = metric[\"metadata\"]\n                \n                if metric[\"plugin_id\"] == self.plugin_id:\n                    # Format value based on type\n                    if metadata[\"format\"] == \"percentage\":\n                        value = f\"{metric['value']:.1f}%\"\n                    elif metadata[\"format\"] == \"numeric\":\n                        value = f\"{metric['value']:.1f} {metadata.get('unit', '')}\"\n                    else:\n                        value = str(metric['value'])\n                        \n                    tree.insert(\"\", \"end\", values=(\n                        value,\n                        metadata[\"format\"].capitalize(),\n                        metadata[\"description\"]\n                    ))\n        else:\n            ttk.Label(plugin_tab, text=\"No plugin metrics available\").pack(pady=20)\n        \n        # Button to close dialog\n        ttk.Button(frame, text=\"Close\", command=dialog.destroy).pack(pady=10)\n            \n    def show_dialog(self):\n        \"\"\"Show a custom dialog\"\"\"\n        # Get configuration for text color\n        config = getattr(self.core, 'config_manager', {})\n        if hasattr(config, 'get'):\n            plugin_config = config.get(f\"plugins.{self.plugin_id}\", {})\n            text_color = plugin_config.get(\"text_color\", \"#007bff\")\n        else:\n            text_color = \"#007bff\"\n        \n        # Create dialog window\n        dialog = tk.Toplevel()\n        dialog.title(\"Example Plugin Dialog\")\n        dialog.geometry(\"400x300\")\n        dialog.transient(tk.Tk.winfo_toplevel(tk._default_root))  # Make dialog transient to main window\n        \n        # Create frame with padding\n        frame = ttk.Frame(dialog, padding=10)\n        frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Add some content\n        ttk.Label(frame, text=\"Example Plugin\", font=(\"\", 16, \"bold\")).pack(pady=(0, 10))\n        \n        # Use tk.Label for colored text (ttk.Label doesn't support foreground)\n        tk.Label(\n            frame, \n            text=f\"Current counter value: {self.counter}\",\n            font=(\"\", 12),\n            foreground=text_color\n        ).pack(pady=10)\n        \n        # Add a button that increments the counter\n        ttk.Button(\n            frame, \n            text=\"Increment Counter\", \n            command=self.increment_counter\n        ).pack(pady=5)\n        \n        # Add a button to reset counter\n        ttk.Button(\n            frame, \n            text=\"Reset Counter\", \n            command=self.reset_counter\n        ).pack(pady=5)\n        \n        # Add information about the plugin\n        info_text = (\n            \"This is an example plugin that demonstrates various features \"\n            \"of the Irintai plugin API including resource monitoring, \"\n            \"configuration, and event handling.\"\n        )\n        \n        ttk.Label(frame, text=info_text, wraplength=350).pack(pady=20)\n        \n        # Close button\n        ttk.Button(frame, text=\"Close\", command=dialog.destroy).pack(pady=10)\n        \n    def increment_counter(self):\n        \"\"\"Increment the counter manually\"\"\"\n        config = getattr(self.core, 'config_manager', {})\n        if hasattr(config, 'get'):\n            plugin_config = config.get(f\"plugins.{self.plugin_id}\", {})\n            increment = plugin_config.get(\"counter_increment\", 1)\n        else:\n            increment = 1\n            \n        self.counter += increment\n        \n        # Show confirmation\n        messagebox.showinfo(\"Counter Incremented\", f\"Counter incremented by {increment} to {self.counter}\")\n        \n\n# Plugin metadata - required for all plugins\nplugin_info = {\n    \"name\": \"Example Plugin\",\n    \"description\": \"A simple example plugin demonstrating the Irintai plugin API\",\n    \"version\": \"1.0.0\",\n    \"author\": \"Irintai Team\",\n    \"url\": \"\",\n    \"plugin_class\": IrintaiPlugin,\n    \"compatibility\": \"1.0.0\",\n    \"dependencies\": [],\n    \"tags\": [\"example\", \"demo\"]\n}",
  "D:\\AI\\IrintAI Assistant\\setup.py": "# Python script to detect CUDA and install appropriate PyTorch version\nimport os\nimport platform\nimport subprocess\nimport sys\nfrom pathlib import Path\nimport re\n\ndef run_command(command):\n    \"\"\"Run a command and return its output.\"\"\"\n    result = subprocess.run(command, shell=True, capture_output=True, text=True)\n    return result.stdout.strip()\n\ndef detect_cuda():\n    \"\"\"Detect if CUDA is available on the system.\"\"\"\n    if platform.system() == \"Windows\":\n        # Check if NVIDIA GPU drivers are installed\n        try:\n            output = run_command(\"nvidia-smi\")\n            # Extract CUDA version from nvidia-smi output\n            match = re.search(r\"CUDA Version: (\\d+\\.\\d+)\", output)\n            if match:\n                cuda_version = match.group(1)\n                print(f\"\u2713 CUDA detected: {cuda_version}\")\n                return cuda_version\n        except Exception:\n            pass\n    \n    return None\n\ndef get_cuda_pytorch_version(cuda_version):\n    \"\"\"Get the appropriate PyTorch CUDA version based on detected CUDA.\"\"\"\n    if cuda_version is None:\n        return None\n    \n    # Map CUDA version to PyTorch CUDA support version\n    cuda_float = float(cuda_version)\n    \n    if cuda_float >= 12.0:\n        return \"cu121\"\n    elif cuda_float >= 11.8:\n        return \"cu118\"\n    elif cuda_float >= 11.7:\n        return \"cu117\"\n    elif cuda_float >= 11.6:\n        return \"cu116\"\n    elif cuda_float >= 11.3:\n        return \"cu113\"\n    else:\n        print(f\"\u26a0 CUDA {cuda_version} detected, but using CPU version as no suitable PyTorch CUDA build exists\")\n        return None\n\ndef install_pytorch(cuda_pytorch_version):\n    \"\"\"Install the appropriate PyTorch version.\"\"\"\n    # Latest stable version as of April 2025\n    pytorch_version = \"2.1.0\" \n    \n    if cuda_pytorch_version:\n        print(f\"Installing PyTorch {pytorch_version} with CUDA support ({cuda_pytorch_version})...\")\n        cmd = f\"pip install torch=={pytorch_version} --index-url https://download.pytorch.org/whl/{cuda_pytorch_version}\"\n    else:\n        print(\"Installing PyTorch CPU version...\")\n        cmd = f\"pip install torch=={pytorch_version}\"\n    \n    print(f\"Running: {cmd}\")\n    os.system(cmd)\n\ndef verify_installation():\n    \"\"\"Verify that PyTorch is installed correctly.\"\"\"\n    print(\"\\nVerifying PyTorch installation:\")\n    try:\n        import torch\n        print(f\"PyTorch version: {torch.__version__}\")\n        print(f\"CUDA available: {torch.cuda.is_available()}\")\n        \n        if torch.cuda.is_available():\n            print(f\"CUDA version: {torch.version.cuda}\")\n            print(f\"GPU device: {torch.cuda.get_device_name(0)}\")\n            print(f\"GPU count: {torch.cuda.device_count()}\")\n        else:\n            print(\"CUDA: Not available\")\n    except ImportError:\n        print(\"\u274c PyTorch is not installed correctly\")\n\ndef install_requirements():\n    \"\"\"Install the remaining packages from requirements.txt.\"\"\"\n    print(\"\\nInstalling remaining requirements...\")\n    os.system(\"pip install -r requirements.txt\")\n\ndef main():\n    print(\"=\" * 70)\n    print(\"IrintAI Assistant - CUDA Detection and PyTorch Setup\")\n    print(\"=\" * 70)\n    \n    # Ensure we're in a virtual environment\n    if not hasattr(sys, 'real_prefix') and not sys.base_prefix != sys.prefix:\n        print(\"\u26a0 Warning: Not running in a virtual environment!\")\n        if input(\"Continue anyway? (y/n): \").lower() != 'y':\n            sys.exit(1)\n    \n    # Detect CUDA\n    cuda_version = detect_cuda()\n    \n    # Get appropriate PyTorch version\n    cuda_pytorch_version = get_cuda_pytorch_version(cuda_version)\n    \n    # Install PyTorch\n    install_pytorch(cuda_pytorch_version)\n    \n    # Verify installation\n    verify_installation()\n    \n    # Install remaining requirements\n    install_requirements()\n    \n    print(\"\\n\u2713 Setup complete!\")\n    print(\"You can now run IrintAI Assistant using: python irintai.py\")\n\nif __name__ == \"__main__\":\n    main()\n",
  "D:\\AI\\IrintAI Assistant\\utils\\__init__.py": "\"\"\"\nUtility modules for IrintAI Assistant\n\"\"\"\n\nfrom utils.logger import IrintaiLogger\nfrom utils.system_monitor import SystemMonitor\nfrom file_operations.file_ops import FileOps\nfrom plugins.plugin_event_bus import EventBus\nfrom plugins.plugin_dependency_manager import DependencyManager\nfrom core.settings_manager import SettingsManager\n\n# Import runtime patching utilities\ntry:\n    from diagnostics.runtime_patching import ensure_attribute_exists, ensure_method_exists, patch_plugin_manager\nexcept ImportError:\n    # These will be defined if the file doesn't exist\n    pass\n\n# Make the plugin settings fix available\ntry:\n    from plugins.plugin_settings_fix import fix_plugin_settings_panel\nexcept ImportError:\n    # This is fine if the file doesn't exist\n    pass\n\n__all__ = [\"IrintaiLogger\", \"SystemMonitor\", \"FileOps\", \"EventBus\", \"DependencyManager\", \"SettingsManager\", \"fix_plugin_settings_panel\"]",
  "D:\\AI\\IrintAI Assistant\\file_operations\\file_ops.py": "\"\"\"\nFile operations utilities for the Irintai assistant\n\"\"\"\nimport os\nimport json\nimport shutil\nimport subprocess\nimport sys\nimport time\nfrom typing import Dict, List, Any, Optional, Tuple, Set\n\n# Supported file extensions\nSUPPORTED_EXTENSIONS = ['.py', '.txt', '.md', '.pdf', '.docx', '.json', '.sty']\n\nclass FileOps:\n    \"\"\"File operations utilities for loading, saving, and managing files\"\"\"\n    \n    def __init__(self, logger=None):\n        \"\"\"\n        Initialize the file operations utility\n        \n        Args:\n            logger: Optional logging function\n        \"\"\"\n        self.logger = logger\n        self.content_cache = {}\n        \n    def _check_path_permissions(self, path: str, write_access: bool = False) -> bool:\n        \"\"\"\n        Check if a path has appropriate permissions for access\n        \n        Args:\n            path: Path to check\n            write_access: Whether write access is needed\n            \n        Returns:\n            True if permission check passes, False otherwise\n        \"\"\"\n        try:\n            # Check if path exists\n            if not os.path.exists(path):\n                if write_access:\n                    # For write access, check if parent directory exists and is writable\n                    parent_dir = os.path.dirname(path)\n                    if not os.path.exists(parent_dir):\n                        self.log(f\"[FileOps] Parent directory does not exist: {parent_dir}\")\n                        return False\n                    if not os.access(parent_dir, os.W_OK):\n                        self.log(f\"[FileOps] No write permission for parent directory: {parent_dir}\")\n                        return False\n                    return True\n                else:\n                    self.log(f\"[FileOps] Path does not exist: {path}\")\n                    return False\n                    \n            # Check read permission\n            if not os.access(path, os.R_OK):\n                self.log(f\"[FileOps] No read permission for path: {path}\")\n                return False\n                \n            # Check write permission if needed\n            if write_access and not os.access(path, os.W_OK):\n                self.log(f\"[FileOps] No write permission for path: {path}\")\n                return False\n                \n            return True\n        except Exception as e:\n            self.log(f\"[FileOps] Failed to check permissions for {path}: {e}\")\n            return False\n    \n    def log(self, msg: str) -> None:\n        \"\"\"\n        Log a message if logger is available\n        \n        Args:\n            msg: Message to log\n        \"\"\"\n        if self.logger:\n            self.logger(msg)\n    \n    def read_file(self, file_path: str, encoding: str = 'utf-8') -> Tuple[bool, str]:\n        \"\"\"\n        Read a file and return its content\n        \n        Args:\n            file_path: Path to the file\n            encoding: File encoding\n            \n        Returns:\n            Tuple containing success flag and file content\n        \"\"\"\n        try:\n            with open(file_path, 'r', encoding=encoding, errors='replace') as f:\n                content = f.read()\n                \n            # Cache the content for later use\n            self.content_cache[file_path] = content\n            \n            return True, content\n        except Exception as e:\n            self.log(f\"[File Error] Failed to read {file_path}: {e}\")\n            return False, f\"Error: {str(e)}\"\n    \n    def write_file(self, file_path: str, content: str, encoding: str = 'utf-8') -> bool:\n        \"\"\"\n        Write content to a file\n        \n        Args:\n            file_path: Path to the file\n            content: Content to write\n            encoding: File encoding\n            \n        Returns:\n            True if file written successfully, False otherwise\n        \"\"\"\n        try:\n            # Ensure directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(file_path)), exist_ok=True)\n            \n            with open(file_path, 'w', encoding=encoding) as f:\n                f.write(content)\n                \n            # Update the cache\n            self.content_cache[file_path] = content\n            \n            self.log(f\"[File] Wrote to {file_path}\")\n            return True\n        except Exception as e:\n            self.log(f\"[File Error] Failed to write to {file_path}: {e}\")\n            return False\n    \n    def append_to_file(self, file_path: str, content: str, encoding: str = 'utf-8') -> bool:\n        \"\"\"\n        Append content to a file\n        \n        Args:\n            file_path: Path to the file\n            content: Content to append\n            encoding: File encoding\n            \n        Returns:\n            True if content appended successfully, False otherwise\n        \"\"\"\n        try:\n            # Ensure directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(file_path)), exist_ok=True)\n            \n            with open(file_path, 'a', encoding=encoding) as f:\n                f.write(content)\n                \n            # Update the cache if it exists\n            if file_path in self.content_cache:\n                self.content_cache[file_path] += content\n                \n            self.log(f\"[File] Appended to {file_path}\")\n            return True\n        except Exception as e:\n            self.log(f\"[File Error] Failed to append to {file_path}: {e}\")\n            return False\n    \n    def list_files(self, directory: str, extensions: Optional[List[str]] = None) -> List[str]:\n        \"\"\"\n        List files in a directory with optional extension filtering\n        \n        Args:\n            directory: Directory to list files from\n            extensions: Optional list of file extensions to filter by\n            \n        Returns:\n            List of file paths\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(directory):\n            return []\n        \n        # Perform the listing directly\n        try:\n            files = []\n            for root, _, filenames in os.walk(directory):\n                for filename in filenames:\n                    file_path = os.path.join(root, filename)\n                    if extensions:\n                        if any(filename.endswith(ext) for ext in extensions):\n                            files.append(file_path)\n                    else:\n                        files.append(file_path)\n                        \n            return files\n        except Exception as e:\n            self.log(f\"[File Error] Failed to list files in {directory}: {e}\")\n            return []\n    \n    def load_json(self, file_path: str) -> Tuple[bool, Any]:\n        \"\"\"\n        Load a JSON file\n        \n        Args:\n            file_path: Path to the JSON file\n            \n        Returns:\n            Tuple containing success flag and loaded data\n        \"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                \n            return True, data\n        except Exception as e:\n            self.log(f\"[JSON Error] Failed to load {file_path}: {e}\")\n            return False, None\n    \n    def save_json(self, file_path: str, data: Any, indent: int = 2) -> bool:\n        \"\"\"\n        Save data to a JSON file\n        \n        Args:\n            file_path: Path to the JSON file\n            data: Data to save\n            indent: JSON indentation\n            \n        Returns:\n            True if data saved successfully, False otherwise\n        \"\"\"\n        try:\n            # Ensure directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(file_path)), exist_ok=True)\n            \n            with open(file_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=indent)\n                \n            self.log(f\"[JSON] Saved to {file_path}\")\n            return True\n        except Exception as e:\n            self.log(f\"[JSON Error] Failed to save to {file_path}: {e}\")\n            return False\n    \n    def copy_file(self, source: str, destination: str) -> bool:\n        \"\"\"\n        Copy a file\n        \n        Args:\n            source: Source file path\n            destination: Destination file path\n            \n        Returns:\n            True if file copied successfully, False otherwise\n        \"\"\"\n        try:\n            # Ensure destination directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(destination)), exist_ok=True)\n            \n            shutil.copy2(source, destination)\n            \n            self.log(f\"[File] Copied {source} to {destination}\")\n            return True\n        except Exception as e:\n            self.log(f\"[File Error] Failed to copy {source} to {destination}: {e}\")\n            return False\n    \n    def move_file(self, source: str, destination: str) -> bool:\n        \"\"\"\n        Move a file\n        \n        Args:\n            source: Source file path\n            destination: Destination file path\n            \n        Returns:\n            True if file moved successfully, False otherwise\n        \"\"\"\n        try:\n            # Ensure destination directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(destination)), exist_ok=True)\n            \n            shutil.move(source, destination)\n            \n            # Update cache if needed\n            if source in self.content_cache:\n                self.content_cache[destination] = self.content_cache[source]\n                del self.content_cache[source]\n                \n            self.log(f\"[File] Moved {source} to {destination}\")\n            return True\n        except Exception as e:\n            self.log(f\"[File Error] Failed to move {source} to {destination}: {e}\")\n            return False\n    \n    def delete_file(self, file_path: str) -> bool:\n        \"\"\"\n        Delete a file\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            True if file deleted successfully, False otherwise\n        \"\"\"\n        try:\n            os.remove(file_path)\n            \n            # Remove from cache if present\n            if file_path in self.content_cache:\n                del self.content_cache[file_path]\n                \n            self.log(f\"[File] Deleted {file_path}\")\n            return True\n        except Exception as e:\n            self.log(f\"[File Error] Failed to delete {file_path}: {e}\")\n            return False\n    \n    def ensure_dir(self, directory: str) -> bool:\n        \"\"\"\n        Ensure a directory exists\n        \n        Args:\n            directory: Directory path\n            \n        Returns:\n            True if directory exists or was created, False otherwise\n        \"\"\"\n        try:\n            os.makedirs(directory, exist_ok=True)\n            return True\n        except Exception as e:\n            self.log(f\"[Directory Error] Failed to create {directory}: {e}\")\n            return False\n    \n    def get_file_info(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Get information about a file\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            Dictionary with file information\n        \"\"\"\n        try:\n            stats = os.stat(file_path)\n            return {\n                \"path\": file_path,\n                \"name\": os.path.basename(file_path),\n                \"extension\": os.path.splitext(file_path)[1],\n                \"size\": stats.st_size,\n                \"created\": stats.st_ctime,\n                \"modified\": stats.st_mtime,\n                \"exists\": True\n            }\n        except Exception as e:\n            self.log(f\"[File Error] Failed to get info for {file_path}: {e}\")\n            return {\n                \"path\": file_path,\n                \"name\": os.path.basename(file_path),\n                \"extension\": os.path.splitext(file_path)[1],\n                \"exists\": False,\n                \"error\": str(e)\n            }\n    \n    def open_folder(self, folder_path: str) -> bool:\n        \"\"\"\n        Open a folder in the file explorer\n        \n        Args:\n            folder_path: Path to the folder\n            \n        Returns:\n            True if folder opened successfully, False otherwise\n        \"\"\"\n        try:\n            if not os.path.exists(folder_path):\n                self.ensure_dir(folder_path)\n            \n            # Open folder based on OS\n            if os.name == 'nt':  # Windows\n                os.startfile(folder_path)\n            elif os.name == 'posix':  # macOS, Linux\n                subprocess.run(['open' if sys.platform == 'darwin' else 'xdg-open', folder_path])\n                \n            self.log(f\"[Folder] Opened {folder_path}\")\n            return True\n        except Exception as e:\n            self.log(f\"[Folder Error] Failed to open {folder_path}: {e}\")\n            return False\n    \n    def get_supported_extensions(self) -> List[str]:\n        \"\"\"\n        Get list of supported file extensions\n        \n        Returns:\n            List of supported extensions\n        \"\"\"\n        return SUPPORTED_EXTENSIONS\n    \n    def add_supported_extension(self, extension: str) -> None:\n        \"\"\"\n        Add a file extension to the supported list\n        \n        Args:\n            extension: File extension to add (including the dot)\n        \"\"\"\n        global SUPPORTED_EXTENSIONS\n        if extension not in SUPPORTED_EXTENSIONS:\n            SUPPORTED_EXTENSIONS.append(extension)\n            \n    def get_content_types(self) -> Dict[str, str]:\n        \"\"\"\n        Get a mapping of file extensions to content types\n        \n        Returns:\n            Dictionary mapping file extensions to content types\n        \"\"\"\n        return {\n            '.py': 'Python Source',\n            '.txt': 'Text File',\n            '.md': 'Markdown',\n            '.pdf': 'PDF Document',\n            '.docx': 'Word Document',\n            '.json': 'JSON Data',\n            '.sty': 'LaTeX Style',\n            '.csv': 'CSV Data',\n            '.html': 'HTML Document',\n            '.css': 'CSS Stylesheet',\n            '.js': 'JavaScript',\n            '.xml': 'XML Document',\n            '.yaml': 'YAML Data',\n            '.yml': 'YAML Data',\n            '.ini': 'Configuration File',\n            '.cfg': 'Configuration File',\n            '.log': 'Log File'\n        }\n        \n    def get_file_extension(self, file_path: str) -> str:\n        \"\"\"\n        Get the extension of a file\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            File extension\n        \"\"\"\n        return os.path.splitext(file_path)[1].lower()\n        \n    def get_files_by_type(self, directory: str, extension: str) -> List[str]:\n        \"\"\"\n        Get all files of a specific type in a directory\n        \n        Args:\n            directory: Directory to search\n            extension: File extension to filter by\n            \n        Returns:\n            List of file paths\n        \"\"\"\n        return self.list_files(directory, [extension])\n        \n    def get_file_tree(self, directory: str, max_depth: int = 3) -> Dict[str, Any]:\n        \"\"\"\n        Get a tree representation of files in a directory\n        \n        Args:\n            directory: Directory to scan\n            max_depth: Maximum directory depth to scan\n            \n        Returns:\n            Dictionary representing the file tree\n        \"\"\"\n        def scan_dir(path: str, current_depth: int) -> Dict[str, Any]:\n            if current_depth > max_depth:\n                return {\"name\": os.path.basename(path), \"type\": \"directory\", \"truncated\": True}\n                \n            result = {\n                \"name\": os.path.basename(path),\n                \"path\": path,\n                \"type\": \"directory\",\n                \"children\": []\n            }\n            \n            try:\n                for item in os.listdir(path):\n                    item_path = os.path.join(path, item)\n                    if os.path.isdir(item_path):\n                        result[\"children\"].append(scan_dir(item_path, current_depth + 1))\n                    else:\n                        result[\"children\"].append({\n                            \"name\": item,\n                            \"path\": item_path,\n                            \"type\": \"file\",\n                            \"extension\": self.get_file_extension(item)\n                        })\n            except Exception as e:\n                self.log(f\"[File Tree Error] Failed to scan {path}: {e}\")\n                result[\"error\"] = str(e)\n                \n            return result\n            \n        return scan_dir(directory, 1)\n        \n    def search_files(self, directory: str, search_term: str, extensions: Optional[List[str]] = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        Search for files containing a specific term\n        \n        Args:\n            directory: Directory to search\n            search_term: Term to search for\n            extensions: Optional list of file extensions to filter by\n            \n        Returns:\n            List of dictionaries with file information and matches\n        \"\"\"\n        results = []\n        files = self.list_files(directory, extensions)\n        \n        for file_path in files:\n            try:\n                success, content = self.read_file(file_path)\n                if success and search_term.lower() in content.lower():\n                    # Count occurrences\n                    count = content.lower().count(search_term.lower())\n                    \n                    # Get some context around matches\n                    context = []\n                    content_lower = content.lower()\n                    search_lower = search_term.lower()\n                    \n                    start = 0\n                    while True:\n                        pos = content_lower.find(search_lower, start)\n                        if pos == -1:\n                            break\n                            \n                        # Get context (50 chars before and after)\n                        ctx_start = max(0, pos - 50)\n                        ctx_end = min(len(content), pos + len(search_term) + 50)\n                        context_str = content[ctx_start:ctx_end]\n                        \n                        # Highlight the match\n                        match_start = max(0, pos - ctx_start)\n                        match_end = match_start + len(search_term)\n                        \n                        context.append({\n                            \"before\": context_str[:match_start],\n                            \"match\": context_str[match_start:match_end],\n                            \"after\": context_str[match_end:]\n                        })\n                        \n                        start = pos + len(search_term)\n                        \n                        # Limit to 5 contexts\n                        if len(context) >= 5:\n                            break\n                    \n                    results.append({\n                        \"path\": file_path,\n                        \"name\": os.path.basename(file_path),\n                        \"extension\": self.get_file_extension(file_path),\n                        \"count\": count,\n                        \"context\": context\n                    })\n            except Exception as e:\n                self.log(f\"[Search Error] Failed to search {file_path}: {e}\")\n                \n        return results\n    \n    def get_plugin_directory(self, plugin_id: str, create: bool = True) -> str:\n        \"\"\"\n        Get the plugin data directory for a specific plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            create: Create the directory if it doesn't exist\n            \n        Returns:\n            Path to the plugin directory\n        \"\"\"\n        # Base plugin data directory (can be configured)\n        base_dir = \"plugin_data\"\n        \n        # Create plugin-specific directory path\n        plugin_dir = os.path.join(base_dir, plugin_id)\n        \n        if create:\n            self.ensure_dir(plugin_dir)\n            \n        return plugin_dir\n        \n    def read_plugin_file(self, plugin_id: str, filename: str, encoding: str = 'utf-8') -> Tuple[bool, str]:\n        \"\"\"\n        Read a file from a plugin's data directory\n        \n        Args:\n            plugin_id: Plugin identifier\n            filename: Name of the file to read\n            encoding: File encoding\n            \n        Returns:\n            Tuple containing success flag and file content\n        \"\"\"\n        plugin_dir = self.get_plugin_directory(plugin_id)\n        file_path = os.path.join(plugin_dir, filename)\n        \n        return self.read_file(file_path, encoding)\n        \n    def write_plugin_file(self, plugin_id: str, filename: str, content: str, encoding: str = 'utf-8') -> bool:\n        \"\"\"\n        Write content to a file in a plugin's data directory\n        \n        Args:\n            plugin_id: Plugin identifier\n            filename: Name of the file to write\n            content: Content to write\n            encoding: File encoding\n            \n        Returns:\n            True if file written successfully, False otherwise\n        \"\"\"\n        plugin_dir = self.get_plugin_directory(plugin_id)\n        file_path = os.path.join(plugin_dir, filename)\n        \n        return self.write_file(file_path, content, encoding)\n        \n    def list_plugin_files(self, plugin_id: str, extensions: Optional[List[str]] = None) -> List[str]:\n        \"\"\"\n        List files in a plugin's data directory\n        \n        Args:\n            plugin_id: Plugin identifier\n            extensions: Optional list of file extensions to filter by\n            \n        Returns:\n            List of file paths\n        \"\"\"\n        plugin_dir = self.get_plugin_directory(plugin_id, create=False)\n        \n        if not os.path.exists(plugin_dir):\n            return []\n            \n        return self.list_files(plugin_dir, extensions)\n        \n    def load_plugin_json(self, plugin_id: str, filename: str) -> Tuple[bool, Any]:\n        \"\"\"\n        Load a JSON file from a plugin's data directory\n        \n        Args:\n            plugin_id: Plugin identifier\n            filename: Name of the JSON file\n            \n        Returns:\n            Tuple containing success flag and loaded data\n        \"\"\"\n        plugin_dir = self.get_plugin_directory(plugin_id)\n        file_path = os.path.join(plugin_dir, filename)\n        \n        return self.load_json(file_path)\n        \n    def save_plugin_json(self, plugin_id: str, filename: str, data: Any, indent: int = 2) -> bool:\n        \"\"\"\n        Save data to a JSON file in a plugin's data directory\n        \n        Args:\n            plugin_id: Plugin identifier\n            filename: Name of the JSON file\n            data: Data to save\n            indent: JSON indentation\n            \n        Returns:\n            True if data saved successfully, False otherwise\n        \"\"\"\n        plugin_dir = self.get_plugin_directory(plugin_id)\n        file_path = os.path.join(plugin_dir, filename)\n        \n        return self.save_json(file_path, data, indent)\n        \n    def delete_plugin_file(self, plugin_id: str, filename: str) -> bool:\n        \"\"\"\n        Delete a file from a plugin's data directory\n        \n        Args:\n            plugin_id: Plugin identifier\n            filename: Name of the file to delete\n            \n        Returns:\n            True if file deleted successfully, False otherwise\n        \"\"\"\n        plugin_dir = self.get_plugin_directory(plugin_id, create=False)\n        file_path = os.path.join(plugin_dir, filename)\n        \n        return self.delete_file(file_path)\n        \n    def get_plugin_directory(self) -> str:\n        \"\"\"\n        Get the plugin's data directory\n        \n        Returns:\n            Path to the plugin's data directory\n        \"\"\"\n        return self.plugin_dir\n        \n    def ensure_dir(self, directory: str) -> bool:\n        \"\"\"\n        Ensure a directory exists with sandbox restrictions\n        \n        Args:\n            directory: Directory path\n            \n        Returns:\n            True if directory exists or was created, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(directory, write_access=True):\n            return False\n            \n        # Perform the directory creation\n        return self.file_ops.ensure_dir(directory)\n        \n    def list_files(self, directory: str, extensions: Optional[List[str]] = None) -> List[str]:\n        \"\"\"\n        List files in a directory with sandbox restrictions\n        \n        Args:\n            directory: Directory to list files from\n            extensions: Optional list of file extensions to filter by\n            \n        Returns:\n            List of file paths\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(directory):\n            return []\n            \n        # Perform the listing directly\n        try:\n            files = []\n            for root, _, filenames in os.walk(directory):\n                for filename in filenames:\n                    file_path = os.path.join(root, filename)\n                    if extensions:\n                        if any(filename.endswith(ext) for ext in extensions):\n                            files.append(file_path)\n                    else:\n                        files.append(file_path)\n                        \n            return files\n        except Exception as e:\n            self.log(f\"[File Error] Failed to list files in {directory}: {e}\")\n            return []\n    \n    def get_file_info(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Get information about a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            Dictionary with file information\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path):\n            return {\n                \"path\": file_path,\n                \"name\": os.path.basename(file_path),\n                \"extension\": os.path.splitext(file_path)[1],\n                \"exists\": False,\n                \"error\": \"Access denied\"\n            }\n            \n        # Perform the info retrieval\n        return self.file_ops.get_file_info(file_path)\n    \n    def load_json(self, file_path: str) -> Tuple[bool, Any]:\n        \"\"\"\n        Load a JSON file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the JSON file\n            \n        Returns:\n            Tuple containing success flag and loaded data\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path):\n            return False, \"Access denied\"\n            \n        # Perform the JSON load\n        return self.file_ops.load_json(file_path)\n    \n    def save_json(self, file_path: str, data: Any, indent: int = 2) -> bool:\n        \"\"\"\n        Save data to a JSON file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the JSON file\n            data: Data to save\n            indent: JSON indentation\n            \n        Returns:\n            True if data saved successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the JSON save\n        return self.file_ops.save_json(file_path, data, indent)\n    \n    def copy_file(self, source: str, destination: str) -> bool:\n        \"\"\"\n        Copy a file with sandbox restrictions\n        \n        Args:\n            source: Source file path\n            destination: Destination file path\n            \n        Returns:\n            True if file copied successfully, False otherwise\n        \"\"\"\n        # Check path permissions for both source and destination\n        if not self._check_path_permissions(source):\n            return False\n            \n        if not self._check_path_permissions(destination, write_access=True):\n            return False\n            \n        # Perform the copy\n        return self.file_ops.copy_file(source, destination)\n    \n    def move_file(self, source: str, destination: str) -> bool:\n        \"\"\"\n        Move a file with sandbox restrictions\n        \n        Args:\n            source: Source file path\n            destination: Destination file path\n            \n        Returns:\n            True if file moved successfully, False otherwise\n        \"\"\"\n        # Check path permissions for both source and destination\n        if not self._check_path_permissions(source, write_access=True):\n            return False\n            \n        if not self._check_path_permissions(destination, write_access=True):\n            return False\n            \n        # Perform the move\n        return self.file_ops.move_file(source, destination)\n    \n    def delete_file(self, file_path: str) -> bool:\n        \"\"\"\n        Delete a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            True if file deleted successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the delete\n        return self.file_ops.delete_file(file_path)\n        \n    def get_plugin_data_dir(self) -> str:\n        \"\"\"\n        Get the plugin's data directory\n        \n        Returns:\n            Path to the plugin's data directory\n        \"\"\"\n        return self.plugin_dir\n        \n    def get_plugin_config_dir(self) -> str:\n        \"\"\"\n        Get the plugin's configuration directory\n        \n        Returns:\n            Path to the plugin's configuration directory\n        \"\"\"\n        return self.config_dir\n        \n    def create_temp_file(self, prefix: str = None, suffix: str = None, content: str = None) -> Tuple[bool, str]:\n        \"\"\"\n        Create a temporary file in the plugin's data directory\n        \n        Args:\n            prefix: Optional prefix for the filename\n            suffix: Optional suffix for the filename\n            content: Optional content to write to the file\n            \n        Returns:\n            Tuple containing success flag and path to the temp file\n        \"\"\"\n        import uuid\n        \n        # Generate a unique filename\n        prefix = prefix or self.plugin_id + \"_\"\n        suffix = suffix or \".tmp\"\n        filename = f\"{prefix}{uuid.uuid4().hex}{suffix}\"\n        \n        # Create path in plugin's temp directory\n        temp_dir = os.path.join(self.plugin_dir, \"temp\")\n        self.ensure_dir(temp_dir)\n        \n        temp_path = os.path.join(temp_dir, filename)\n        \n        # Write content if provided\n        if content:\n            success = self.write_file(temp_path, content)\n            return success, temp_path if success else \"\"\n        else:\n            # Just create an empty file\n            success = self.write_file(temp_path, \"\")\n            return success, temp_path if success else \"\"\n    \n    def cleanup_temp_files(self, max_age_hours: int = 24) -> int:\n        \"\"\"\n        Clean up old temporary files in the plugin's temp directory\n        \n        Args:\n            max_age_hours: Maximum age of files to keep in hours\n            \n        Returns:\n            Number of files deleted\n        \"\"\"\n        temp_dir = os.path.join(self.plugin_dir, \"temp\")\n        if not os.path.exists(temp_dir):\n            return 0\n            \n        # Calculate cutoff time\n        cutoff_time = time.time() - (max_age_hours * 3600)\n        \n        # Find and delete old files\n        count = 0\n        for item in os.listdir(temp_dir):\n            file_path = os.path.join(temp_dir, item)\n            if os.path.isfile(file_path):\n                # Check file modification time\n                if os.path.getmtime(file_path) < cutoff_time:\n                    if self.delete_file(file_path):\n                        count += 1\n                        \n        return count\n    \nclass PluginSandboxedFileOps:\n    \"\"\"Sandboxed file operations for plugins with restricted access\"\"\"\n    \n    def __init__(self, file_ops: FileOps, plugin_id: str, base_dir: str = None, logger=None):\n        \"\"\"\n        Initialize sandboxed file operations for a plugin\n        \n        Args:\n            file_ops: FileOps instance to wrap\n            plugin_id: Plugin identifier\n            base_dir: Base directory for the application\n            logger: Optional logging function\n        \"\"\"\n        self.file_ops = file_ops\n        self.plugin_id = plugin_id\n        self.logger = logger\n        \n        # Set up base directories\n        if base_dir:\n            self.base_dir = os.path.abspath(base_dir)\n        else:\n            self.base_dir = os.path.abspath(os.getcwd())\n            \n        # Set up plugin directories\n        self.plugin_dir = os.path.join(self.base_dir, \"data\", \"plugins\", \"data\", plugin_id)\n        self.config_dir = os.path.join(self.base_dir, \"data\", \"plugins\", \"config\", plugin_id)\n        \n        # Create directories if they don't exist\n        os.makedirs(self.plugin_dir, exist_ok=True)\n        os.makedirs(self.config_dir, exist_ok=True)\n        \n        # Safe paths that this plugin can access\n        self.safe_paths = [\n            self.plugin_dir,\n            self.config_dir,\n            # Optionally allow read-only access to shared resources\n            os.path.join(self.base_dir, \"resources\", \"shared\")\n        ]\n        \n    def log(self, message: str, level: str = \"INFO\") -> None:\n        \"\"\"\n        Log a message if logger is available\n        \n        Args:\n            message: Message to log\n            level: Log level\n        \"\"\"\n        if self.logger:\n            self.logger(f\"[PluginFileOps:{self.plugin_id}] {message}\", level)\n            \n    def _check_path_permissions(self, path: str, write_access: bool = False) -> bool:\n        \"\"\"\n        Check if a path has appropriate permissions for access\n        \n        Args:\n            path: The path to check\n            write_access: Whether write access is required\n            \n        Returns:\n            True if path has appropriate permissions, False otherwise\n        \"\"\"\n        try:\n            # Check if path exists\n            if not os.path.exists(path):\n                if write_access:\n                    # For write access, check if parent directory exists and is writable\n                    parent_dir = os.path.dirname(path)\n                    if not os.path.exists(parent_dir):\n                        self.log(f\"[File Warning] Parent directory does not exist: {parent_dir}\")\n                        return False\n                    if not os.access(parent_dir, os.W_OK):\n                        self.log(f\"[File Warning] No write permission for parent directory: {parent_dir}\")\n                        return False\n                    return True\n                else:\n                    self.log(f\"[File Warning] Path does not exist: {path}\")\n                    return False\n            \n            # Check read permission\n            if not os.access(path, os.R_OK):\n                self.log(f\"[File Warning] No read permission for path: {path}\")\n                return False\n                \n            # Check write permission if needed\n            if write_access and not os.access(path, os.W_OK):\n                self.log(f\"[File Warning] No write permission for path: {path}\")\n                return False\n                \n            return True\n        except Exception as e:\n            self.log(f\"[File Error] Failed to check permissions for {path}: {e}\")\n            return False\n    \n    def write_file(self, file_path: str, content: str, encoding: str = 'utf-8') -> bool:\n        \"\"\"\n        Write content to a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            content: Content to write\n            encoding: File encoding\n            \n        Returns:\n            True if file written successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the write\n        return self.file_ops.write_file(file_path, content, encoding)\n        \n    def append_to_file(self, file_path: str, content: str, encoding: str = 'utf-8') -> bool:\n        \"\"\"\n        Append content to a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            content: Content to append\n            encoding: File encoding\n            \n        Returns:\n            True if content appended successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the append\n        return self.file_ops.append_to_file(file_path, content, encoding)\n        \n    def ensure_dir(self, directory: str) -> bool:\n        \"\"\"\n        Ensure a directory exists with sandbox restrictions\n        \n        Args:\n            directory: Directory path\n            \n        Returns:\n            True if directory exists or was created, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(directory, write_access=True):\n            return False\n            \n        # Perform the directory creation\n        return self.file_ops.ensure_dir(directory)\n        \n    def list_files(self, directory: str, extensions: Optional[List[str]] = None) -> List[str]:\n        \"\"\"\n        List files in a directory with sandbox restrictions\n        \n        Args:\n            directory: Directory to list files from\n            extensions: Optional list of file extensions to filter by\n            \n        Returns:\n            List of file paths\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(directory):\n            return []\n            \n        # Perform the listing directly\n        try:\n            files = []\n            for root, _, filenames in os.walk(directory):\n                for filename in filenames:\n                    file_path = os.path.join(root, filename)\n                    if extensions:\n                        if any(filename.endswith(ext) for ext in extensions):\n                            files.append(file_path)\n                    else:\n                        files.append(file_path)\n                        \n            return files\n        except Exception as e:\n            self.log(f\"[File Error] Failed to list files in {directory}: {e}\")\n            return []\n    \n    def get_file_info(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Get information about a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            Dictionary with file information\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path):\n            return {\n                \"path\": file_path,\n                \"name\": os.path.basename(file_path),\n                \"extension\": os.path.splitext(file_path)[1],\n                \"exists\": False,\n                \"error\": \"Access denied\"\n            }\n            \n        # Perform the info retrieval\n        return self.file_ops.get_file_info(file_path)\n    \n    def load_json(self, file_path: str) -> Tuple[bool, Any]:\n        \"\"\"\n        Load a JSON file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the JSON file\n            \n        Returns:\n            Tuple containing success flag and loaded data\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path):\n            return False, \"Access denied\"\n            \n        # Perform the JSON load\n        return self.file_ops.load_json(file_path)\n    \n    def save_json(self, file_path: str, data: Any, indent: int = 2) -> bool:\n        \"\"\"\n        Save data to a JSON file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the JSON file\n            data: Data to save\n            indent: JSON indentation\n            \n        Returns:\n            True if data saved successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the JSON save\n        return self.file_ops.save_json(file_path, data, indent)\n    \n    def copy_file(self, source: str, destination: str) -> bool:\n        \"\"\"\n        Copy a file with sandbox restrictions\n        \n        Args:\n            source: Source file path\n            destination: Destination file path\n            \n        Returns:\n            True if file copied successfully, False otherwise\n        \"\"\"\n        # Check path permissions for both source and destination\n        if not self._check_path_permissions(source):\n            return False\n            \n        if not self._check_path_permissions(destination, write_access=True):\n            return False\n            \n        # Perform the copy\n        return self.file_ops.copy_file(source, destination)\n    \n    def move_file(self, source: str, destination: str) -> bool:\n        \"\"\"\n        Move a file with sandbox restrictions\n        \n        Args:\n            source: Source file path\n            destination: Destination file path\n            \n        Returns:\n            True if file moved successfully, False otherwise\n        \"\"\"\n        # Check path permissions for both source and destination\n        if not self._check_path_permissions(source, write_access=True):\n            return False\n            \n        if not self._check_path_permissions(destination, write_access=True):\n            return False\n            \n        # Perform the move\n        return self.file_ops.move_file(source, destination)\n    \n    def delete_file(self, file_path: str) -> bool:\n        \"\"\"\n        Delete a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            True if file deleted successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the delete\n        return self.file_ops.delete_file(file_path)\n        \n    def get_plugin_data_dir(self) -> str:\n        \"\"\"\n        Get the plugin's data directory\n        \n        Returns:\n            Path to the plugin's data directory\n        \"\"\"\n        return self.plugin_dir\n        \n    def get_plugin_config_dir(self) -> str:\n        \"\"\"\n        Get the plugin's configuration directory\n        \n        Returns:\n            Path to the plugin's configuration directory\n        \"\"\"\n        return self.config_dir\n        \n    def create_temp_file(self, prefix: str = None, suffix: str = None, content: str = None) -> Tuple[bool, str]:\n        \"\"\"\n        Create a temporary file in the plugin's data directory\n        \n        Args:\n            prefix: Optional prefix for the filename\n            suffix: Optional suffix for the filename\n            content: Optional content to write to the file\n            \n        Returns:\n            Tuple containing success flag and path to the temp file\n        \"\"\"\n        import uuid\n        \n        # Generate a unique filename\n        prefix = prefix or self.plugin_id + \"_\"\n        suffix = suffix or \".tmp\"\n        filename = f\"{prefix}{uuid.uuid4().hex}{suffix}\"\n        \n        # Create path in plugin's temp directory\n        temp_dir = os.path.join(self.plugin_dir, \"temp\")\n        self.ensure_dir(temp_dir)\n        \n        temp_path = os.path.join(temp_dir, filename)\n        \n        # Write content if provided\n        if content:\n            success = self.write_file(temp_path, content)\n            return success, temp_path if success else \"\"\n        else:\n            # Just create an empty file\n            success = self.write_file(temp_path, \"\")\n            return success, temp_path if success else \"\"\n    \n    def cleanup_temp_files(self, max_age_hours: int = 24) -> int:\n        \"\"\"\n        Clean up old temporary files in the plugin's temp directory\n        \n        Args:\n            max_age_hours: Maximum age of files to keep in hours\n            \n        Returns:\n            Number of files deleted\n        \"\"\"\n        temp_dir = os.path.join(self.plugin_dir, \"temp\")\n        if not os.path.exists(temp_dir):\n            return 0\n            \n        # Calculate cutoff time\n        cutoff_time = time.time() - (max_age_hours * 3600)\n        \n        # Find and delete old files\n        count = 0\n        for item in os.listdir(temp_dir):\n            file_path = os.path.join(temp_dir, item)\n            if os.path.isfile(file_path):\n                # Check file modification time\n                if os.path.getmtime(file_path) < cutoff_time:\n                    if self.delete_file(file_path):\n                        count += 1\n                        \n        return count\n    \nclass PluginSandboxedFileOps:\n    \"\"\"Sandboxed file operations for plugins with restricted access\"\"\"\n    \n    def __init__(self, file_ops: FileOps, plugin_id: str, base_dir: str = None, logger=None):\n        \"\"\"\n        Initialize sandboxed file operations for a plugin\n        \n        Args:\n            file_ops: FileOps instance to wrap\n            plugin_id: Plugin identifier\n            base_dir: Base directory for the application\n            logger: Optional logging function\n        \"\"\"\n        self.file_ops = file_ops\n        self.plugin_id = plugin_id\n        self.logger = logger\n        \n        # Set up base directories\n        if base_dir:\n            self.base_dir = os.path.abspath(base_dir)\n        else:\n            self.base_dir = os.path.abspath(os.getcwd())\n            \n        # Set up plugin directories\n        self.plugin_dir = os.path.join(self.base_dir, \"data\", \"plugins\", \"data\", plugin_id)\n        self.config_dir = os.path.join(self.base_dir, \"data\", \"plugins\", \"config\", plugin_id)\n        \n        # Create directories if they don't exist\n        os.makedirs(self.plugin_dir, exist_ok=True)\n        os.makedirs(self.config_dir, exist_ok=True)\n        \n        # Safe paths that this plugin can access\n        self.safe_paths = [\n            self.plugin_dir,\n            self.config_dir,\n            # Optionally allow read-only access to shared resources\n            os.path.join(self.base_dir, \"resources\", \"shared\")\n        ]\n        \n    def log(self, message: str, level: str = \"INFO\") -> None:\n        \"\"\"\n        Log a message if logger is available\n        \n        Args:\n            message: Message to log\n            level: Log level\n        \"\"\"\n        if self.logger:\n            self.logger(f\"[PluginFileOps:{self.plugin_id}] {message}\", level)\n            \n    def _check_path_permissions(self, path: str, write_access: bool = False) -> bool:\n        \"\"\"\n        Check if a path has appropriate permissions for access\n        \n        Args:\n            path: The path to check\n            write_access: Whether write access is required\n            \n        Returns:\n            True if path has appropriate permissions, False otherwise\n        \"\"\"\n        try:\n            # Check if path exists\n            if not os.path.exists(path):\n                if write_access:\n                    # For write access, check if parent directory exists and is writable\n                    parent_dir = os.path.dirname(path)\n                    if not os.path.exists(parent_dir):\n                        self.log(f\"[File Warning] Parent directory does not exist: {parent_dir}\")\n                        return False\n                    if not os.access(parent_dir, os.W_OK):\n                        self.log(f\"[File Warning] No write permission for parent directory: {parent_dir}\")\n                        return False\n                    return True\n                else:\n                    self.log(f\"[File Warning] Path does not exist: {path}\")\n                    return False\n            \n            # Check read permission\n            if not os.access(path, os.R_OK):\n                self.log(f\"[File Warning] No read permission for path: {path}\")\n                return False\n                \n            # Check write permission if needed\n            if write_access and not os.access(path, os.W_OK):\n                self.log(f\"[File Warning] No write permission for path: {path}\")\n                return False\n                \n            return True\n        except Exception as e:\n            self.log(f\"[File Error] Failed to check permissions for {path}: {e}\")\n            return False\n    \n    def write_file(self, file_path: str, content: str, encoding: str = 'utf-8') -> bool:\n        \"\"\"\n        Write content to a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            content: Content to write\n            encoding: File encoding\n            \n        Returns:\n            True if file written successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the write\n        return self.file_ops.write_file(file_path, content, encoding)\n        \n    def append_to_file(self, file_path: str, content: str, encoding: str = 'utf-8') -> bool:\n        \"\"\"\n        Append content to a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            content: Content to append\n            encoding: File encoding\n            \n        Returns:\n            True if content appended successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the append\n        return self.file_ops.append_to_file(file_path, content, encoding)\n        \n    def ensure_dir(self, directory: str) -> bool:\n        \"\"\"\n        Ensure a directory exists with sandbox restrictions\n        \n        Args:\n            directory: Directory path\n            \n        Returns:\n            True if directory exists or was created, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(directory, write_access=True):\n            return False\n            \n        # Perform the directory creation\n        return self.file_ops.ensure_dir(directory)\n        \n    def list_files(self, directory: str, extensions: Optional[List[str]] = None) -> List[str]:\n        \"\"\"\n        List files in a directory with sandbox restrictions\n        \n        Args:\n            directory: Directory to list files from\n            extensions: Optional list of file extensions to filter by\n            \n        Returns:\n            List of file paths\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(directory):\n            return []\n            \n        # Perform the listing directly\n        try:\n            files = []\n            for root, _, filenames in os.walk(directory):\n                for filename in filenames:\n                    file_path = os.path.join(root, filename)\n                    if extensions:\n                        if any(filename.endswith(ext) for ext in extensions):\n                            files.append(file_path)\n                    else:\n                        files.append(file_path)\n                        \n            return files\n        except Exception as e:\n            self.log(f\"[File Error] Failed to list files in {directory}: {e}\")\n            return []\n    \n    def get_file_info(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Get information about a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            Dictionary with file information\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path):\n            return {\n                \"path\": file_path,\n                \"name\": os.path.basename(file_path),\n                \"extension\": os.path.splitext(file_path)[1],\n                \"exists\": False,\n                \"error\": \"Access denied\"\n            }\n            \n        # Perform the info retrieval\n        return self.file_ops.get_file_info(file_path)\n    \n    def load_json(self, file_path: str) -> Tuple[bool, Any]:\n        \"\"\"\n        Load a JSON file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the JSON file\n            \n        Returns:\n            Tuple containing success flag and loaded data\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path):\n            return False, \"Access denied\"\n            \n        # Perform the JSON load\n        return self.file_ops.load_json(file_path)\n    \n    def save_json(self, file_path: str, data: Any, indent: int = 2) -> bool:\n        \"\"\"\n        Save data to a JSON file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the JSON file\n            data: Data to save\n            indent: JSON indentation\n            \n        Returns:\n            True if data saved successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the JSON save\n        return self.file_ops.save_json(file_path, data, indent)\n    \n    def copy_file(self, source: str, destination: str) -> bool:\n        \"\"\"\n        Copy a file with sandbox restrictions\n        \n        Args:\n            source: Source file path\n            destination: Destination file path\n            \n        Returns:\n            True if file copied successfully, False otherwise\n        \"\"\"\n        # Check path permissions for both source and destination\n        if not self._check_path_permissions(source):\n            return False\n            \n        if not self._check_path_permissions(destination, write_access=True):\n            return False\n            \n        # Perform the copy\n        return self.file_ops.copy_file(source, destination)\n    \n    def move_file(self, source: str, destination: str) -> bool:\n        \"\"\"\n        Move a file with sandbox restrictions\n        \n        Args:\n            source: Source file path\n            destination: Destination file path\n            \n        Returns:\n            True if file moved successfully, False otherwise\n        \"\"\"\n        # Check path permissions for both source and destination\n        if not self._check_path_permissions(source, write_access=True):\n            return False\n            \n        if not self._check_path_permissions(destination, write_access=True):\n            return False\n            \n        # Perform the move\n        return self.file_ops.move_file(source, destination)\n    \n    def delete_file(self, file_path: str) -> bool:\n        \"\"\"\n        Delete a file with sandbox restrictions\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            True if file deleted successfully, False otherwise\n        \"\"\"\n        # Check path permissions\n        if not self._check_path_permissions(file_path, write_access=True):\n            return False\n            \n        # Perform the delete\n        return self.file_ops.delete_file(file_path)\n        \n    def get_plugin_data_dir(self) -> str:\n        \"\"\"\n        Get the plugin's data directory\n        \n        Returns:\n            Path to the plugin's data directory\n        \"\"\"\n        return self.plugin_dir\n        \n    def get_plugin_config_dir(self) -> str:\n        \"\"\"\n        Get the plugin's configuration directory\n        \n        Returns:\n            Path to the plugin's configuration directory\n        \"\"\"\n        return self.config_dir\n        \n    def create_temp_file(self, prefix: str = None, suffix: str = None, content: str = None) -> Tuple[bool, str]:\n        \"\"\"\n        Create a temporary file in the plugin's data directory\n        \n        Args:\n            prefix: Optional prefix for the filename\n            suffix: Optional suffix for the filename\n            content: Optional content to write to the file\n            \n        Returns:\n            Tuple containing success flag and path to the temp file\n        \"\"\"\n        import uuid\n        \n        # Generate a unique filename\n        prefix = prefix or self.plugin_id + \"_\"\n        suffix = suffix or \".tmp\"\n        filename = f\"{prefix}{uuid.uuid4().hex}{suffix}\"\n        \n        # Create path in plugin's temp directory\n        temp_dir = os.path.join(self.plugin_dir, \"temp\")\n        self.ensure_dir(temp_dir)\n        \n        temp_path = os.path.join(temp_dir, filename)\n        \n        # Write content if provided\n        if content:\n            success = self.write_file(temp_path, content)\n            return success, temp_path if success else \"\"\n        else:\n            # Just create an empty file\n            success = self.write_file(temp_path, \"\")\n            return success, temp_path if success else \"\"\n    \n    def cleanup_temp_files(self, max_age_hours: int = 24) -> int:\n        \"\"\"\n        Clean up old temporary files in the plugin's temp directory\n        \n        Args:\n            max_age_hours: Maximum age of files to keep in hours\n            \n        Returns:\n            Number of files deleted\n        \"\"\"\n        temp_dir = os.path.join(self.plugin_dir, \"temp\")\n        if not os.path.exists(temp_dir):\n            return 0\n            \n        # Calculate cutoff time\n        cutoff_time = time.time() - (max_age_hours * 3600)\n        \n        # Find and delete old files\n        count = 0\n        for item in os.listdir(temp_dir):\n            file_path = os.path.join(temp_dir, item)\n            if os.path.isfile(file_path):\n                # Check file modification time\n                if os.path.getmtime(file_path) < cutoff_time:\n                    if self.delete_file(file_path):\n                        count += 1\n                        \n        return count",
  "D:\\AI\\IrintAI Assistant\\core\\memory_system.py": "\"\"\"\nMemory System - Vector embeddings and semantic search for context retrieval\n\"\"\"\nimport os\nimport json\nimport torch\nimport numpy as np\nfrom typing import List, Dict, Any, Optional, Callable, Union\nfrom sentence_transformers import SentenceTransformer, util\nimport time\n\nclass MemorySystem:\n    \"\"\"Manages vector embeddings and semantic search for context retrieval\"\"\"\n    \n    def __init__(self, \n                 model_name: str = \"all-MiniLM-L6-v2\", \n                 index_path: str = \"data/vector_store/vector_store.json\",\n                 logger: Optional[Callable] = None):\n        \"\"\"\n        Initialize the memory system\n        \n        Args:\n            model_name: Name of the sentence transformer model to use\n            index_path: Path to the vector store JSON file\n            logger: Optional logging function\n        \"\"\"\n        self.model_name = model_name\n        self.index_path = index_path\n        self.log = logger or print\n        \n        self.log(f\"[Memory] Initializing memory system with model: {model_name}\")\n        self.model = None\n        self.index = []\n        self.documents = []\n        \n        # Ensure the directory exists\n        os.makedirs(os.path.dirname(index_path), exist_ok=True)\n        \n        # Try to load the model\n        self.load_model()\n        \n        # Try to load the index\n        self.load_index()\n    \n    def load_model(self) -> bool:\n        \"\"\"\n        Load the embedding model\n        \n        Returns:\n            True if model loaded successfully, False otherwise\n        \"\"\"\n        try:\n            self.log(f\"[Memory] Loading embedding model: {self.model_name}\")\n            self.model = SentenceTransformer(self.model_name)\n            self.log(\"[Memory] Model loaded successfully\")\n            return True\n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to load model: {e}\")\n            return False\n    \n    def embed_texts(self, texts: List[str]) -> List[torch.Tensor]:\n        \"\"\"\n        Embed a list of texts\n        \n        Args:\n            texts: List of text strings to embed\n            \n        Returns:\n            List of tensor embeddings\n        \"\"\"\n        if not self.model:\n            if not self.load_model():\n                return []\n                \n        try:\n            embeddings = self.model.encode(texts, convert_to_tensor=True)\n            \n            # Handle different return types from different model implementations\n            if isinstance(embeddings, list):\n                return embeddings\n            elif isinstance(embeddings, torch.Tensor):\n                # If it's a single tensor with shape [batch_size, embedding_dim]\n                # Convert to list of tensors with shape [embedding_dim]\n                return [embeddings[i] for i in range(embeddings.shape[0])]\n            else:\n                self.log(f\"[Memory Warning] Unexpected embedding type: {type(embeddings)}\")\n                return []\n                \n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to embed texts: {e}\")\n            return []\n    \n    def add_to_index(self, docs: List[str], metadata: List[Dict[str, Any]]) -> bool:\n        \"\"\"\n        Add documents to the index\n        \n        Args:\n            docs: List of document text strings\n            metadata: List of metadata dictionaries\n            \n        Returns:\n            True if documents were added successfully, False otherwise\n        \"\"\"\n        if not docs or not metadata:\n            self.log(\"[Memory Warning] No documents to add\")\n            return False\n            \n        if len(docs) != len(metadata):\n            self.log(\"[Memory Error] Number of documents and metadata entries must match\")\n            return False\n            \n        try:\n            # Get embeddings\n            embeddings = self.embed_texts(docs)\n            \n            if len(embeddings) == 0:\n                return False\n                \n            # Add to index\n            for emb, meta in zip(embeddings, metadata):\n                if \"timestamp\" not in meta:\n                    meta[\"timestamp\"] = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n                self.index.append(emb)\n                self.documents.append(meta)\n            \n            self.log(f\"[Memory] Added {len(docs)} documents to index\")\n            \n            # Save updated index\n            return self.save_index()\n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to add documents to index: {e}\")\n            return False\n    \n    def search(self, query: str, top_k: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"\n        Search the index for documents similar to the query\n        \n        Args:\n            query: Search query string\n            top_k: Number of results to return\n            \n        Returns:\n            List of document metadata dictionaries\n        \"\"\"\n        if not self.index:\n            self.log(\"[Memory Warning] Index is empty\")\n            return []\n            \n        try:\n            # Get query embedding\n            query_vec = self.embed_texts([query])\n            \n            if not query_vec:\n                return []\n                \n            # Calculate similarity scores\n            scores = util.cos_sim(query_vec[0], torch.stack(self.index))[0]\n            \n            # Get top K results\n            top_scores, top_indices = torch.topk(scores, k=min(top_k, len(scores)))\n            \n            # Return metadata for top matches\n            results = []\n            for i, score in zip(top_indices, top_scores):\n                meta = self.documents[i]\n                meta[\"score\"] = float(score)  # Convert tensor to float for serialization\n                results.append(meta)\n                \n            self.log(f\"[Memory] Found {len(results)} matches for query: {query[:50]}...\")\n            return results\n        except Exception as e:\n            self.log(f\"[Memory Error] Search failed: {e}\")\n            return []\n    \n    def save_index(self) -> bool:\n        \"\"\"\n        Save the index to disk\n        \n        Returns:\n            True if index saved successfully, False otherwise\n        \"\"\"\n        if not self.index:\n            self.log(\"[Memory Warning] No index to save\")\n            return False\n            \n        try:\n            # Convert tensors to lists for JSON serialization\n            data = [\n                {\n                    \"embedding\": emb.cpu().tolist(), \n                    \"meta\": meta\n                } \n                for emb, meta in zip(self.index, self.documents)\n            ]\n            \n            # Create directory if it doesn't exist\n            os.makedirs(os.path.dirname(self.index_path), exist_ok=True)\n            \n            # Save to file\n            with open(self.index_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(data, f, indent=2)\n                \n            self.log(f\"[Memory] Index saved to {self.index_path}\")\n            return True\n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to save index: {e}\")\n            return False\n    \n    def load_index(self) -> bool:\n        \"\"\"\n        Load the index from disk\n        \n        Returns:\n            True if index loaded successfully, False otherwise\n        \"\"\"\n        if not os.path.exists(self.index_path):\n            self.log(f\"[Memory] No index file found at {self.index_path}\")\n            return False\n            \n        try:\n            # Use utf-8-sig to handle UTF-8 BOM (Byte Order Mark)\n            with open(self.index_path, \"r\", encoding=\"utf-8-sig\") as f:\n                data = json.load(f)\n                \n            # Clear current index\n            self.index = []\n            self.documents = []\n            \n            # Check if data is a list or dict\n            if isinstance(data, list):\n                # Load index (list format)\n                for item in data:\n                    if not isinstance(item, dict):\n                        self.log(f\"[Memory Warning] Invalid item format in index: {type(item)}\")\n                        continue\n                    if \"embedding\" in item and \"meta\" in item:\n                        self.index.append(torch.tensor(item[\"embedding\"]))\n                        self.documents.append(item[\"meta\"])\n                    else:\n                        self.log(f\"[Memory Warning] Missing embedding or meta in item\")\n            elif isinstance(data, dict):\n                # Alternative format (dict with embeddings and documents)\n                if \"embeddings\" in data and \"documents\" in data:\n                    embeddings = data[\"embeddings\"]\n                    documents = data[\"documents\"]\n                    if len(embeddings) == len(documents):\n                        for emb, doc in zip(embeddings, documents):\n                            self.index.append(torch.tensor(emb))\n                            self.documents.append(doc)\n                    else:\n                        self.log(\"[Memory Error] Mismatched lengths of embeddings and documents\")\n                        return False\n                else:\n                    self.log(\"[Memory Error] Invalid index format: missing embeddings or documents\")\n                    return False\n            else:\n                self.log(f\"[Memory Error] Invalid index data type: {type(data)}\")\n                return False\n                \n            self.log(f\"[Memory] Loaded {len(self.index)} items from index\")\n            return True\n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to load index: {e}\")\n            return False\n    \n    def clear_index(self) -> bool:\n        \"\"\"\n        Clear the index\n        \n        Returns:\n            True if index cleared successfully, False otherwise\n        \"\"\"\n        try:\n            self.index = []\n            self.documents = []\n            \n            # Remove the index file if it exists\n            if os.path.exists(self.index_path):\n                os.remove(self.index_path)\n                \n            self.log(\"[Memory] Index cleared\")\n            return True\n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to clear index: {e}\")\n            return False\n            \n    def add_file_to_index(self, file_path: str, \n                          content: Optional[str] = None, \n                          chunk_size: int = 1000, \n                          chunk_overlap: int = 200) -> bool:\n        \"\"\"\n        Add a file to the index, optionally with chunking\n        \n        Args:\n            file_path: Path to the file\n            content: Optional file content if already read\n            chunk_size: Size of chunks to split content into\n            chunk_overlap: Overlap between chunks\n            \n        Returns:\n            True if file added successfully, False otherwise\n        \"\"\"\n        try:\n            # Get file content if not provided\n            if content is None:\n                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:\n                    content = f.read()\n                    \n            # Check if we should chunk based on content length\n            if len(content) > chunk_size:\n                self.log(f\"[Memory] Chunking file {os.path.basename(file_path)} into smaller sections\")\n                return self._add_chunked_file(file_path, content, chunk_size, chunk_overlap)\n            else:\n                # Add as a single document\n                meta = {\n                    \"source\": os.path.basename(file_path),\n                    \"path\": file_path,\n                    \"text\": content,\n                    \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\")\n                }\n                \n                return self.add_to_index([content], [meta])\n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to add file {file_path}: {e}\")\n            return False\n            \n    def _add_chunked_file(self, file_path: str, content: str, \n                          chunk_size: int, chunk_overlap: int) -> bool:\n        \"\"\"\n        Add a file to the index in chunks using sentence-aware chunking\n        \n        Args:\n            file_path: Path to the file\n            content: File content\n            chunk_size: Size of chunks to split content into\n            chunk_overlap: Overlap between chunks\n            \n        Returns:\n            True if file added successfully, False otherwise\n        \"\"\"\n        try:\n            # Get the file name for metadata\n            file_name = os.path.basename(file_path)\n            \n            # Use the sentence-aware chunking method\n            chunks = self._chunk_text(content, max_chunk_size=chunk_size, overlap=chunk_overlap)\n            \n            self.log(f\"[Memory] Split file '{file_name}' into {len(chunks)} chunks\")\n            \n            # Create metadata for each chunk\n            metadata = []\n            for i, chunk in enumerate(chunks):\n                meta = {\n                    \"source\": file_name,\n                    \"path\": file_path,\n                    \"text\": chunk,\n                    \"chunk\": i + 1,\n                    \"total_chunks\": len(chunks),\n                    \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    # Add file extension as a hint about content type\n                    \"file_type\": os.path.splitext(file_path)[1].lower(),\n                }\n                metadata.append(meta)\n                \n            # Add chunks to index\n            return self.add_to_index(chunks, metadata)\n            \n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to chunk file {file_path}: {e}\")\n            return False\n            \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get statistics about the memory system\n        \n        Returns:\n            Dictionary of statistics\n        \"\"\"\n        stats = {\n            \"model\": self.model_name,\n            \"index_path\": self.index_path,\n            \"documents_count\": len(self.documents),\n            \"sources\": {},\n            \"last_updated\": None\n        }\n        \n        # Get unique sources and count\n        for doc in self.documents:\n            source = doc.get(\"source\", \"Unknown\")\n            if source in stats[\"sources\"]:\n                stats[\"sources\"][source] += 1\n            else:\n                stats[\"sources\"][source] = 1\n                \n        # Get last updated timestamp\n        if self.documents:\n            timestamps = [doc.get(\"timestamp\") for doc in self.documents if \"timestamp\" in doc]\n            if timestamps:\n                stats[\"last_updated\"] = max(timestamps)\n                \n        return stats\n    \n    def _chunk_text(self, text: str, max_chunk_size: int = 1000, overlap: int = 100) -> List[str]:\n        \"\"\"Split text into overlapping chunks of maximum size\"\"\"\n        chunks = []\n        \n        # If text is shorter than max chunk size, return as is\n        if len(text) <= max_chunk_size:\n            return [text]\n        \n        # Split into sentences to avoid breaking sentences\n        import re\n        sentences = re.split(r'(?<=[.!?])\\s+', text)\n        \n        current_chunk = \"\"\n        \n        for sentence in sentences:\n            # If adding this sentence would exceed max_chunk_size\n            if len(current_chunk) + len(sentence) > max_chunk_size and current_chunk:\n                # Add current chunk to chunks list\n                chunks.append(current_chunk)\n                \n                # Start new chunk with overlap\n                words = current_chunk.split()\n                overlap_words = min(len(words), int(overlap / 4))  # Approx 4 chars per word\n                overlap_text = \" \".join(words[-overlap_words:]) if overlap_words > 0 else \"\"\n                current_chunk = overlap_text + \" \" + sentence\n            else:\n                # Add sentence to current chunk\n                if current_chunk:\n                    current_chunk += \" \" + sentence\n                else:\n                    current_chunk = sentence\n        \n        # Add the last chunk if it's not empty\n        if current_chunk:\n            chunks.append(current_chunk)\n        \n        return chunks\n    \n    def add_reflection(self, category: str, content: str, importance: float = 0.5) -> Optional[str]:\n        \"\"\"\n        Add a reflection or insight to the memory system\n        \n        Args:\n            category: Category of reflection (e.g., 'conversation', 'learning', 'user_preference')\n            content: Text content of the reflection\n            importance: Importance score (0.0-1.0) to prioritize in retrieval\n            \n        Returns:\n            ID of the added reflection or None if failed\n        \"\"\"\n        if not self.model:\n            self.log(\"[Memory Warning] Cannot add reflection: model not loaded\")\n            return None\n            \n        try:\n            # Generate a unique ID\n            reflection_id = f\"refl_{int(time.time())}_{category}\"\n            \n            # Create metadata\n            metadata = {\n                \"id\": reflection_id,\n                \"source\": \"reflection\",\n                \"category\": category,\n                \"importance\": importance,\n                \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"text\": content\n            }\n            \n            # Add to index\n            success = self.add_to_index([content], [metadata])\n            \n            if success:\n                self.log(f\"[Memory] Added {category} reflection to memory: {content[:50]}...\")\n                return reflection_id\n            else:\n                return None\n                \n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to add reflection: {e}\")\n            return None\n        \n    def get_context_for_query(self, query: str, max_tokens: int = 1500, \n                             top_k: int = 5, min_score: float = 0.3) -> str:\n        \"\"\"\n        Get a formatted context string for a query from memory\n        \n        Args:\n            query: Query to find context for\n            max_tokens: Maximum approximate tokens to include in context\n            top_k: Maximum number of results to include\n            min_score: Minimum similarity score to include\n        \n        Returns:\n            Formatted context string\n        \"\"\"\n        # Search for relevant items\n        results = self.search(query, top_k=top_k)\n        \n        if not results:\n            return \"\"\n            \n        # Filter by minimum score\n        results = [r for r in results if r.get(\"score\", 0) >= min_score]\n        \n        if not results:\n            return \"\"\n            \n        # Format the context\n        context_parts = []\n        total_length = 0\n        char_per_token = 4  # Rough approximation\n        max_chars = max_tokens * char_per_token\n        \n        for item in results:\n            # Get text from the item\n            text = item.get(\"text\", \"\")\n            if not text:\n                continue\n                \n            # Extract metadata for context\n            source = item.get(\"source\", \"Unknown\")\n            score = item.get(\"score\", 0)\n            \n            # Format this item\n            item_text = f\"[Source: {source} (relevance: {score:.2f})]\\n{text}\\n\"\n            \n            # Check if we've reached the max length\n            if total_length + len(item_text) > max_chars:\n                # Truncate if needed\n                available_chars = max_chars - total_length\n                if available_chars > 100:  # Only add if we can include meaningful content\n                    item_text = item_text[:available_chars] + \"...\"\n                    context_parts.append(item_text)\n                break\n                \n            context_parts.append(item_text)\n            total_length += len(item_text)\n        \n        return \"\\n\".join(context_parts)\n\n    def search_by_category(self, category: str, top_k: int = 10) -> List[Dict[str, Any]]:\n        \"\"\"\n        Retrieve items from memory by category\n        \n        Args:\n            category: Category to search for\n            top_k: Maximum number of results to return\n            \n        Returns:\n            List of items matching the category\n        \"\"\"\n        if not self.documents:\n            return []\n            \n        try:\n            # Find all documents with matching category\n            matches = [doc for doc in self.documents if doc.get(\"category\") == category]\n            \n            # Sort by timestamp (newest first)\n            matches.sort(key=lambda x: x.get(\"timestamp\", \"\"), reverse=True)\n            \n            # Limit to top_k\n            return matches[:top_k]\n                \n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to search by category: {e}\")\n            return []\n    \n    def export_memory(self, export_path: str) -> bool:\n        \"\"\"\n        Export the memory system to a file\n        \n        Args:\n            export_path: Path to export to\n            \n        Returns:\n            True if export successful, False otherwise\n        \"\"\"\n        try:\n            # Create data to export\n            export_data = {\n                \"model_name\": self.model_name,\n                \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"documents\": self.documents,\n                \"embeddings\": [emb.cpu().tolist() for emb in self.index]\n            }\n            \n            # Create directory if it doesn't exist\n            os.makedirs(os.path.dirname(export_path), exist_ok=True)\n            \n            # Save to file\n            with open(export_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(export_data, f, indent=2)\n                \n            self.log(f\"[Memory] Exported memory to {export_path}\")\n            return True\n            \n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to export memory: {e}\")\n            return False\n            \n    def import_memory(self, import_path: str, merge: bool = False) -> bool:\n        \"\"\"\n        Import memory from a file\n        \n        Args:\n            import_path: Path to import from\n            merge: Whether to merge with existing memory or replace\n            \n        Returns:\n            True if import successful, False otherwise\n        \"\"\"\n        if not os.path.exists(import_path):\n            self.log(f\"[Memory Error] Import file not found: {import_path}\")\n            return False\n            \n        try:\n            # Load from file\n            with open(import_path, \"r\", encoding=\"utf-8\") as f:\n                import_data = json.load(f)\n                \n            # Validate data\n            if \"documents\" not in import_data or \"embeddings\" not in import_data:\n                self.log(f\"[Memory Error] Invalid memory export file: {import_path}\")\n                return False\n                \n            # Clear existing memory if not merging\n            if not merge:\n                self.index = []\n                self.documents = []\n                \n            # Import data\n            for emb_data, doc in zip(import_data[\"embeddings\"], import_data[\"documents\"]):\n                emb = torch.tensor(emb_data)\n                self.index.append(emb)\n                self.documents.append(doc)\n                \n            self.log(f\"[Memory] Imported {len(import_data['documents'])} items from {import_path}\")\n            \n            # Save to index\n            self.save_index()\n            return True\n            \n        except Exception as e:\n            self.log(f\"[Memory Error] Failed to import memory: {e}\")\n            return False",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\ollama_panel_diagnostic.py": "# filepath: d:\\AI\\IrintAI Assistant\\diagnostics\\ollama_panel_diagnostic.py\nimport requests\nimport json\nimport tkinter as tk\nfrom tkinter import ttk\nimport sys\nimport os\nfrom urllib.parse import urlparse\n\n# Add project root to sys.path to allow importing core modules\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nif project_root not in sys.path:\n    sys.path.insert(0, project_root)\n\ntry:\n    from plugins.ollama_hub.core.ollama_client import OllamaClient\n    from core.config_manager import ConfigManager\n    from utils.logger import IrintaiLogger # Assuming logger setup utility\nexcept ImportError as e:\n    print(f\"Error importing core modules: {e}\")\n    print(\"Please ensure the script is run from the project root or the PYTHONPATH is set correctly.\")\n    sys.exit(1)\n\n# Setup a dummy logger for the client if needed\ndiagnostic_logger = IrintaiLogger('ollama_diagnostic', 'ollama_diagnostic.log')\n\nclass OllamaPanelDiagnostic:    \n    def __init__(self, config_path='data/config.json'):\n        self.config_manager = ConfigManager(config_path)\n        self.ollama_url = self.config_manager.get(\"ollama_url\", \"http://localhost:11434\")\n        self.results = {}\n        # Pass a proper logging function - using the print method from this class\n        # since OllamaClient expects a callable function, not a logger object\n        self.ollama_client = OllamaClient(logger=self.log) # Only pass logger since OllamaClient doesn't accept base_url\n\n    def log(self, message):\n        \"\"\"Simple print-based logging for diagnostics.\"\"\"\n        print(f\"[DIAGNOSTIC] {message}\")\n\n    def check_ollama_server_connection(self):\n        \"\"\"Checks if the Ollama server is reachable.\"\"\"\n        self.log(f\"Attempting to connect to Ollama server at: {self.ollama_url}\")\n        try:\n            response = requests.get(f\"{self.ollama_url}/\", timeout=5)\n            if response.status_code == 200 and \"Ollama is running\" in response.text:\n                self.results['server_connection'] = {'status': 'Success', 'message': f\"Successfully connected to {self.ollama_url}.\"}\n                self.log(\"Server connection successful.\")\n                return True\n            else:\n                self.results['server_connection'] = {'status': 'Failure', 'message': f\"Connected, but unexpected response (Status: {response.status_code}). Is it an Ollama server?\"}\n                self.log(f\"Server connection failed: Unexpected response {response.status_code}\")\n                return False\n        except requests.exceptions.ConnectionError as e:\n            self.results['server_connection'] = {'status': 'Failure', 'message': f\"Connection Error: Could not connect to {self.ollama_url}. Is Ollama running? Details: {e}\"}\n            self.log(f\"Server connection failed: Connection Error - {e}\")\n            return False\n        except requests.exceptions.Timeout:\n            self.results['server_connection'] = {'status': 'Failure', 'message': f\"Connection Timeout: Timed out connecting to {self.ollama_url}.\"}\n            self.log(\"Server connection failed: Timeout\")\n            return False\n        except Exception as e:\n            self.results['server_connection'] = {'status': 'Failure', 'message': f\"An unexpected error occurred during connection: {e}\"}\n            self.log(f\"Server connection failed: Unexpected error - {e}\")\n            return False\n\n    def check_list_local_models(self):\n        \"\"\"Checks if local models can be listed via the API.\"\"\"\n        if not self.results.get('server_connection', {}).get('status') == 'Success':\n            self.results['list_local_models'] = {'status': 'Skipped', 'message': 'Server connection failed.'}\n            self.log(\"Skipping local model list check - server connection failed.\")\n            return False\n\n        self.log(\"Attempting to list local models...\")\n        try:\n            # Use the OllamaClient method\n            success, data = self.ollama_client.list_models(remote=False)\n\n            if success and isinstance(data.get('models'), list):\n                count = len(data['models'])\n                self.results['list_local_models'] = {'status': 'Success', 'message': f\"Successfully listed {count} local models.\"}\n                self.log(f\"Local model list successful ({count} models found).\")\n                return True\n            else:\n                error_msg = data.get('error', 'Unknown error format')\n                self.results['list_local_models'] = {'status': 'Failure', 'message': f\"Failed to list local models. API Error: {error_msg}\"}\n                self.log(f\"Local model list failed: {error_msg}\")\n                return False\n        except Exception as e:\n            self.results['list_local_models'] = {'status': 'Failure', 'message': f\"An unexpected error occurred listing local models: {e}\"}\n            self.log(f\"Local model list failed: Unexpected error - {e}\")\n            return False\n\n    def check_list_remote_models(self):\n        \"\"\"Checks if remote models can be listed (simulated or via client).\"\"\"\n        if not self.results.get('server_connection', {}).get('status') == 'Success':\n            self.results['list_remote_models'] = {'status': 'Skipped', 'message': 'Server connection failed.'}\n            self.log(\"Skipping remote model list check - server connection failed.\")\n            return False\n\n        self.log(\"Attempting to list remote models...\")\n        try:\n            # Use the OllamaClient method if it supports remote listing reliably\n            success, data = self.ollama_client.list_models(remote=True)\n\n            if success and isinstance(data.get('models'), list):\n                count = len(data['models'])\n                self.results['list_remote_models'] = {'status': 'Success', 'message': f\"Successfully listed {count} remote models from Ollama Hub.\"}\n                self.log(f\"Remote model list successful ({count} models found).\")\n                return True\n            elif not success and \"failed to get location\" in data.get('error', '').lower():\n                 self.results['list_remote_models'] = {'status': 'Warning', 'message': f\"Could not fetch remote models (API Error: {data.get('error', '')}). This might be a temporary Ollama Hub issue or network problem.\"}\n                 self.log(f\"Remote model list warning: {data.get('error', '')}\")\n                 return False # Treat as warning, not outright failure for diagnostics\n            else:\n                error_msg = data.get('error', 'Unknown error format')\n                self.results['list_remote_models'] = {'status': 'Failure', 'message': f\"Failed to list remote models. API Error: {error_msg}\"}\n                self.log(f\"Remote model list failed: {error_msg}\")\n                return False        \n        except Exception as e:\n        # Handle connection issues with Ollama hub\n        # Since OllamaClient doesn't have remote_registry_url attribute, use a default\n            default_registry = \"ollama.ai\"\n            if isinstance(e, requests.exceptions.ConnectionError) and default_registry in str(e):\n                self.results['list_remote_models'] = {'status': 'Warning', 'message': f\"Could not connect to Ollama Hub ({default_registry}): {e}. Check network/DNS.\"}\n                self.log(f\"Remote model list warning: Connection error to {default_registry} - {e}\")\n                return False\n            else:\n                self.results['list_remote_models'] = {'status': 'Failure', 'message': f\"An unexpected error occurred listing remote models: {e}\"}\n                self.log(f\"Remote model list failed: Unexpected error - {e}\")\n                return False\n\n    def check_pull_model(self, model_name=\"phi3:mini\"):\n        \"\"\"Attempts to pull a small model to test download functionality.\"\"\"\n        if not self.results.get('server_connection', {}).get('status') == 'Success':\n            self.results['pull_model'] = {'status': 'Skipped', 'message': 'Server connection failed.'}\n            self.log(f\"Skipping pull model check ({model_name}) - server connection failed.\")\n            return False\n\n        self.log(f\"Attempting to pull model: {model_name} (this may take a moment)...\")\n        try:\n            # Use the OllamaClient method\n            success, message = self.ollama_client.pull_model(model_name, progress_callback=lambda p: None) # No progress needed for diagnostic\n\n            if success:\n                self.results['pull_model'] = {'status': 'Success', 'message': f\"Successfully pulled model '{model_name}'.\"}\n                self.log(f\"Pull model successful: {model_name}\")\n                # Attempt to clean up the downloaded model\n                self.check_delete_model(model_name, is_cleanup=True)\n                return True\n            else:\n                self.results['pull_model'] = {'status': 'Failure', 'message': f\"Failed to pull model '{model_name}'. API Error: {message}\"}\n                self.log(f\"Pull model failed ({model_name}): {message}\")\n                return False\n        except Exception as e:\n            self.results['pull_model'] = {'status': 'Failure', 'message': f\"An unexpected error occurred pulling model '{model_name}': {e}\"}\n            self.log(f\"Pull model failed ({model_name}): Unexpected error - {e}\")\n            return False\n\n    def check_delete_model(self, model_name=\"phi3:mini\", is_cleanup=False):\n        \"\"\"Attempts to delete a model (used for cleanup after pull test).\"\"\"\n        if not self.results.get('server_connection', {}).get('status') == 'Success':\n            if not is_cleanup:\n                self.results['delete_model'] = {'status': 'Skipped', 'message': 'Server connection failed.'}\n            self.log(f\"Skipping delete model check ({model_name}) - server connection failed.\")\n            return False\n\n        self.log(f\"Attempting to delete model: {model_name}...\")\n        try:\n            # Use the OllamaClient method\n            success, message = self.ollama_client.delete_model(model_name)\n\n            result_key = 'delete_model_cleanup' if is_cleanup else 'delete_model'\n\n            if success:\n                self.results[result_key] = {'status': 'Success', 'message': f\"Successfully deleted model '{model_name}'.\"}\n                self.log(f\"Delete model successful: {model_name}\")\n                return True\n            else:\n                # It's possible the model wasn't there to begin with (e.g., pull failed)\n                if \"model 'phi3:mini' not found\" in message:\n                     self.results[result_key] = {'status': 'Info', 'message': f\"Model '{model_name}' not found for deletion (might be expected if pull failed).\"}\n                     self.log(f\"Delete model info ({model_name}): Model not found.\")\n                     return True # Not a failure in this context\n                else:\n                    self.results[result_key] = {'status': 'Failure', 'message': f\"Failed to delete model '{model_name}'. API Error: {message}\"}\n                    self.log(f\"Delete model failed ({model_name}): {message}\")\n                    return False\n        except Exception as e:\n            result_key = 'delete_model_cleanup' if is_cleanup else 'delete_model'\n            self.results[result_key] = {'status': 'Failure', 'message': f\"An unexpected error occurred deleting model '{model_name}': {e}\"}\n            self.log(f\"Delete model failed ({model_name}): Unexpected error - {e}\")\n            return False\n\n    def run_all_checks(self):\n        \"\"\"Runs all diagnostic checks.\"\"\"\n        self.log(\"Starting Ollama Panel Diagnostics...\")\n        self.check_ollama_server_connection()\n        self.check_list_local_models()\n        self.check_list_remote_models()\n        self.check_pull_model() # This implicitly tests delete on success\n        self.log(\"Diagnostics complete.\")\n\n    def print_results(self):\n        \"\"\"Prints the results of the diagnostic checks.\"\"\"\n        print(\"\\n--- Ollama Panel Diagnostic Results ---\")\n        print(f\"Ollama URL Tested: {self.ollama_url}\")\n        print(\"-\" * 35)\n        for check, result in self.results.items():\n            status = result.get('status', 'Unknown')\n            message = result.get('message', 'No details.')\n            print(f\"[{status.upper()}] Check: {check.replace('_', ' ').title()}\")\n            print(f\"  Message: {message}\")\n            print(\"-\" * 35)\n        print(\"--- End of Report ---\")\n\nif __name__ == \"__main__\":\n    # Example usage: Run from the command line\n    config_file = os.path.join(project_root, 'data', 'config.json')\n    diagnostic = OllamaPanelDiagnostic(config_path=config_file)\n    diagnostic.run_all_checks()\n    diagnostic.print_results()\n\n    # Optional: Keep window open if run directly without console\n    input(\"Press Enter to exit...\")\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\personality_plugin\\ui\\__init__.py": "\"\"\"\nUI Components for the Personality Plugin\n\"\"\"\n\nfrom plugins.personality_plugin.ui.panel import Panel\n\n# Export the class at the package level\n__all__ = ['Panel']\n\n# Module level activation function for plugin manager\ndef activate_ui(container):\n    \"\"\"\n    Create and return a panel for the plugin\n    \n    Args:\n        container: UI container to place panel in\n        \n    Returns:\n        The created panel\n    \"\"\"\n    from plugins.personality_plugin.core import PersonalityPlugin\n    from plugins.personality_plugin.ui.panel import Panel\n    \n    # Get plugin instance from plugin manager\n    plugin_manager = container.master.plugin_manager\n    plugin_instance = plugin_manager.get_plugin_instance(\"personality_plugin\")\n    \n    if plugin_instance and isinstance(plugin_instance, PersonalityPlugin):\n        # Create panel with plugin instance\n        panel = Panel(container, plugin_instance)\n        return panel\n    else:\n        import tkinter as tk\n        # Show error if plugin is not available\n        frame = tk.Frame(container)\n        tk.Label(\n            frame,\n            text=\"Error: Personality plugin not loaded or active\",\n            foreground=\"red\"\n        ).pack(padx=10, pady=10)\n        return frame",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\diagnostic_fixer.py": "\"\"\"\nIrintAI Assistant Diagnostic Fixer\n\nThis module provides automated fixes for issues identified by the diagnostic suite.\n\"\"\"\nimport os\nimport sys\nimport json\nimport logging\nfrom pathlib import Path\nimport importlib\nfrom datetime import datetime\nimport requests\n\n# Add project root to sys.path\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nif project_root not in sys.path:\n    sys.path.insert(0, project_root)\n\nfrom diagnostics.diagnostic_suite import DiagnosticSuite\nfrom core.config_manager import ConfigManager\nfrom utils.logger import IrintaiLogger\n\n# Setup logger for diagnostic fixer\nlogger = IrintaiLogger('diagnostic_fixer', 'diagnostic_fixer.log')\n\nclass DiagnosticFixer:\n    \"\"\"Provides automated fixes for issues found by the diagnostic suite\"\"\"\n    \n    def __init__(self, config_path='data/config.json'):\n        \"\"\"Initialize the diagnostic fixer with configuration\"\"\"\n        self.config_path = config_path\n        self.config_manager = ConfigManager(config_path)\n        self.diagnostic_suite = DiagnosticSuite(config_path=config_path)\n        self.fix_functions = {\n            'system': self._fix_system_issues,\n            'config': self._fix_config_issues,\n            'ollama': self._fix_ollama_issues,\n            'plugin': self._fix_plugin_issues,\n            'memory': self._fix_memory_issues,\n            'network': self._fix_network_issues\n        }\n        self.fixed_issues = {\n            'system': [],\n            'config': [],\n            'ollama': [],\n            'plugin': [],\n            'memory': [],\n            'network': []\n        }\n        self.unfixable_issues = {\n            'system': [],\n            'config': [],\n            'ollama': [],\n            'plugin': [],\n            'memory': [],\n            'network': []\n        }\n    \n    def run_diagnostics(self):\n        \"\"\"Run diagnostics to identify issues\"\"\"\n        logger.info(\"Running diagnostics to identify issues...\")\n        self.diagnostic_suite.run_all_diagnostics()\n        return self.diagnostic_suite.results\n    \n    def fix_all_issues(self):\n        \"\"\"Run diagnostics and fix all identified issues\"\"\"\n        # First run diagnostics to identify issues\n        results = self.run_diagnostics()\n        \n        # Get summary to check if there are issues\n        summary = self.diagnostic_suite.get_summary()\n        if isinstance(summary, str) or summary['overall_status'] == 'Success':\n            logger.info(\"No issues found that need fixing\")\n            return {'fixed': 0, 'unfixable': 0}\n        \n        # Fix issues in each module\n        fixed_count = 0\n        unfixable_count = 0\n        \n        for module_name, module_results in results.items():\n            if module_name in self.fix_functions:\n                module_fixed, module_unfixable = self.fix_functions[module_name](module_results)\n                fixed_count += module_fixed\n                unfixable_count += module_unfixable\n        \n        # Run diagnostics again to verify fixes\n        verification_results = self.run_diagnostics()\n        verification_summary = self.diagnostic_suite.get_summary()\n        \n        return {\n            'fixed': fixed_count,\n            'unfixable': unfixable_count,\n            'fixed_issues': self.fixed_issues,\n            'unfixable_issues': self.unfixable_issues,\n            'verification': verification_summary\n        }\n    \n    def fix_module_issues(self, module_name):\n        \"\"\"Fix issues for a specific module\"\"\"\n        if module_name not in self.fix_functions:\n            logger.error(f\"Unknown module: {module_name}\")\n            return {'error': f\"Unknown module: {module_name}\"}\n        \n        # Run specific diagnostic\n        results = self.diagnostic_suite.run_specific_diagnostic(module_name)\n        \n        # Fix issues\n        fixed_count, unfixable_count = self.fix_functions[module_name](results)\n        \n        # Verify fixes\n        verification_results = self.diagnostic_suite.run_specific_diagnostic(module_name)\n        \n        return {\n            'fixed': fixed_count,\n            'unfixable': unfixable_count,\n            'fixed_issues': self.fixed_issues[module_name],\n            'unfixable_issues': self.unfixable_issues[module_name],\n            'verification': verification_results\n        }\n    def _fix_system_issues(self, results):\n        \"\"\"Fix system-related issues\"\"\"\n        fixed_count = 0\n        unfixable_count = 0\n        \n        for check, result in results.items():\n            if isinstance(result, dict) and result.get('status', '').lower() in ['failure', 'warning']:\n                issue_description = f\"{check}: {result.get('message', 'No details')}\"\n                \n                if check == 'system_resources':\n                    # Try to address high CPU/memory usage\n                    try:\n                        # Create a resource optimization script\n                        resource_script = os.path.join(project_root, \"optimize_resources.bat\")\n                        with open(resource_script, 'w') as f:\n                            f.write('@echo off\\n')\n                            f.write('echo IrintAI Assistant Resource Optimizer\\n')\n                            f.write('echo ===============================\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Checking for resource-intensive processes...\\n')\n                            f.write('echo.\\n')\n                            f.write('powershell -command \"Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 10 | Format-Table -AutoSize Id, ProcessName, CPU, WorkingSet\"\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Cleaning up temporary files...\\n')\n                            f.write('powershell -command \"Remove-Item -Path $env:TEMP\\\\* -Recurse -Force -ErrorAction SilentlyContinue\"\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Checking for large log files in IrintAI Assistant...\\n')\n                            f.write('dir /s /b \"%~dp0..\\\\data\\\\logs\\\\*.log\" | findstr /v \"\"\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Would you like to clean up old log files? (Y/N)\\n')\n                            f.write('set /p clean=\"Enter your choice: \"\\n')\n                            f.write('if /i \"%clean%\" == \"Y\" (\\n')\n                            f.write('    echo Cleaning up logs older than 7 days...\\n')\n                            f.write('    forfiles /p \"%~dp0..\\\\data\\\\logs\" /s /m *.log /d -7 /c \"cmd /c del @path\" 2>nul\\n')\n                            f.write('    echo Done cleaning logs.\\n')\n                            f.write(')\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Recommendations to improve system resources:\\n')\n                            f.write('echo 1. Close unnecessary applications\\n')\n                            f.write('echo 2. Restart the computer if it has been running for a long time\\n')\n                            f.write('echo 3. Consider upgrading memory if consistently at high usage\\n')\n                            f.write('echo 4. Check for malware that might be consuming resources\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Press any key to exit...\\n')\n                            f.write('pause > nul\\n')\n                        \n                        self.fixed_issues['system'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': \"Created optimize_resources.bat script to help identify and reduce resource usage. Run this script to view top resource-intensive processes and clean temporary files.\"\n                        })\n                        fixed_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to create resource optimization script: {e}\")\n                        self.unfixable_issues['system'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to create resource optimization script: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                elif check == 'network_connectivity':\n                    # Try to fix network connectivity issues\n                    try:\n                        # Create a network diagnostic script\n                        network_script = os.path.join(project_root, \"diagnose_network.bat\")\n                        with open(network_script, 'w') as f:\n                            f.write('@echo off\\n')\n                            f.write('echo IrintAI Assistant Network Diagnostics\\n')\n                            f.write('echo =============================\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Checking internet connectivity...\\n')\n                            f.write('ping -n 4 8.8.8.8\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Checking DNS resolution...\\n')\n                            f.write('nslookup google.com\\n')\n                            f.write('nslookup ollama.ai\\n')\n                            f.write('nslookup api.github.com\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Checking proxy settings...\\n')\n                            f.write('netsh winhttp show proxy\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Checking firewall status...\\n')\n                            f.write('netsh advfirewall show allprofiles state\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Attempting to access Ollama API...\\n')\n                            f.write('powershell -command \"try { $response = Invoke-WebRequest -Uri http://localhost:11434/api/version -UseBasicParsing -TimeoutSec 5; Write-Host \\\"Response: $($response.StatusCode) $($response.StatusDescription)\\\"; Write-Host $response.Content } catch { Write-Host \\\"Error: $_\\\" }\"\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Would you like to reset network settings? (Y/N)\\n')\n                            f.write('set /p reset=\"Enter your choice: \"\\n')\n                            f.write('if /i \"%reset%\" == \"Y\" (\\n')\n                            f.write('    echo Resetting network settings...\\n')\n                            f.write('    ipconfig /flushdns\\n')\n                            f.write('    netsh winsock reset\\n')\n                            f.write('    echo Network settings reset. A system restart is recommended.\\n')\n                            f.write(')\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Press any key to exit...\\n')\n                            f.write('pause > nul\\n')\n                        \n                        self.fixed_issues['system'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': \"Created diagnose_network.bat script to help diagnose and fix network connectivity issues.\"\n                        })\n                        fixed_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to create network diagnostic script: {e}\")\n                        self.unfixable_issues['system'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to create network diagnostic script: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                elif check == 'python_version':\n                    # Can't fix Python version automatically\n                    self.unfixable_issues['system'].append({\n                        'check': check,\n                        'message': result.get('message', ''),\n                        'reason': \"Python version can't be changed automatically\"\n                    })\n                    unfixable_count += 1\n                \n                elif check == 'memory_available':\n                    # Can't fix memory issues automatically\n                    self.unfixable_issues['system'].append({\n                        'check': check,\n                        'message': result.get('message', ''),\n                        'reason': \"Memory issues require hardware changes or closing other applications\"\n                    })\n                    unfixable_count += 1\n                \n                elif check == 'disk_space':\n                    # Attempt to clean temp files to free up space\n                    try:\n                        # Try to clean up logs older than 7 days\n                        import shutil\n                        from datetime import datetime, timedelta\n                        \n                        logs_dir = os.path.join(project_root, 'data', 'logs')\n                        if os.path.exists(logs_dir):\n                            cutoff_date = datetime.now() - timedelta(days=7)\n                            cleaned_files = 0\n                            bytes_freed = 0\n                            \n                            for log_file in os.listdir(logs_dir):\n                                log_path = os.path.join(logs_dir, log_file)\n                                if os.path.isfile(log_path):\n                                    file_time = datetime.fromtimestamp(os.path.getmtime(log_path))\n                                    if file_time < cutoff_date:\n                                        file_size = os.path.getsize(log_path)\n                                        os.remove(log_path)\n                                        cleaned_files += 1\n                                        bytes_freed += file_size\n                            \n                            if cleaned_files > 0:\n                                self.fixed_issues['system'].append({\n                                    'check': check,\n                                    'message': result.get('message', ''),\n                                    'fix': f\"Removed {cleaned_files} old log files, freeing {bytes_freed / (1024*1024):.2f} MB\"\n                                })\n                                fixed_count += 1\n                            else:\n                                self.unfixable_issues['system'].append({\n                                    'check': check,\n                                    'message': result.get('message', ''),\n                                    'reason': \"No old log files to clean up. Manual cleanup needed.\"\n                                })\n                                unfixable_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to fix disk space issue: {e}\")\n                        self.unfixable_issues['system'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Auto-cleanup failed: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                elif check == 'required_packages':\n                    # Try to install missing packages\n                    try:\n                        message = result.get('message', '')\n                        import re\n                        missing_packages = re.findall(r\"missing: ([a-zA-Z0-9_\\-]+)\", message)\n                        \n                        if missing_packages:\n                            import subprocess\n                            for package in missing_packages:\n                                subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n                            \n                            self.fixed_issues['system'].append({\n                                'check': check,\n                                'message': message,\n                                'fix': f\"Installed missing packages: {', '.join(missing_packages)}\"\n                            })\n                            fixed_count += 1\n                        else:\n                            self.unfixable_issues['system'].append({\n                                'check': check,\n                                'message': message,\n                                'reason': \"Couldn't identify specific missing packages\"\n                            })\n                            unfixable_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to fix package issue: {e}\")\n                        self.unfixable_issues['system'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Package installation failed: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                else:\n                    # Generic unfixable issue\n                    self.unfixable_issues['system'].append({\n                        'check': check,\n                        'message': result.get('message', ''),\n                        'reason': \"No automated fix available for this issue\"\n                    })\n                    unfixable_count += 1\n        \n        return fixed_count, unfixable_count    \n    \n    def _fix_config_issues(self, results):\n        \"\"\"Fix configuration-related issues\"\"\"\n        fixed_count = 0\n        unfixable_count = 0\n        \n        for check, result in results.items():\n            if isinstance(result, dict) and result.get('status', '').lower() in ['failure', 'warning']:\n                issue_description = f\"{check}: {result.get('message', 'No details')}\"\n                \n                if check == 'ollama_url':\n                    # Fix Ollama URL configuration\n                    try:\n                        config_path = os.path.join(project_root, self.config_path)\n                        if os.path.exists(config_path):\n                            with open(config_path, 'r') as f:\n                                config_data = json.load(f)\n                            \n                            # Add or update the Ollama URL configuration\n                            if 'ollama' not in config_data:\n                                config_data['ollama'] = {}\n                            \n                            config_data['ollama']['url'] = 'http://localhost:11434'\n                            \n                            # Also add a top-level ollama_url for backward compatibility\n                            config_data['ollama_url'] = 'http://localhost:11434'\n                            \n                            with open(config_path, 'w') as f:\n                                json.dump(config_data, f, indent=2)\n                            \n                            self.fixed_issues['config'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'fix': \"Set Ollama URL to http://localhost:11434 in configuration\"\n                            })\n                            fixed_count += 1\n                        else:\n                            self.unfixable_issues['config'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'reason': \"Config file doesn't exist. Fix 'config_file_exists' issue first.\"\n                            })\n                            unfixable_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to set Ollama URL: {e}\")\n                        self.unfixable_issues['config'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to set Ollama URL: {e}\"\n                        })\n                        unfixable_count += 1\n                        \n                elif check == 'config_file_exists':\n                    # Try to create default config file\n                    try:\n                        config_dir = os.path.dirname(os.path.join(project_root, self.config_path))\n                        os.makedirs(config_dir, exist_ok=True)\n                        \n                        default_config = {\n                            \"model\": {\n                                \"provider\": \"ollama\",\n                                \"name\": \"llama3:8b\",\n                                \"api_key\": \"\"\n                            },\n                            \"interface\": {\n                                \"theme\": \"light\",\n                                \"font_size\": 12\n                            },\n                            \"plugins\": {\n                                \"enabled\": [\"memory\", \"personality\"],\n                                \"settings\": {},\n                                \"plugin_directory\": \"plugins\"\n                            },\n                            \"memory\": {\n                                \"enabled\": True,\n                                \"storage_type\": \"vector\",\n                                \"max_history\": 100\n                            },\n                            \"ui\": {\n                                \"theme\": \"System\",\n                                \"font_size\": 12,\n                                \"window_size\": \"1024x768\"\n                            },\n                            \"logging\": {\n                                \"log_level\": \"INFO\",\n                                \"log_directory\": \"data/logs\"\n                            },\n                            \"ollama\": {\n                                \"url\": \"http://localhost:11434\"\n                            }\n                        }\n                        \n                        with open(os.path.join(project_root, self.config_path), 'w') as f:\n                            json.dump(default_config, f, indent=2)\n                        \n                        self.fixed_issues['config'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': \"Created default configuration file\"\n                        })\n                        fixed_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to create config file: {e}\")\n                        self.unfixable_issues['config'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to create config file: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                elif check == 'config_format':\n                    # Try to fix JSON format\n                    try:\n                        config_path = os.path.join(project_root, self.config_path)\n                        with open(config_path, 'r') as f:\n                            config_text = f.read()\n                        \n                        # Try to parse and reformat\n                        try:\n                            config_data = json.loads(config_text)\n                            with open(config_path, 'w') as f:\n                                json.dump(config_data, f, indent=2)\n                            \n                            self.fixed_issues['config'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'fix': \"Reformatted config JSON\"\n                            })\n                            fixed_count += 1\n                        except json.JSONDecodeError:\n                            # If we can't parse it, we need manual intervention\n                            self.unfixable_issues['config'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'reason': \"Config file has JSON syntax errors that require manual fixing\"\n                            })\n                            unfixable_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to fix config format: {e}\")\n                        self.unfixable_issues['config'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to fix config format: {e}\"\n                        })\n                        unfixable_count += 1\n                elif check in ['required_fields', 'required_settings', 'path_validations', 'models_configuration']:\n                    # Try to add missing required fields and restructure the config\n                    try:\n                        config_path = os.path.join(project_root, self.config_path)\n                        if not os.path.exists(config_path):\n                            self.unfixable_issues['config'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'reason': \"Config file doesn't exist. Fix 'config_file_exists' issue first.\"\n                            })\n                            unfixable_count += 1\n                            continue\n                        \n                        with open(config_path, 'r') as f:\n                            config_data = json.load(f)\n                        \n                        # Create a new restructured configuration\n                        restructured_config = {}\n                        \n                        # Model section\n                        restructured_config[\"model\"] = {\n                            \"provider\": \"ollama\",\n                            \"name\": config_data.get('model', 'llama3:8b'),\n                            \"api_key\": \"\",\n                            \"use_8bit\": config_data.get('use_8bit', True),\n                            \"top_p\": config_data.get('top_p', 0.9),\n                            \"temperature\": config_data.get('temperature', 0.7),\n                            \"max_tokens\": config_data.get('max_tokens', 2048),\n                            \"context_window\": config_data.get('context_window', 4096)\n                        }\n                        \n                        # UI section\n                        restructured_config[\"ui\"] = {\n                            \"theme\": config_data.get('theme', 'System'),\n                            \"font_size\": config_data.get('font_size', 12),\n                            \"window_size\": \"1024x768\",\n                            \"show_debug_messages\": config_data.get('show_debug_messages', False),\n                            \"start_minimized\": config_data.get('start_minimized', False),\n                            \"confirm_exit\": config_data.get('confirm_exit', True)\n                        }\n                        \n                        # Plugins section\n                        restructured_config[\"plugins\"] = {\n                            \"enabled\": config_data.get('autoload_plugins', []),\n                            \"plugin_directory\": \"plugins\",\n                            \"settings\": {}\n                        }\n                        if 'autoload_plugins' in config_data:\n                            restructured_config[\"plugins\"][\"enabled\"] = config_data['autoload_plugins']\n                        \n                        # Memory section\n                        restructured_config[\"memory\"] = {\n                            \"enabled\": config_data.get('auto_save_session', True),\n                            \"storage_type\": \"vector\",\n                            \"max_history\": 100,\n                            \"embedding_model\": config_data.get('embedding_model', 'all-mpnet-base-v2'),\n                            \"relevance_threshold\": config_data.get('relevance_threshold', 0.7),\n                            \"default_result_count\": config_data.get('default_result_count', 5),\n                            \"index_path\": config_data.get('index_path', 'data/vector_store/vector_store.json')\n                        }\n                        \n                        # Logging section\n                        restructured_config[\"logging\"] = {\n                            \"log_level\": config_data.get('log_level', 'INFO'),\n                            \"log_directory\": config_data.get('log_dir', 'data/logs'),\n                            \"max_log_size_mb\": config_data.get('max_log_size_mb', 10),\n                            \"keep_backup_logs\": config_data.get('keep_backup_logs', True)\n                        }\n                        \n                        # Ollama section\n                        restructured_config[\"ollama\"] = {\n                            \"url\": config_data.get('ollama_url', 'http://localhost:11434'),\n                            \"model_path\": config_data.get('model_path', '')\n                        }\n                        \n                        # System section\n                        restructured_config[\"system\"] = {\n                            \"system_message\": config_data.get('system_message', 'You are Irintai, a helpful and knowledgeable assistant.'),\n                            \"system_prompt\": config_data.get('system_prompt', 'You are a helpful, creative, and knowledgeable assistant.'),\n                            \"inference_mode\": config_data.get('inference_mode', 'GPU'),\n                            \"memory_mode\": config_data.get('memory_mode', 'Auto'),\n                            \"check_updates\": config_data.get('check_updates', True),\n                            \"nsfw_enabled\": config_data.get('nsfw_enabled', False)\n                        }\n                        \n                        # Write the restructured config\n                        with open(config_path, 'w') as f:\n                            json.dump(restructured_config, f, indent=2)\n                        \n                        self.fixed_issues['config'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': \"Completely restructured configuration with proper sections and required fields\"\n                        })\n                        fixed_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to fix required fields: {e}\")\n                        self.unfixable_issues['config'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to fix required fields: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                else:\n                    # Generic unfixable issue\n                    self.unfixable_issues['config'].append({\n                        'check': check,\n                        'message': result.get('message', ''),\n                        'reason': \"No automated fix available for this issue\"\n                    })\n                    unfixable_count += 1\n        \n        return fixed_count, unfixable_count\n    def _fix_ollama_issues(self, results):\n        \"\"\"Fix Ollama-related issues\"\"\"\n        fixed_count = 0\n        unfixable_count = 0\n        \n        for check, result in results.items():\n            if isinstance(result, dict) and result.get('status', '').lower() in ['failure', 'warning']:\n                issue_description = f\"{check}: {result.get('message', 'No details')}\"\n                if check in ['ollama_installed', 'ollama_installation', 'list_local_models', 'pull_model']:\n                    # For Ollama-related issues, recommend installation and provide guidance\n                    # We can't automatically install Ollama, but we can guide the user\n                    \n                    # First, create a shell script that tries multiple Ollama version commands\n                    try:\n                        # Create a batch file to check for Ollama using multiple version command formats\n                        ollama_check_script = os.path.join(project_root, \"check_ollama.bat\")\n                        with open(ollama_check_script, 'w') as f:\n                            f.write('@echo off\\n')\n                            f.write('echo Checking Ollama installation...\\n')\n                            f.write('echo.\\n')\n                            f.write('echo Trying format 1: ollama --version\\n')\n                            f.write('ollama --version 2>nul\\n')\n                            f.write('if %ERRORLEVEL% EQU 0 goto :found\\n\\n')\n                            f.write('echo Trying format 2: ollama -v\\n')\n                            f.write('ollama -v 2>nul\\n')\n                            f.write('if %ERRORLEVEL% EQU 0 goto :found\\n\\n')\n                            f.write('echo Trying format 3: ollama version\\n')\n                            f.write('ollama version 2>nul\\n')\n                            f.write('if %ERRORLEVEL% EQU 0 goto :found\\n\\n')\n                            f.write('echo Checking if Ollama is running...\\n')\n                            f.write('echo Checking http://localhost:11434/api/version\\n')\n                            f.write('powershell -command \"try { $response = Invoke-WebRequest -Uri http://localhost:11434/api/version -UseBasicParsing; if($response.StatusCode -eq 200) { Write-Host \\'Ollama API is responding\\'; exit 0 } else { Write-Host \\'Ollama API returned status code: \\' $response.StatusCode; exit 1 } } catch { Write-Host \\'Ollama API not responding: \\' $_.Exception.Message; exit 1 }\"\\n')\n                            f.write('if %ERRORLEVEL% EQU 0 goto :running\\n\\n')\n                            f.write('echo Ollama not found or not running.\\n')\n                            f.write('goto :notfound\\n\\n')\n                            f.write(':found\\n')\n                            f.write('echo Ollama is installed. Checking if it is running...\\n')\n                            f.write('powershell -command \"try { $response = Invoke-WebRequest -Uri http://localhost:11434/api/version -UseBasicParsing; if($response.StatusCode -eq 200) { Write-Host \\'Ollama API is responding\\'; exit 0 } else { Write-Host \\'Ollama API returned status code: \\' $response.StatusCode; exit 1 } } catch { Write-Host \\'Ollama API not responding: \\' $_.Exception.Message; exit 1 }\"\\n')\n                            f.write('if %ERRORLEVEL% EQU 0 goto :running\\n')\n                            f.write('echo Ollama is installed but not running. Starting Ollama service...\\n')\n                            f.write('start /B ollama serve\\n')\n                            f.write('timeout /t 5 /nobreak > nul\\n')\n                            f.write('goto :end\\n\\n')\n                            f.write(':running\\n')\n                            f.write('echo Ollama is running properly!\\n')\n                            f.write('goto :end\\n\\n')\n                            f.write(':notfound\\n')\n                            f.write('echo Checking common Ollama installation paths...\\n')\n                            for path in [\"C:\\\\Program Files\\\\Ollama\", \"C:\\\\Ollama\", \"%USERPROFILE%\\\\Ollama\", \"%LOCALAPPDATA%\\\\Ollama\"]:\n                                f.write(f'if exist \"{path}\\\\ollama.exe\" (\\n')\n                                f.write(f'  echo Found Ollama at {path}\\\\ollama.exe\\n')\n                                f.write(f'  echo Adding {path} to PATH for this session\\n')\n                                f.write(f'  set \"PATH=%PATH%;{path}\"\\n')\n                                f.write('  echo Starting Ollama service...\\n')\n                                f.write('  start /B ollama serve\\n')\n                                f.write('  timeout /t 5 /nobreak > nul\\n')\n                                f.write('  goto :end\\n')\n                                f.write(')\\n\\n')\n                            f.write('echo Ollama not found. Please install it from https://ollama.ai\\n')\n                            f.write(':end\\n')\n                        \n                        # Create a second bat file that users can run to always start Ollama properly\n                        startup_script = os.path.join(project_root, \"start_ollama.bat\")\n                        with open(startup_script, 'w') as f:\n                            f.write('@echo off\\n')\n                            f.write('echo Starting Ollama service...\\n')\n                            f.write('powershell -command \"try { $response = Invoke-WebRequest -Uri http://localhost:11434/api/version -UseBasicParsing; if($response.StatusCode -eq 200) { Write-Host \\'Ollama is already running\\'; exit 0 } } catch {}\\\"\\n')\n                            f.write('if %ERRORLEVEL% EQU 0 goto :already_running\\n\\n')\n                            f.write('for %%p in (\\n')\n                            f.write('  \"C:\\\\Program Files\\\\Ollama\\\\ollama.exe\"\\n')\n                            f.write('  \"C:\\\\Ollama\\\\ollama.exe\"\\n')\n                            f.write('  \"%USERPROFILE%\\\\Ollama\\\\ollama.exe\"\\n')\n                            f.write('  \"%LOCALAPPDATA%\\\\Ollama\\\\ollama.exe\"\\n')\n                            f.write(') do (\\n')\n                            f.write('  if exist %%p (\\n')\n                            f.write('    echo Found Ollama at %%p\\n')\n                            f.write('    echo Adding Ollama directory to PATH\\n')\n                            f.write('    for %%d in (%%p\\\\..) do set \"OLLAMA_DIR=%%~fd\"\\n')\n                            f.write('    set \"PATH=%PATH%;%OLLAMA_DIR%\"\\n')\n                            f.write('    echo Starting Ollama service...\\n')\n                            f.write('    start /B ollama serve\\n')\n                            f.write('    echo Ollama service started.\\n')\n                            f.write('    echo Waiting for the service to initialize...\\n')\n                            f.write('    timeout /t 5 /nobreak > nul\\n')\n                            f.write('    goto :end\\n')\n                            f.write('  )\\n')\n                            f.write(')\\n\\n')\n                            f.write('echo Ollama executable not found. Please install Ollama from https://ollama.ai\\n')\n                            f.write('goto :end\\n\\n')\n                            f.write(':already_running\\n')\n                            f.write('echo Ollama is already running.\\n')\n                            f.write(':end\\n')\n                            f.write('echo.\\n')\n                            f.write('echo You can now use IrintAI Assistant.\\n')\n                            f.write('echo Press any key to exit...\\n')\n                            f.write('pause > nul\\n')\n\n                        # Run the check script\n                        import subprocess\n                        subprocess.run([ollama_check_script], shell=True)\n                        \n                        self.fixed_issues['ollama'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': f\"Created diagnostic scripts (check_ollama.bat and start_ollama.bat) to detect and fix Ollama installation issues. Please run start_ollama.bat before using IrintAI Assistant.\"\n                        })\n                        fixed_count += 1\n                    \n                    except Exception as e:\n                        logger.error(f\"Failed to create Ollama scripts: {e}\")\n                        \n                        # Fallback: Check if Ollama is actually installed but just not in PATH\n                        ollama_paths = [\n                            \"C:\\\\Program Files\\\\Ollama\\\\ollama.exe\",\n                            \"C:\\\\Ollama\\\\ollama.exe\",\n                            os.path.expanduser(\"~\\\\Ollama\\\\ollama.exe\"),\n                            os.path.expanduser(\"~\\\\AppData\\\\Local\\\\Ollama\\\\ollama.exe\")\n                        ]\n                        \n                        found_ollama = False\n                        for path in ollama_paths:\n                            if os.path.exists(path):\n                                found_ollama = True\n                                # Try to create a simpler batch script\n                                try:\n                                    bat_path = os.path.join(project_root, \"start_ollama_simple.bat\")\n                                    with open(bat_path, 'w') as f:\n                                        f.write(f'@echo off\\necho Adding Ollama to PATH...\\nset \"PATH=%PATH%;{os.path.dirname(path)}\"\\necho Starting Ollama server...\\nstart /B ollama serve\\necho Ollama server started in background.\\n')\n                                    \n                                    self.fixed_issues['ollama'].append({\n                                        'check': check,\n                                        'message': result.get('message', ''),\n                                        'fix': f\"Created start_ollama_simple.bat script to add Ollama to PATH and start the server. Please run this script before using IrintAI Assistant.\"\n                                    })\n                                    fixed_count += 1\n                                    break\n                                except Exception as e2:\n                                    logger.error(f\"Failed to create simple Ollama startup script: {e2}\")\n                        \n                        if not found_ollama:\n                            # Provide detailed instructions for installing Ollama\n                            self.unfixable_issues['ollama'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'reason': \"Ollama needs to be installed manually. Please visit https://ollama.ai, download and install Ollama, then run 'ollama serve' from a terminal.\"\n                            })\n                            unfixable_count += 1\n                \n                elif check == 'ollama_running':\n                    # Try to start Ollama service\n                    try:\n                        import subprocess\n                        import platform\n                        \n                        system = platform.system().lower()\n                        if system == 'windows':\n                            # Start Ollama on Windows\n                            subprocess.Popen(['start', 'ollama', 'serve'], \n                                           shell=True, \n                                           stdout=subprocess.PIPE,\n                                           stderr=subprocess.PIPE)\n                        elif system == 'darwin':\n                            # Start Ollama on macOS\n                            subprocess.Popen(['open', '-a', 'Ollama'])\n                        elif system == 'linux':\n                            # Start Ollama on Linux\n                            subprocess.Popen(['ollama', 'serve'], \n                                           stdout=subprocess.PIPE,\n                                           stderr=subprocess.PIPE)\n                        \n                        # Give it time to start\n                        import time\n                        time.sleep(3)\n                        \n                        # Check if it's running now\n                        try:\n                            response = requests.get('http://localhost:11434/api/version')\n                            if response.status_code == 200:\n                                self.fixed_issues['ollama'].append({\n                                    'check': check,\n                                    'message': result.get('message', ''),\n                                    'fix': \"Started Ollama service\"\n                                })\n                                fixed_count += 1\n                            else:\n                                self.unfixable_issues['ollama'].append({\n                                    'check': check,\n                                    'message': result.get('message', ''),\n                                    'reason': \"Failed to start Ollama service automatically\"\n                                })\n                                unfixable_count += 1\n                        except requests.exceptions.RequestException:\n                            self.unfixable_issues['ollama'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'reason': \"Failed to start Ollama service automatically\"\n                            })\n                            unfixable_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to start Ollama: {e}\")\n                        self.unfixable_issues['ollama'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to start Ollama: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                elif check == 'model_available':\n                    # Try to pull the model\n                    try:\n                        # Get the model name from config\n                        config_path = os.path.join(project_root, self.config_path)\n                        with open(config_path, 'r') as f:\n                            config_data = json.load(f)\n                        \n                        model_name = config_data.get('model', {}).get('name', 'llama2')\n                        \n                        # Try to pull the model\n                        import subprocess\n                        result = subprocess.run(['ollama', 'pull', model_name], \n                                             stdout=subprocess.PIPE,\n                                             stderr=subprocess.PIPE,\n                                             text=True)\n                        \n                        if result.returncode == 0:\n                            self.fixed_issues['ollama'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'fix': f\"Pulled model '{model_name}' successfully\"\n                            })\n                            fixed_count += 1\n                        else:\n                            self.unfixable_issues['ollama'].append({\n                                'check': check,\n                                'message': result.get('message', ''),\n                                'reason': f\"Failed to pull model: {result.stderr}\"\n                            })\n                            unfixable_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to pull model: {e}\")\n                        self.unfixable_issues['ollama'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to pull model: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                else:\n                    # Generic unfixable issue\n                    self.unfixable_issues['ollama'].append({\n                        'check': check,\n                        'message': result.get('message', ''),\n                        'reason': \"No automated fix available for this issue\"\n                    })\n                    unfixable_count += 1\n        \n        return fixed_count, unfixable_count\n    \n    def _fix_plugin_issues(self, results):\n        \"\"\"Fix plugin-related issues\"\"\"\n        fixed_count = 0\n        unfixable_count = 0\n        \n        for check, result in results.items():\n            if isinstance(result, dict) and result.get('status', '').lower() in ['failure', 'warning']:\n                issue_description = f\"{check}: {result.get('message', 'No details')}\"\n                \n                if check == 'plugin_directory_exists':\n                    # Try to create plugin directory\n                    try:\n                        plugins_dir = os.path.join(project_root, 'plugins')\n                        os.makedirs(plugins_dir, exist_ok=True)\n                        \n                        self.fixed_issues['plugin'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': \"Created plugins directory\"\n                        })\n                        fixed_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to create plugin directory: {e}\")\n                        self.unfixable_issues['plugin'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to create plugin directory: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                elif check == 'plugin_dependencies':\n                    # Try to install missing dependencies\n                    try:\n                        message = result.get('message', '')\n                        import re\n                        missing_deps = re.findall(r\"missing: ([a-zA-Z0-9_\\-]+)\", message)\n                        \n                        if missing_deps:\n                            import subprocess\n                            for dep in missing_deps:\n                                subprocess.check_call([sys.executable, '-m', 'pip', 'install', dep])\n                            \n                            self.fixed_issues['plugin'].append({\n                                'check': check,\n                                'message': message,\n                                'fix': f\"Installed missing dependencies: {', '.join(missing_deps)}\"\n                            })\n                            fixed_count += 1\n                        else:\n                            self.unfixable_issues['plugin'].append({\n                                'check': check,\n                                'message': message,\n                                'reason': \"Couldn't identify specific missing dependencies\"\n                            })\n                            unfixable_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to fix plugin dependencies: {e}\")\n                        self.unfixable_issues['plugin'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to fix plugin dependencies: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                else:\n                    # Generic unfixable issue\n                    self.unfixable_issues['plugin'].append({\n                        'check': check,\n                        'message': result.get('message', ''),\n                        'reason': \"No automated fix available for this issue\"\n                    })\n                    unfixable_count += 1\n        \n        return fixed_count, unfixable_count\n    \n    def _fix_memory_issues(self, results):\n        \"\"\"Fix memory system-related issues\"\"\"\n        fixed_count = 0\n        unfixable_count = 0\n        \n        for check, result in results.items():\n            if isinstance(result, dict) and result.get('status', '').lower() in ['failure', 'warning']:\n                issue_description = f\"{check}: {result.get('message', 'No details')}\"\n                \n                if check == 'memory_directory_exists':\n                    # Try to create memory directory\n                    try:\n                        memory_dir = os.path.join(project_root, 'data', 'vector_store')\n                        os.makedirs(memory_dir, exist_ok=True)\n                        \n                        self.fixed_issues['memory'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': \"Created memory directory\"\n                        })\n                        fixed_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to create memory directory: {e}\")\n                        self.unfixable_issues['memory'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to create memory directory: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                elif check == 'embedding_model':\n                    # Try to install required embedding model packages\n                    try:\n                        # Install sentence-transformers which includes good embedding models\n                        import subprocess\n                        subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'sentence-transformers'])\n                        \n                        self.fixed_issues['memory'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': \"Installed sentence-transformers package for embedding models\"\n                        })\n                        fixed_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to install embedding model: {e}\")\n                        self.unfixable_issues['memory'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to install embedding model: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                else:\n                    # Generic unfixable issue\n                    self.unfixable_issues['memory'].append({\n                        'check': check,\n                        'message': result.get('message', ''),\n                        'reason': \"No automated fix available for this issue\"\n                    })\n                    unfixable_count += 1\n        \n        return fixed_count, unfixable_count\n    \n    def _fix_network_issues(self, results):\n        \"\"\"Fix network-related issues\"\"\"\n        fixed_count = 0\n        unfixable_count = 0\n        \n        for check, result in results.items():\n            if isinstance(result, dict) and result.get('status', '').lower() in ['failure', 'warning']:\n                issue_description = f\"{check}: {result.get('message', 'No details')}\"\n                \n                # Most network issues require manual intervention\n                if check == 'proxy_settings':\n                    # Try to clear proxy settings that might be causing issues\n                    try:\n                        os.environ.pop('HTTP_PROXY', None)\n                        os.environ.pop('HTTPS_PROXY', None)\n                        os.environ.pop('http_proxy', None)\n                        os.environ.pop('https_proxy', None)\n                        \n                        self.fixed_issues['network'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'fix': \"Cleared proxy environment variables for this session\"\n                        })\n                        fixed_count += 1\n                    except Exception as e:\n                        logger.error(f\"Failed to clear proxy settings: {e}\")\n                        self.unfixable_issues['network'].append({\n                            'check': check,\n                            'message': result.get('message', ''),\n                            'reason': f\"Failed to clear proxy settings: {e}\"\n                        })\n                        unfixable_count += 1\n                \n                else:\n                    # Generic unfixable network issue\n                    self.unfixable_issues['network'].append({\n                        'check': check,\n                        'message': result.get('message', ''),\n                        'reason': \"Network issues typically require manual intervention\"\n                    })\n                    unfixable_count += 1\n        \n        return fixed_count, unfixable_count\n    \n    def print_fix_report(self):\n        \"\"\"Print a report of fixed and unfixable issues\"\"\"\n        print(\"\\n===== IrintAI Assistant Diagnostic Fixer Report =====\")\n        print(f\"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        \n        # Count fixed and unfixable issues\n        total_fixed = sum(len(issues) for issues in self.fixed_issues.values())\n        total_unfixable = sum(len(issues) for issues in self.unfixable_issues.values())\n        \n        print(f\"Total issues fixed: {total_fixed}\")\n        print(f\"Total issues that need manual attention: {total_unfixable}\")\n        \n        # Print fixed issues\n        if total_fixed > 0:\n            print(\"\\n--- FIXED ISSUES ---\")\n            for module, issues in self.fixed_issues.items():\n                if issues:\n                    print(f\"\\n{module.upper()} Module:\")\n                    for i, issue in enumerate(issues, 1):\n                        print(f\"  {i}. {issue['check']}\")\n                        print(f\"     Issue: {issue['message']}\")\n                        print(f\"     Fix: {issue['fix']}\")\n        \n        # Print unfixable issues\n        if total_unfixable > 0:\n            print(\"\\n--- ISSUES REQUIRING MANUAL ATTENTION ---\")\n            for module, issues in self.unfixable_issues.items():\n                if issues:\n                    print(f\"\\n{module.upper()} Module:\")\n                    for i, issue in enumerate(issues, 1):\n                        print(f\"  {i}. {issue['check']}\")\n                        print(f\"     Issue: {issue['message']}\")\n                        print(f\"     Reason: {issue['reason']}\")\n        \n        print(\"\\n===== End of Fix Report =====\")\n\n\n# Add a command-line interface to run the fixer\ndef main():\n    import argparse\n    \n    parser = argparse.ArgumentParser(description=\"IrintAI Assistant Diagnostic Fixer\")\n    parser.add_argument('--module', '-m', choices=['all', 'system', 'config', 'ollama', 'plugin', 'memory', 'network'],\n                       default='all', help='Specific module to diagnose and fix')\n    parser.add_argument('--config', '-c', default='data/config.json',\n                       help='Path to configuration file')\n    \n    args = parser.parse_args()\n    \n    # Initialize fixer\n    fixer = DiagnosticFixer(config_path=args.config)\n    \n    # Run diagnostics and fixes\n    if args.module == 'all':\n        fixer.fix_all_issues()\n    else:\n        fixer.fix_module_issues(args.module)\n    \n    # Print report\n    fixer.print_fix_report()\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\plugin_dependency_manager.py": "\"\"\"\nPlugin Dependency Manager for IrintAI Assistant\nHandles plugin dependencies and version requirements\n\"\"\"\nimport os\nimport json\nfrom typing import Dict, List, Any, Tuple, Set, Optional\n\nclass DependencyManager:\n    \"\"\"\n    Manages plugin dependencies and version requirements\n    \"\"\"\n    \n    def __init__(self, logger=None):\n        \"\"\"\n        Initialize the dependency manager\n        \n        Args:\n            logger: Optional logger for dependency logging\n        \"\"\"\n        self.logger = logger\n        self.plugins = {}  # Plugin info by plugin_id\n        self.plugin_dependencies = {}  # Dependencies by plugin_id\n        \n    def _log(self, message, level=\"INFO\"):\n        \"\"\"Log a message if logger is available\"\"\"\n        if self.logger:\n            if hasattr(self.logger, 'log'):\n                self.logger.log(f\"[DependencyManager] {message}\", level)\n            else:\n                print(f\"[DependencyManager] {message}\")\n                \n    def register_plugin(self, plugin_id: str, plugin_info: Dict[str, Any]) -> bool:\n        \"\"\"\n        Register a plugin with the dependency manager\n        \n        Args:\n            plugin_id: Plugin identifier\n            plugin_info: Plugin metadata\n            \n        Returns:\n            True if registration was successful\n        \"\"\"\n        if not plugin_info:\n            self._log(f\"Failed to register plugin {plugin_id}: No plugin info provided\", \"ERROR\")\n            return False\n            \n        # Extract plugin information\n        plugin_data = {\n            'id': plugin_id,\n            'name': plugin_info.get('name', plugin_id),\n            'version': plugin_info.get('version', '1.0.0'),\n            'compatibility': plugin_info.get('compatibility', '0.0.0'),\n            'dependencies': plugin_info.get('dependencies', [])\n        }\n        \n        # Register the plugin\n        self.plugins[plugin_id] = plugin_data\n        \n        # Process dependencies\n        self._process_dependencies(plugin_id, plugin_data['dependencies'])\n        \n        self._log(f\"Registered plugin {plugin_id} v{plugin_data['version']}\")\n        return True\n        \n    def unregister_plugin(self, plugin_id: str) -> bool:\n        \"\"\"\n        Unregister a plugin from the dependency manager\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            True if unregistration was successful\n        \"\"\"\n        if plugin_id not in self.plugins:\n            return False\n            \n        # Remove plugin\n        del self.plugins[plugin_id]\n        \n        # Remove dependencies\n        if plugin_id in self.plugin_dependencies:\n            del self.plugin_dependencies[plugin_id]\n            \n        # Remove this plugin as a dependency for other plugins\n        for dependencies in self.plugin_dependencies.values():\n            dependencies.discard(plugin_id)\n            \n        self._log(f\"Unregistered plugin {plugin_id}\")\n        return True\n        \n    def _process_dependencies(self, plugin_id: str, dependencies: List[str]) -> None:\n        \"\"\"\n        Process plugin dependencies\n        \n        Args:\n            plugin_id: Plugin identifier\n            dependencies: List of dependency strings\n        \"\"\"\n        if not dependencies:\n            self.plugin_dependencies[plugin_id] = set()\n            return\n            \n        # Parse dependencies\n        dep_set = set()\n        for dep in dependencies:\n            # Dependencies can be specified as \"plugin_id\" or \"plugin_id>=1.0.0\"\n            parts = dep.split('>=')\n            if len(parts) == 1:\n                dep_id = parts[0].strip()\n                dep_set.add(dep_id)\n            else:\n                dep_id = parts[0].strip()\n                # We could store version requirements here if needed\n                dep_set.add(dep_id)\n                \n        self.plugin_dependencies[plugin_id] = dep_set\n        \n    def check_dependencies(self, plugin_id: str, active_plugins: List[str]) -> Tuple[bool, List[str]]:\n        \"\"\"\n        Check if all dependencies for a plugin are satisfied\n        \n        Args:\n            plugin_id: Plugin identifier\n            active_plugins: List of currently active plugin IDs\n            \n        Returns:\n            Tuple of (dependencies_met, missing_dependencies)\n        \"\"\"\n        if plugin_id not in self.plugin_dependencies:\n            return True, []\n            \n        dependencies = self.plugin_dependencies[plugin_id]\n        if not dependencies:\n            return True, []\n            \n        # Check if all dependencies are in active plugins\n        active_set = set(active_plugins)\n        missing = dependencies - active_set\n        \n        if missing:\n            return False, list(missing)\n        return True, []\n        \n    def get_plugin_dependents(self, plugin_id: str) -> List[str]:\n        \"\"\"\n        Get plugins that depend on the given plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            List of plugin IDs that depend on the given plugin\n        \"\"\"\n        dependents = []\n        for pid, dependencies in self.plugin_dependencies.items():\n            if plugin_id in dependencies:\n                dependents.append(pid)\n                \n        return dependents\n        \n    def get_activation_order(self, plugin_ids: List[str]) -> List[str]:\n        \"\"\"\n        Get the order in which plugins should be activated\n        \n        Args:\n            plugin_ids: List of plugin IDs to activate\n            \n        Returns:\n            Ordered list of plugin IDs\n        \"\"\"\n        # Build dependency graph\n        graph = {}\n        for pid in plugin_ids:\n            if pid in self.plugin_dependencies:\n                # Only include dependencies that are in the list of plugins to activate\n                deps = [d for d in self.plugin_dependencies[pid] if d in plugin_ids]\n                graph[pid] = deps\n            else:\n                graph[pid] = []\n                \n        # Topological sort\n        result = []\n        visited = set()\n        temp_mark = set()\n        \n        def visit(node):\n            if node in temp_mark:\n                # Circular dependency\n                self._log(f\"Circular dependency detected for plugin {node}\", \"WARNING\")\n                return\n                \n            if node not in visited:\n                temp_mark.add(node)\n                \n                # Visit dependencies first\n                for dep in graph.get(node, []):\n                    visit(dep)\n                    \n                temp_mark.discard(node)\n                visited.add(node)\n                result.append(node)\n                \n        # Visit all nodes\n        for pid in graph:\n            if pid not in visited:\n                visit(pid)\n                \n        # Reverse to get activation order (dependencies first)\n        return list(reversed(result))\n        \n    def get_deactivation_order(self, plugin_ids: List[str]) -> List[str]:\n        \"\"\"\n        Get the order in which plugins should be deactivated\n        \n        Args:\n            plugin_ids: List of plugin IDs to deactivate\n            \n        Returns:\n            Ordered list of plugin IDs\n        \"\"\"\n        # For deactivation, we want the reverse of the activation order\n        # (dependents before dependencies)\n        activation_order = self.get_activation_order(plugin_ids)\n        return list(reversed(activation_order))\n        \n    def verify_compatibility(self, plugin_id: str, core_version: str) -> bool:\n        \"\"\"\n        Verify if a plugin is compatible with the core\n        \n        Args:\n            plugin_id: Plugin identifier\n            core_version: Core system version\n            \n        Returns:\n            True if compatible\n        \"\"\"\n        if plugin_id not in self.plugins:\n            return False\n            \n        plugin_data = self.plugins[plugin_id]\n        required_version = plugin_data.get('compatibility', '0.0.0')\n        \n        # Simple version comparison\n        core_parts = self._parse_version(core_version)\n        required_parts = self._parse_version(required_version)\n        \n        # Core version must be >= required version\n        for i in range(max(len(core_parts), len(required_parts))):\n            core_part = core_parts[i] if i < len(core_parts) else 0\n            required_part = required_parts[i] if i < len(required_parts) else 0\n            \n            if core_part > required_part:\n                return True\n            if core_part < required_part:\n                return False\n                \n        return True\n        \n    def _parse_version(self, version_str: str) -> List[int]:\n        \"\"\"\n        Parse a version string into parts\n        \n        Args:\n            version_str: Version string (e.g., \"1.2.3\")\n            \n        Returns:\n            List of version parts\n        \"\"\"\n        try:\n            parts = version_str.split('.')\n            return [int(p) for p in parts]\n        except ValueError:\n            self._log(f\"Invalid version format: {version_str}\", \"ERROR\")\n            return [0, 0, 0]\n            \n    def get_plugin_info(self, plugin_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get information about a plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            Plugin information dictionary\n        \"\"\"\n        return self.plugins.get(plugin_id, {})\n        \n    def get_all_plugins(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Get information about all plugins\n        \n        Returns:\n            Dictionary of plugin information by plugin ID\n        \"\"\"\n        return self.plugins.copy()\n        \n    def get_plugin_dependencies(self, plugin_id: str) -> List[str]:\n        \"\"\"\n        Get dependencies for a plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            List of dependency plugin IDs\n        \"\"\"\n        if plugin_id not in self.plugin_dependencies:\n            return []\n        return list(self.plugin_dependencies[plugin_id])\n        \n    def get_dependency_graph(self) -> Dict[str, List[str]]:\n        \"\"\"\n        Get the complete dependency graph\n        \n        Returns:\n            Dictionary of plugin IDs to their dependencies\n        \"\"\"\n        graph = {}\n        for plugin_id, deps in self.plugin_dependencies.items():\n            graph[plugin_id] = list(deps)\n        return graph",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\core\\__init__.py": "\"\"\"\nOllama Hub Plugin Core Module\n\nThis package contains core functionality for the Ollama Hub plugin.\n\"\"\"\n\nfrom plugins.ollama_hub.core.ollama_client import OllamaClient\n\n__all__ = ['OllamaClient']",
  "D:\\AI\\IrintAI Assistant\\ui\\panels\\unified_settings_panel.py": "\"\"\"\nUnified Settings Panel - Consolidated settings UI for all application components\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport os\nfrom typing import Dict, Any, Callable, Optional\n\nclass UnifiedSettingsPanel:\n    \"\"\"\n    A consolidated settings panel that combines all application settings in one place,\n    organized by categories. This helps prevent duplicate controls and ensures settings\n    consistency throughout the application.\n    \"\"\"\n    \n    def __init__(self, parent, settings_manager, core_system, logger=None):\n        \"\"\"\n        Initialize the unified settings panel\n        \n        Args:\n            parent: Parent widget\n            settings_manager: SettingsManager instance\n            core_system: Dictionary containing core system components\n            logger: Optional logging function\n        \"\"\"\n        self.parent = parent\n        self.settings_manager = settings_manager\n        self.core_system = core_system\n        self.log = logger or print\n        \n        # Extract commonly used components from core_system\n        self.chat_engine = core_system.get(\"chat_engine\")\n        self.memory_system = core_system.get(\"memory_system\")\n        self.model_manager = core_system.get(\"model_manager\")\n        self.plugin_manager = core_system.get(\"plugin_manager\")\n        \n        # Create the main frame\n        self.frame = ttk.Frame(parent)\n        \n        # Initialize the UI components\n        self.initialize_ui()\n        \n    def initialize_ui(self):\n        \"\"\"Initialize the settings UI components\"\"\"\n        # Create notebook for settings categories\n        self.notebook = ttk.Notebook(self.frame)\n        self.notebook.pack(fill=\"both\", expand=True, padx=10, pady=10)\n        \n        # Create tabs for different settings categories\n        self.general_tab = ttk.Frame(self.notebook)\n        self.model_tab = ttk.Frame(self.notebook)\n        self.memory_tab = ttk.Frame(self.notebook)\n        self.plugin_tab = ttk.Frame(self.notebook)\n        self.advanced_tab = ttk.Frame(self.notebook)\n        \n        # Add tabs to notebook\n        self.notebook.add(self.general_tab, text=\"General\")\n        self.notebook.add(self.model_tab, text=\"Model Settings\")\n        self.notebook.add(self.memory_tab, text=\"Memory Settings\")\n        self.notebook.add(self.plugin_tab, text=\"Plugin Settings\")\n        self.notebook.add(self.advanced_tab, text=\"Advanced\")\n        \n        # Initialize tab contents\n        self.initialize_general_tab()\n        self.initialize_model_tab()\n        self.initialize_memory_tab()\n        self.initialize_plugin_tab()\n        self.initialize_advanced_tab()\n        \n    def initialize_general_tab(self):\n        \"\"\"Initialize general settings tab\"\"\"\n        frame = ttk.Frame(self.general_tab, padding=10)\n        frame.pack(fill=\"both\", expand=True)\n        \n        # UI Theme settings\n        theme_frame = ttk.LabelFrame(frame, text=\"UI Theme\")\n        theme_frame.pack(fill=\"x\", pady=5)\n        \n        ttk.Label(theme_frame, text=\"Theme:\").grid(row=0, column=0, sticky=\"w\", padx=5, pady=5)\n        \n        self.theme_var = tk.StringVar(value=self.settings_manager.get_setting(\"ui.theme\", \"system\"))\n        themes = [\"light\", \"dark\", \"system\"]\n        theme_combo = ttk.Combobox(theme_frame, textvariable=self.theme_var, values=themes, state=\"readonly\", width=15)\n        theme_combo.grid(row=0, column=1, sticky=\"w\", padx=5, pady=5)\n        theme_combo.bind(\"<<ComboboxSelected>>\", lambda e: self.settings_manager.update_setting(\"ui.theme\", self.theme_var.get()))\n        \n        # System behavior\n        behavior_frame = ttk.LabelFrame(frame, text=\"System Behavior\")\n        behavior_frame.pack(fill=\"x\", pady=10)\n        \n        # Auto-save settings\n        self.autosave_var = tk.BooleanVar(value=self.settings_manager.get_setting(\"system.autosave\", True))\n        ttk.Checkbutton(\n            behavior_frame, \n            text=\"Auto-save settings\", \n            variable=self.autosave_var,\n            command=lambda: self.settings_manager.update_setting(\"system.autosave\", self.autosave_var.get())\n        ).grid(row=0, column=0, sticky=\"w\", padx=5, pady=2)\n        \n        # Auto-load plugins\n        self.autoload_plugins_var = tk.BooleanVar(value=self.settings_manager.get_setting(\"plugins.auto_load\", True))\n        ttk.Checkbutton(\n            behavior_frame, \n            text=\"Auto-load plugins on startup\", \n            variable=self.autoload_plugins_var,\n            command=lambda: self.settings_manager.update_setting(\"plugins.auto_load\", self.autoload_plugins_var.get())\n        ).grid(row=1, column=0, sticky=\"w\", padx=5, pady=2)\n        \n        # System prompt\n        prompt_frame = ttk.LabelFrame(frame, text=\"System Prompt\")\n        prompt_frame.pack(fill=\"x\", pady=10)\n        \n        self.system_prompt_var = tk.StringVar(value=self.settings_manager.get_setting(\n            \"chat.system_prompt\", \n            \"You are Irintai, a helpful and knowledgeable assistant.\"\n        ))\n        \n        prompt_text = tk.Text(prompt_frame, height=4, width=50, wrap=\"word\")\n        prompt_text.insert(\"1.0\", self.system_prompt_var.get())\n        prompt_text.pack(fill=\"x\", padx=5, pady=5)\n        \n        def update_system_prompt():\n            new_prompt = prompt_text.get(\"1.0\", \"end-1c\")\n            self.settings_manager.update_setting(\"chat.system_prompt\", new_prompt)\n            self.log(\"[Settings] System prompt updated\")\n        \n        ttk.Button(\n            prompt_frame,\n            text=\"Update System Prompt\",\n            command=update_system_prompt\n        ).pack(anchor=\"e\", padx=5, pady=5)\n        \n    def initialize_model_tab(self):\n        \"\"\"Initialize model settings tab\"\"\"\n        frame = ttk.Frame(self.model_tab, padding=10)\n        frame.pack(fill=\"both\", expand=True)\n        \n        # Model preferences\n        model_frame = ttk.LabelFrame(frame, text=\"Model Preferences\")\n        model_frame.pack(fill=\"x\", pady=5)\n        \n        # Default model\n        ttk.Label(model_frame, text=\"Default Model:\").grid(row=0, column=0, sticky=\"w\", padx=5, pady=5)\n        \n        self.default_model_var = tk.StringVar(value=self.settings_manager.get_setting(\"model.default\", \"\"))\n        models = self.model_manager.get_available_models() or [\"\"]\n        model_combo = ttk.Combobox(model_frame, textvariable=self.default_model_var, values=models, width=20)\n        model_combo.grid(row=0, column=1, sticky=\"w\", padx=5, pady=5)\n        model_combo.bind(\"<<ComboboxSelected>>\", lambda e: self.settings_manager.update_setting(\"model.default\", self.default_model_var.get()))\n        \n        # Model optimizations\n        optim_frame = ttk.LabelFrame(frame, text=\"Model Optimizations\")\n        optim_frame.pack(fill=\"x\", pady=10)\n        \n        # 8-bit quantization\n        self.use_8bit_var = tk.BooleanVar(value=self.settings_manager.get_setting(\"model.use_8bit\", False))\n        ttk.Checkbutton(\n            optim_frame, \n            text=\"Enable 8-bit quantization (reduces memory usage)\", \n            variable=self.use_8bit_var,\n            command=lambda: self.settings_manager.update_setting(\"model.use_8bit\", self.use_8bit_var.get())\n        ).grid(row=0, column=0, sticky=\"w\", padx=5, pady=2)\n        \n        # GPU offloading\n        self.use_gpu_var = tk.BooleanVar(value=self.settings_manager.get_setting(\"model.use_gpu\", True))\n        ttk.Checkbutton(\n            optim_frame, \n            text=\"Use GPU acceleration when available\", \n            variable=self.use_gpu_var,\n            command=lambda: self.settings_manager.update_setting(\"model.use_gpu\", self.use_gpu_var.get())\n        ).grid(row=1, column=0, sticky=\"w\", padx=5, pady=2)\n        \n        # Model parameters\n        param_frame = ttk.LabelFrame(frame, text=\"Generation Parameters\")\n        param_frame.pack(fill=\"x\", pady=10)\n        \n        # Temperature\n        ttk.Label(param_frame, text=\"Temperature:\").grid(row=0, column=0, sticky=\"w\", padx=5, pady=5)\n        \n        self.temperature_var = tk.DoubleVar(value=self.settings_manager.get_setting(\"model.temperature\", 0.7))\n        temperature_scale = ttk.Scale(\n            param_frame, \n            from_=0.0, \n            to=1.0, \n            variable=self.temperature_var,\n            orient=\"horizontal\",\n            length=200\n        )\n        temperature_scale.grid(row=0, column=1, sticky=\"w\", padx=5, pady=5)\n        temperature_scale.bind(\"<ButtonRelease-1>\", lambda e: self.settings_manager.update_setting(\"model.temperature\", self.temperature_var.get()))\n        \n        temperature_value = ttk.Label(param_frame, textvariable=tk.StringVar(value=f\"{self.temperature_var.get():.2f}\"))\n        temperature_value.grid(row=0, column=2, sticky=\"w\", padx=5, pady=5)\n        \n        def update_temp_display(*args):\n            temperature_value[\"text\"] = f\"{self.temperature_var.get():.2f}\"\n            \n        self.temperature_var.trace_add(\"write\", update_temp_display)\n        \n    def initialize_memory_tab(self):\n        \"\"\"Initialize memory settings tab\"\"\"\n        frame = ttk.Frame(self.memory_tab, padding=10)\n        frame.pack(fill=\"both\", expand=True)\n        \n        # Memory mode settings\n        memory_mode_frame = ttk.LabelFrame(frame, text=\"Memory Mode\")\n        memory_mode_frame.pack(fill=\"x\", pady=5)\n        \n        # Memory mode radio buttons\n        self.memory_mode_var = tk.StringVar(value=self.settings_manager.get_setting(\"memory.mode\", \"off\"))\n        \n        ttk.Radiobutton(memory_mode_frame, text=\"Off (No memory usage)\", \n                       variable=self.memory_mode_var, \n                       value=\"off\", \n                       command=self.sync_memory_mode).pack(anchor=\"w\", padx=10, pady=2)\n                       \n        ttk.Radiobutton(memory_mode_frame, text=\"Manual (Use memory when explicitly requested)\", \n                       variable=self.memory_mode_var, \n                       value=\"manual\", \n                       command=self.sync_memory_mode).pack(anchor=\"w\", padx=10, pady=2)\n                       \n        ttk.Radiobutton(memory_mode_frame, text=\"Auto (Automatically use relevant memories)\", \n                       variable=self.memory_mode_var, \n                       value=\"auto\", \n                       command=self.sync_memory_mode).pack(anchor=\"w\", padx=10, pady=2)\n                       \n        ttk.Radiobutton(memory_mode_frame, text=\"Background (Continuously update memory with context)\", \n                       variable=self.memory_mode_var, \n                       value=\"background\", \n                       command=self.sync_memory_mode).pack(anchor=\"w\", padx=10, pady=2)\n        \n        # Enhanced PDF settings\n        pdf_frame = ttk.LabelFrame(frame, text=\"PDF Processing\")\n        pdf_frame.pack(fill=\"x\", pady=10)\n        \n        # OCR Settings\n        self.ocr_enabled_var = tk.BooleanVar(value=self.settings_manager.get_setting(\"memory.pdf.ocr_enabled\", False))\n        ttk.Checkbutton(\n            pdf_frame, \n            text=\"Enable OCR for image-based PDFs\", \n            variable=self.ocr_enabled_var,\n            command=lambda: self.settings_manager.update_setting(\"memory.pdf.ocr_enabled\", self.ocr_enabled_var.get())\n        ).pack(anchor=\"w\", padx=10, pady=5)\n        \n        ocr_note = \"Note: OCR requires pytesseract and Pillow packages.\"\n        ttk.Label(pdf_frame, text=ocr_note, font=(\"Helvetica\", 8), foreground=\"gray\").pack(anchor=\"w\", padx=10, pady=0)\n        \n        # Add test OCR button\n        ttk.Button(pdf_frame, text=\"Check OCR Installation\", \n                  command=self.check_ocr_installation).pack(anchor=\"w\", padx=10, pady=5)\n        \n        # Advanced memory settings\n        advanced_frame = ttk.LabelFrame(frame, text=\"Advanced Memory Settings\")\n        advanced_frame.pack(fill=\"x\", pady=10)\n        \n        # Memory embedding model\n        ttk.Label(advanced_frame, text=\"Embedding Model:\").grid(row=0, column=0, sticky=\"w\", padx=5, pady=5)\n        \n        self.embedding_model_var = tk.StringVar(value=self.settings_manager.get_setting(\"memory.embedding_model\", \"all-MiniLM-L6-v2\"))\n        embedding_models = [\"all-MiniLM-L6-v2\", \"all-mpnet-base-v2\", \"all-distilroberta-v1\"]\n        embedding_combo = ttk.Combobox(advanced_frame, textvariable=self.embedding_model_var, values=embedding_models, width=25)\n        embedding_combo.grid(row=0, column=1, sticky=\"w\", padx=5, pady=5)\n        embedding_combo.bind(\"<<ComboboxSelected>>\", lambda e: self.settings_manager.update_setting(\"memory.embedding_model\", self.embedding_model_var.get()))\n        \n        # Clear memory button\n        ttk.Button(advanced_frame, text=\"Clear Memory Index\", \n                  command=self.clear_memory_index, style=\"Warning.TButton\").grid(row=1, column=0, columnspan=2, sticky=\"w\", padx=5, pady=10)\n        \n    def initialize_plugin_tab(self):\n        \"\"\"Initialize plugin settings tab\"\"\"\n        frame = ttk.Frame(self.plugin_tab, padding=10)\n        frame.pack(fill=\"both\", expand=True)\n        \n        # Plugin management\n        mgmt_frame = ttk.LabelFrame(frame, text=\"Plugin Management\")\n        mgmt_frame.pack(fill=\"x\", pady=5)\n        \n        # Auto-start plugins\n        self.auto_start_plugins_var = tk.BooleanVar(value=self.settings_manager.get_setting(\"plugins.auto_start\", True))\n        ttk.Checkbutton(\n            mgmt_frame, \n            text=\"Auto-start activated plugins on launch\", \n            variable=self.auto_start_plugins_var,\n            command=lambda: self.settings_manager.update_setting(\"plugins.auto_start\", self.auto_start_plugins_var.get())\n        ).grid(row=0, column=0, sticky=\"w\", padx=5, pady=2)\n        \n        # Plugin directory\n        ttk.Label(mgmt_frame, text=\"Plugin Directory:\").grid(row=1, column=0, sticky=\"w\", padx=5, pady=5)\n        \n        self.plugin_dir_var = tk.StringVar(value=self.settings_manager.get_setting(\"plugins.directory\", \"plugins\"))\n        plugin_dir_entry = ttk.Entry(mgmt_frame, textvariable=self.plugin_dir_var, width=40)\n        plugin_dir_entry.grid(row=1, column=1, sticky=\"w\", padx=5, pady=5)\n        \n        def update_plugin_dir():\n            new_dir = self.plugin_dir_var.get()\n            if os.path.isdir(new_dir):\n                self.settings_manager.update_setting(\"plugins.directory\", new_dir)\n                if self.plugin_manager:\n                    self.plugin_manager.plugin_dir = new_dir\n                    self.log(f\"[Settings] Plugin directory updated to: {new_dir}\")\n            else:\n                messagebox.showerror(\"Invalid Directory\", f\"The directory {new_dir} does not exist.\")\n        \n        ttk.Button(mgmt_frame, text=\"Update\", command=update_plugin_dir).grid(row=1, column=2, sticky=\"w\", padx=5, pady=5)\n        \n        # Plugin security\n        security_frame = ttk.LabelFrame(frame, text=\"Plugin Security\")\n        security_frame.pack(fill=\"x\", pady=10)\n        \n        # Sandbox plugins\n        self.sandbox_plugins_var = tk.BooleanVar(value=self.settings_manager.get_setting(\"plugins.sandbox\", True))\n        ttk.Checkbutton(\n            security_frame, \n            text=\"Run plugins in sandbox mode (recommended)\", \n            variable=self.sandbox_plugins_var,\n            command=lambda: self.settings_manager.update_setting(\"plugins.sandbox\", self.sandbox_plugins_var.get())\n        ).grid(row=0, column=0, sticky=\"w\", padx=5, pady=2)\n        \n        # Verify plugin signatures\n        self.verify_plugins_var = tk.BooleanVar(value=self.settings_manager.get_setting(\"plugins.verify_signatures\", False))\n        ttk.Checkbutton(\n            security_frame, \n            text=\"Verify plugin signatures\", \n            variable=self.verify_plugins_var,\n            command=lambda: self.settings_manager.update_setting(\"plugins.verify_signatures\", self.verify_plugins_var.get())\n        ).grid(row=1, column=0, sticky=\"w\", padx=5, pady=2)\n        \n        # Plugin settings section - will be populated based on loaded plugins\n        if self.plugin_manager and hasattr(self.plugin_manager, \"get_plugins\"):\n            plugins = self.plugin_manager.get_plugins()\n            \n            if plugins:\n                plugins_frame = ttk.LabelFrame(frame, text=\"Plugin Settings\")\n                plugins_frame.pack(fill=\"both\", expand=True, pady=10)\n                \n                # Create a notebook to hold plugin-specific settings\n                plugin_notebook = ttk.Notebook(plugins_frame)\n                plugin_notebook.pack(fill=\"both\", expand=True, padx=5, pady=5)\n                \n                for plugin_id, plugin_info in plugins.items():\n                    if plugin_info.get(\"status\") in [\"ACTIVE\", \"LOADED\"]:\n                        # Create a frame for this plugin\n                        plugin_frame = ttk.Frame(plugin_notebook)\n                        plugin_notebook.add(plugin_frame, text=plugin_info.get(\"name\", plugin_id))\n                        \n                        try:\n                            # Try to get plugin config\n                            config = self.plugin_manager.get_plugin_config(plugin_id)\n                            if config and isinstance(config, dict):\n                                self.create_plugin_settings(plugin_frame, plugin_id, config)\n                            else:\n                                ttk.Label(plugin_frame, text=\"No configurable settings available\").pack(padx=10, pady=10)\n                        except Exception as e:\n                            ttk.Label(plugin_frame, text=f\"Error loading plugin settings: {e}\").pack(padx=10, pady=10)\n            else:\n                ttk.Label(frame, text=\"No active plugins found\").pack(pady=20)\n        else:\n            ttk.Label(frame, text=\"Plugin manager not initialized or no plugins available\").pack(pady=20)\n        \n    def initialize_advanced_tab(self):\n        \"\"\"Initialize advanced settings tab\"\"\"\n        frame = ttk.Frame(self.advanced_tab, padding=10)\n        frame.pack(fill=\"both\", expand=True)\n        \n        # System settings\n        system_frame = ttk.LabelFrame(frame, text=\"System Settings\")\n        system_frame.pack(fill=\"x\", pady=5)\n        \n        # Resource monitoring interval\n        ttk.Label(system_frame, text=\"Resource Monitoring Interval (seconds):\").grid(row=0, column=0, sticky=\"w\", padx=5, pady=5)\n        \n        self.monitoring_interval_var = tk.DoubleVar(value=self.settings_manager.get_setting(\"system.monitoring_interval\", 1.0))\n        interval_spinner = ttk.Spinbox(\n            system_frame,\n            from_=0.1,\n            to=10.0,\n            increment=0.1,\n            textvariable=self.monitoring_interval_var,\n            width=5\n        )\n        interval_spinner.grid(row=0, column=1, sticky=\"w\", padx=5, pady=5)\n        interval_spinner.bind(\"<FocusOut>\", lambda e: self.settings_manager.update_setting(\"system.monitoring_interval\", float(self.monitoring_interval_var.get())))\n        \n        # Logging settings\n        log_frame = ttk.LabelFrame(frame, text=\"Logging Settings\")\n        log_frame.pack(fill=\"x\", pady=10)\n        \n        # Log level\n        ttk.Label(log_frame, text=\"Log Level:\").grid(row=0, column=0, sticky=\"w\", padx=5, pady=5)\n        \n        self.log_level_var = tk.StringVar(value=self.settings_manager.get_setting(\"logging.level\", \"INFO\"))\n        log_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n        log_level_combo = ttk.Combobox(log_frame, textvariable=self.log_level_var, values=log_levels, state=\"readonly\", width=10)\n        log_level_combo.grid(row=0, column=1, sticky=\"w\", padx=5, pady=5)\n        log_level_combo.bind(\"<<ComboboxSelected>>\", lambda e: self.settings_manager.update_setting(\"logging.level\", self.log_level_var.get()))\n        \n        # Log file retention\n        ttk.Label(log_frame, text=\"Log File Retention (days):\").grid(row=1, column=0, sticky=\"w\", padx=5, pady=5)\n        \n        self.log_retention_var = tk.IntVar(value=self.settings_manager.get_setting(\"logging.retention_days\", 30))\n        retention_spinner = ttk.Spinbox(\n            log_frame,\n            from_=1,\n            to=365,\n            textvariable=self.log_retention_var,\n            width=5\n        )\n        retention_spinner.grid(row=1, column=1, sticky=\"w\", padx=5, pady=5)\n        retention_spinner.bind(\"<FocusOut>\", lambda e: self.settings_manager.update_setting(\"logging.retention_days\", int(self.log_retention_var.get())))\n        \n        # Expert settings (show raw config file)\n        expert_frame = ttk.LabelFrame(frame, text=\"Expert Settings\")\n        expert_frame.pack(fill=\"x\", pady=10)\n        \n        ttk.Button(\n            expert_frame,\n            text=\"Edit Raw Configuration\",\n            command=self.show_raw_config\n        ).pack(anchor=\"w\", padx=5, pady=5)\n        \n    def sync_memory_mode(self):\n        \"\"\"Synchronize memory mode changes with the chat engine and settings\"\"\"\n        mode = self.memory_mode_var.get()\n        \n        # Set memory mode in chat engine using the updated interface\n        if mode == \"off\":\n            self.chat_engine.set_memory_mode(enabled=False)\n        elif mode == \"manual\":\n            self.chat_engine.set_memory_mode(enabled=True, auto=False, background=False)\n        elif mode == \"auto\":\n            self.chat_engine.set_memory_mode(enabled=True, auto=True, background=False)\n        elif mode == \"background\":\n            self.chat_engine.set_memory_mode(enabled=True, auto=True, background=True)\n            \n        # Update the setting\n        self.settings_manager.update_setting(\"memory.mode\", mode)\n        self.log(f\"[Memory Mode] Set to: {mode.capitalize()}\")\n        \n    def check_ocr_installation(self):\n        \"\"\"Check if OCR dependencies are installed\"\"\"\n        try:\n            import pytesseract\n            from PIL import Image\n            pytesseract.get_tesseract_version()\n            messagebox.showinfo(\"OCR Check\", \"OCR dependencies are correctly installed.\")\n        except ImportError as e:\n            messagebox.showerror(\"OCR Check\", f\"Missing OCR dependency: {str(e)}\\n\\nInstall with:\\npip install pytesseract pillow\")\n        except Exception as e:\n            messagebox.showerror(\"OCR Check\", f\"OCR error: {str(e)}\\n\\nMake sure Tesseract OCR is installed on your system.\")\n            \n    def clear_memory_index(self):\n        \"\"\"Clear the memory index after confirmation\"\"\"\n        # Ask for confirmation before clearing\n        response = messagebox.askyesno(\n            \"Confirm Clear Memory\",\n            \"Are you sure you want to clear the entire memory index?\\n\\nThis will remove all documents and cannot be undone.\",\n            icon=\"warning\"\n        )\n        \n        if response:\n            # Clear the index\n            self.memory_system.clear_index()\n            self.log(\"[Memory] Memory index cleared\")\n            \n            messagebox.showinfo(\n                \"Memory Cleared\",\n                \"Memory index has been cleared successfully.\"\n            )\n            \n    def create_plugin_settings(self, parent, plugin_id, config):\n        \"\"\"Create settings UI for a specific plugin\"\"\"\n        frame = ttk.Frame(parent, padding=10)\n        frame.pack(fill=\"both\", expand=True)\n        \n        row = 0\n        settings_vars = {}\n        \n        for key, value in config.items():\n            # Skip internal settings that start with underscore\n            if key.startswith('_'):\n                continue\n                \n            # Create label for the setting\n            ttk.Label(frame, text=f\"{key}:\").grid(row=row, column=0, sticky=\"w\", padx=5, pady=5)\n            \n            # Create appropriate control based on the setting type\n            if isinstance(value, bool):\n                # Boolean toggle\n                var = tk.BooleanVar(value=value)\n                ttk.Checkbutton(\n                    frame,\n                    variable=var,\n                    command=lambda k=key, v=var: self.update_plugin_setting(plugin_id, k, v.get())\n                ).grid(row=row, column=1, sticky=\"w\", padx=5, pady=5)\n                settings_vars[key] = var\n                \n            elif isinstance(value, (int, float)):\n                # Numeric spinner\n                var = tk.DoubleVar(value=value) if isinstance(value, float) else tk.IntVar(value=value)\n                spinner = ttk.Spinbox(\n                    frame,\n                    from_=0,\n                    to=9999,\n                    increment=1 if isinstance(value, int) else 0.1,\n                    textvariable=var,\n                    width=10\n                )\n                spinner.grid(row=row, column=1, sticky=\"w\", padx=5, pady=5)\n                spinner.bind(\"<FocusOut>\", lambda e, k=key, v=var: self.update_plugin_setting(plugin_id, k, float(v.get()) if isinstance(value, float) else int(v.get())))\n                settings_vars[key] = var\n                \n            elif isinstance(value, str):\n                # Text entry\n                var = tk.StringVar(value=value)\n                entry = ttk.Entry(frame, textvariable=var, width=30)\n                entry.grid(row=row, column=1, sticky=\"w\", padx=5, pady=5)\n                entry.bind(\"<FocusOut>\", lambda e, k=key, v=var: self.update_plugin_setting(plugin_id, k, v.get()))\n                settings_vars[key] = var\n                \n            row += 1\n            \n        # Add save button at the bottom\n        if row > 0:\n            ttk.Button(\n                frame,\n                text=\"Save Plugin Settings\",\n                command=lambda: self.save_plugin_settings(plugin_id, settings_vars)\n            ).grid(row=row, column=0, columnspan=2, sticky=\"e\", padx=5, pady=10)\n        \n    def update_plugin_setting(self, plugin_id, key, value):\n        \"\"\"Update a single plugin setting\"\"\"\n        try:\n            # Get current config\n            config = self.plugin_manager.get_plugin_config(plugin_id) or {}\n            \n            # Update the specific setting\n            config[key] = value\n            \n            # Save back to plugin\n            self.plugin_manager.set_plugin_config(plugin_id, config)\n            \n        except Exception as e:\n            self.log(f\"[Settings] Error updating plugin setting: {e}\")\n            messagebox.showerror(\"Settings Error\", f\"Failed to update plugin setting: {e}\")\n            \n    def save_plugin_settings(self, plugin_id, settings_vars):\n        \"\"\"Save all plugin settings at once\"\"\"\n        try:\n            # Get current config\n            config = self.plugin_manager.get_plugin_config(plugin_id) or {}\n            \n            # Update with all values from UI\n            for key, var in settings_vars.items():\n                config[key] = var.get()\n                \n            # Save back to plugin\n            self.plugin_manager.set_plugin_config(plugin_id, config)\n            \n            self.log(f\"[Settings] Updated settings for plugin: {plugin_id}\")\n            messagebox.showinfo(\"Settings Saved\", f\"Settings for {plugin_id} have been saved.\")\n            \n        except Exception as e:\n            self.log(f\"[Settings] Error saving plugin settings: {e}\")\n            messagebox.showerror(\"Settings Error\", f\"Failed to save plugin settings: {e}\")\n            \n    def show_raw_config(self):\n        \"\"\"Show and edit raw configuration in a text editor\"\"\"\n        # Create a new top-level window\n        editor = tk.Toplevel(self.parent)\n        editor.title(\"Raw Configuration Editor\")\n        editor.geometry(\"800x600\")\n        \n        # Make it modal\n        editor.transient(self.parent)\n        editor.grab_set()\n        \n        # Create a text editor\n        import json\n        raw_config = json.dumps(self.settings_manager.config_manager.config, indent=2)\n        \n        text_frame = ttk.Frame(editor, padding=10)\n        text_frame.pack(fill=\"both\", expand=True)\n        \n        ttk.Label(text_frame, text=\"Edit raw configuration JSON (experts only):\").pack(anchor=\"w\")\n        \n        text_editor = tk.Text(text_frame, wrap=\"none\", font=(\"Consolas\", 10))\n        text_editor.insert(\"1.0\", raw_config)\n        text_editor.pack(fill=\"both\", expand=True, pady=5)\n        \n        # Add scrollbars\n        x_scrollbar = ttk.Scrollbar(text_frame, orient=\"horizontal\", command=text_editor.xview)\n        x_scrollbar.pack(side=\"bottom\", fill=\"x\")\n        \n        y_scrollbar = ttk.Scrollbar(text_frame, orient=\"vertical\", command=text_editor.yview)\n        y_scrollbar.pack(side=\"right\", fill=\"y\")\n        \n        text_editor.configure(xscrollcommand=x_scrollbar.set, yscrollcommand=y_scrollbar.set)\n        \n        # Create save/cancel buttons\n        button_frame = ttk.Frame(editor, padding=10)\n        button_frame.pack(fill=\"x\")\n        \n        def save_raw_config():\n            try:\n                # Get the edited JSON\n                edited_json = text_editor.get(\"1.0\", \"end-1c\")\n                \n                # Parse it to ensure it's valid\n                new_config = json.loads(edited_json)\n                \n                # Update the config manager\n                self.settings_manager.config_manager.config = new_config\n                self.settings_manager.config_manager.save()\n                \n                messagebox.showinfo(\"Config Saved\", \"Configuration has been updated.\")\n                editor.destroy()\n                \n            except json.JSONDecodeError as e:\n                messagebox.showerror(\"Invalid JSON\", f\"Configuration contains invalid JSON: {e}\")\n                \n        ttk.Button(button_frame, text=\"Save\", command=save_raw_config).pack(side=\"right\", padx=5)\n        ttk.Button(button_frame, text=\"Cancel\", command=editor.destroy).pack(side=\"right\", padx=5)\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\core\\ollamalocal.py": "import tkinter\nimport customtkinter\nimport requests\nimport json\nimport threading\nimport queue  # For thread-safe communication\nimport time\nimport os\nimport datetime\nimport logging\nfrom tkinter import filedialog\n\n# Import configuration settings\nimport config\nfrom model_manager import ModelManager, ModelBrowserDialog\n\n# --- Set up logging ---\nif config.LOGGING_ENABLED:\n    log_level = getattr(logging, config.LOGGING_LEVEL)\n    logging.basicConfig(\n        level=log_level,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.FileHandler(\"ollama_gui.log\"),\n            logging.StreamHandler()\n        ]\n    )\n    logger = logging.getLogger(\"OllamaGUI\")\n    logger.info(\"Starting Ollama Desktop GUI\")\n\n# --- Ensure upload directory exists ---\nif not os.path.exists(config.UPLOAD_DIR):\n    os.makedirs(config.UPLOAD_DIR)\n    if config.LOGGING_ENABLED:\n        logger.info(f\"Created upload directory: {config.UPLOAD_DIR}\")\n\n# --- Main Application Class ---\nclass OllamaGUI(customtkinter.CTk):\n    \"\"\"\n    Main application class for the Ollama Desktop GUI.\n    Provides a graphical interface for interacting with Ollama models.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize the application window and set up the UI components.\"\"\"\n        super().__init__()\n\n        # --- Window Setup ---\n        self.title(config.APP_TITLE)\n        self.geometry(config.INITIAL_WINDOW_SIZE)\n        customtkinter.set_appearance_mode(config.APPEARANCE_MODE)\n        customtkinter.set_default_color_theme(config.COLOR_THEME)\n\n        # Initialize model manager\n        self.model_manager = ModelManager(config.OLLAMA_BASE_URL)\n\n        # --- Internal State ---\n        self.models = []\n        self.selected_model = tkinter.StringVar(value=\"Select Model\")\n        self.is_generating = False\n        self.response_queue = queue.Queue()  # Queue for thread communication\n        self.active_request = None  # Reference to the active request for cancellation\n        self.conversations = []  # Store conversation history\n        self.current_conversation = []  # Current active conversation\n        self.selected_file = None  # Currently selected file for upload\n        \n        # Model parameters\n        self.temperature = tkinter.DoubleVar(value=config.DEFAULT_TEMPERATURE)\n        self.max_tokens = tkinter.IntVar(value=config.DEFAULT_MAX_TOKENS)\n        self.top_p = tkinter.DoubleVar(value=config.DEFAULT_ADDITIONAL_SETTINGS[\"top_p\"])\n        self.frequency_penalty = tkinter.DoubleVar(value=config.DEFAULT_ADDITIONAL_SETTINGS[\"frequency_penalty\"])\n        self.presence_penalty = tkinter.DoubleVar(value=config.DEFAULT_ADDITIONAL_SETTINGS[\"presence_penalty\"])\n        self.context_length = tkinter.IntVar(value=config.DEFAULT_CONTEXT_LIMIT)\n        self.output_token_length = tkinter.IntVar(value=config.DEFAULT_OUTPUT_TOKEN_LENGTH)\n\n        # --- Create Menu Bar ---\n        self.create_menu_bar()\n\n        # --- Create Main Layout ---\n        self.create_layout()\n\n        # --- Initialization ---\n        self.fetch_models_async()\n        self.after(100, self.process_response_queue)  # Start checking the queue\n        \n        if config.LOGGING_ENABLED:\n            logger.info(\"GUI initialized\")\n\n    def create_menu_bar(self):\n        \"\"\"Create the application's menu bar with File and Settings options.\"\"\"\n        menubar = tkinter.Menu(self)\n        self.config(menu=menubar)\n        \n        # File menu\n        file_menu = tkinter.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"File\", menu=file_menu)\n        file_menu.add_command(label=\"New Conversation\", command=self.new_conversation)\n        file_menu.add_command(label=\"Save Conversation\", command=self.save_conversation)\n        file_menu.add_command(label=\"Upload File\", command=self.upload_file)\n        file_menu.add_separator()\n        file_menu.add_command(label=\"Exit\", command=self.quit)\n        \n        # Models menu\n        models_menu = tkinter.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"Models\", menu=models_menu)\n        models_menu.add_command(label=\"Browse & Download Models\", command=self.open_model_browser)\n        models_menu.add_command(label=\"Refresh Local Models\", command=self.refresh_models)\n        \n        # Settings menu\n        settings_menu = tkinter.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"Settings\", menu=settings_menu)\n        settings_menu.add_command(label=\"Model Parameters\", command=self.open_model_settings)\n        settings_menu.add_command(label=\"Appearance\", command=self.open_appearance_settings)\n        \n        # Help menu\n        help_menu = tkinter.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"Help\", menu=help_menu)\n        help_menu.add_command(label=\"About\", command=self.show_about)\n        \n        if config.LOGGING_ENABLED:\n            logger.debug(\"Menu bar created\")\n\n    def refresh_models(self):\n        \"\"\"Refresh the list of local models.\"\"\"\n        # Clear the current model list\n        self.models = []\n        self.model_menu.configure(values=[\"Fetching models...\"])\n        self.selected_model.set(\"Fetching models...\")\n        \n        # Fetch models again\n        self.fetch_models_async()\n    \n    if config.LOGGING_ENABLED:\n        logger.info(\"Refreshing model list\")\n\n    def create_layout(self):\n        \"\"\"Create the main application layout with all UI components.\"\"\"\n        # --- Layout Configuration ---\n        self.grid_rowconfigure(0, weight=1)  # Chat area expands\n        self.grid_rowconfigure(1, weight=0)  # Input area fixed\n        self.grid_columnconfigure(0, weight=1)\n\n        # --- Top Frame (Model Selection & Chat History) ---\n        self.top_frame = customtkinter.CTkFrame(self, corner_radius=0)\n        self.top_frame.grid(row=0, column=0, sticky=\"nsew\")\n        self.top_frame.grid_rowconfigure(1, weight=1)  # Textbox row expands\n        self.top_frame.grid_columnconfigure(0, weight=1)\n\n        # Control Bar (Model Selection)\n        self.control_bar = customtkinter.CTkFrame(self.top_frame)\n        self.control_bar.grid(row=0, column=0, padx=10, pady=(10, 5), sticky=\"ew\")\n        self.control_bar.grid_columnconfigure(0, weight=1)\n\n        # Control Bar (Model Selection)\n        self.control_bar = customtkinter.CTkFrame(self.top_frame)\n        self.control_bar.grid(row=0, column=0, padx=10, pady=(10, 5), sticky=\"ew\")\n        self.control_bar.grid_columnconfigure(0, weight=1)\n\n        # Model Selection Dropdown\n        self.model_menu = customtkinter.CTkOptionMenu(\n            self.control_bar,\n            variable=self.selected_model,\n            values=[\"Fetching models...\"],\n            command=self.on_model_select\n        )\n        self.model_menu.grid(row=0, column=0, padx=(0, 10), pady=0, sticky=\"ew\")\n        self.model_menu.set(\"Fetching models...\")  # Initial state\n\n        # Browse Models Button\n        self.browse_button = customtkinter.CTkButton(\n            self.control_bar,\n            text=\"Browse\",\n            width=70,\n            command=self.open_model_browser\n        )\n        self.browse_button.grid(row=0, column=1, padx=(0, 10), pady=0)\n\n        # Settings Button\n        self.settings_button = customtkinter.CTkButton(\n            self.control_bar,\n            text=\"\u2699\ufe0f\",\n            width=30,\n            command=self.open_model_settings\n        )\n        self.settings_button.grid(row=0, column=2, padx=0, pady=0)\n\n        # Upload Button\n        self.upload_button = customtkinter.CTkButton(\n            self.control_bar,\n            text=\"\ud83d\udcc1\",\n            width=30,\n            command=self.upload_file\n        )\n        self.upload_button.grid(row=0, column=3, padx=(10, 0), pady=0)\n\n        # Chat History Frame\n        self.chat_frame = customtkinter.CTkFrame(self.top_frame)\n        self.chat_frame.grid(row=1, column=0, padx=10, pady=(5, 10), sticky=\"nsew\")\n        self.chat_frame.grid_rowconfigure(0, weight=1)\n        self.chat_frame.grid_columnconfigure(0, weight=1)\n        \n        # Chat History Textbox\n        self.chat_history = customtkinter.CTkTextbox(\n            self.chat_frame,\n            wrap=tkinter.WORD,  # Wrap text at word boundaries\n            state=\"disabled\"    # Start as read-only\n        )\n        self.chat_history.grid(row=0, column=0, sticky=\"nsew\")\n        \n        # Configure tags for styling user/model messages\n        self.chat_history.tag_config(\"user\", foreground=\"blue\")\n        self.chat_history.tag_config(\"model\", foreground=\"#006400\")  # Dark Green\n        self.chat_history.tag_config(\"error\", foreground=\"red\")\n        self.chat_history.tag_config(\"system\", foreground=\"gray\")\n        self.chat_history.tag_config(\"file\", foreground=\"purple\")\n\n        # --- Bottom Frame (Input & Send Button) ---\n        self.input_frame = customtkinter.CTkFrame(self, corner_radius=0)\n        self.input_frame.grid(row=1, column=0, padx=10, pady=10, sticky=\"ew\")\n        self.input_frame.grid_columnconfigure(0, weight=1)  # Entry expands\n\n        # File indicator label\n        self.file_label = customtkinter.CTkLabel(\n            self.input_frame,\n            text=\"\",\n            text_color=\"purple\",\n        )\n        self.file_label.grid(row=0, column=0, padx=(0, 10), pady=(0, 5), sticky=\"w\")\n\n        # Prompt Entry Field\n        self.prompt_entry = customtkinter.CTkEntry(\n            self.input_frame,\n            placeholder_text=\"Enter your prompt here...\"\n        )\n        self.prompt_entry.grid(row=1, column=0, padx=(0, 10), pady=0, sticky=\"ew\")\n        self.prompt_entry.bind(\"<Return>\", self.send_prompt_event)  # Bind Enter key\n\n        # Send Button\n        self.send_button = customtkinter.CTkButton(\n            self.input_frame,\n            text=\"Send\",\n            command=self.send_prompt_event\n        )\n        self.send_button.grid(row=1, column=1, padx=0, pady=0)\n\n        # Cancel Button (hidden initially)\n        self.cancel_button = customtkinter.CTkButton(\n            self.input_frame,\n            text=\"Cancel\",\n            fg_color=\"darkred\",\n            command=self.cancel_generation,\n            state=\"disabled\"\n        )\n        # Not added to grid initially - will be shown during generation\n        \n        if config.LOGGING_ENABLED:\n            logger.debug(\"Main layout created\")\n\n    # --- Appearance Settings Dialog ---\n    def open_appearance_settings(self):\n        \"\"\"Open a dialog to configure application appearance.\"\"\"\n        settings_window = customtkinter.CTkToplevel(self)\n        settings_window.title(\"Appearance Settings\")\n        settings_window.geometry(\"400x300\")\n        settings_window.transient(self)  # Set to be on top of the main window\n        settings_window.grab_set()  # Make window modal\n        \n        # Appearance mode setting\n        appearance_frame = customtkinter.CTkFrame(settings_window)\n        appearance_frame.pack(fill=\"x\", padx=20, pady=10)\n        \n        appearance_label = customtkinter.CTkLabel(appearance_frame, text=\"Appearance Mode:\")\n        appearance_label.pack(side=\"left\", padx=10)\n        \n        # Variable to store the current appearance mode\n        appearance_var = tkinter.StringVar(value=customtkinter.get_appearance_mode())\n        \n        # Function to change appearance mode\n        def change_appearance_mode(new_mode):\n            customtkinter.set_appearance_mode(new_mode)\n            if config.LOGGING_ENABLED:\n                logger.info(f\"Appearance mode changed to {new_mode}\")\n        \n        # Appearance mode dropdown\n        appearance_dropdown = customtkinter.CTkOptionMenu(\n            appearance_frame,\n            values=[\"Light\", \"Dark\", \"System\"],\n            variable=appearance_var,\n            command=change_appearance_mode\n        )\n        appearance_dropdown.pack(side=\"left\", padx=10)\n        \n        # Color theme setting\n        theme_frame = customtkinter.CTkFrame(settings_window)\n        theme_frame.pack(fill=\"x\", padx=20, pady=10)\n        \n        theme_label = customtkinter.CTkLabel(theme_frame, text=\"Color Theme:\")\n        theme_label.pack(side=\"left\", padx=10)\n        \n        # Variable to store the current color theme\n        theme_var = tkinter.StringVar(value=customtkinter.get_default_color_theme())\n        \n        # Function to change color theme\n        def change_color_theme(new_theme):\n            customtkinter.set_default_color_theme(new_theme)\n            messagebox = customtkinter.CTkLabel(\n                settings_window,\n                text=\"Theme will be applied on restart\",\n                text_color=\"orange\"\n            )\n            messagebox.pack(pady=10)\n            if config.LOGGING_ENABLED:\n                logger.info(f\"Color theme changed to {new_theme}\")\n        \n        # Color theme dropdown\n        theme_dropdown = customtkinter.CTkOptionMenu(\n            theme_frame,\n            values=[\"blue\", \"green\", \"dark-blue\"],\n            variable=theme_var,\n            command=change_color_theme\n        )\n        theme_dropdown.pack(side=\"left\", padx=10)\n        \n        # Close button\n        close_button = customtkinter.CTkButton(\n            settings_window, \n            text=\"Close\", \n            command=settings_window.destroy\n        )\n        close_button.pack(pady=20)\n        \n        if config.LOGGING_ENABLED:\n            logger.debug(\"Appearance settings dialog opened\")\n\n    def open_model_browser(self):\n        \"\"\"Open the model browser dialog.\"\"\"\n        if config.LOGGING_ENABLED:\n            logger.info(\"Opening model browser\")\n            \n        browser = ModelBrowserDialog(self, self.model_manager)\n        \n    def on_model_browser_select(self, model_name):\n        \"\"\"\n        Handle model selection from the model browser.\n        \n        Args:\n            model_name (str): The selected model name\n        \"\"\"\n        if config.LOGGING_ENABLED:\n            logger.info(f\"Model selected from browser: {model_name}\")\n            \n        # Set the selected model\n        self.selected_model.set(model_name)\n        \n        # Update the UI to reflect the selection\n        self.add_message(\"System\", f\"Model selected: {model_name}\\n\")\n\n    # --- Model Settings Dialog ---\n    def open_model_settings(self):\n        \"\"\"Open a dialog to configure model parameters.\"\"\"\n        settings_window = customtkinter.CTkToplevel(self)\n        settings_window.title(\"Model Parameters\")\n        settings_window.geometry(\"500x550\")\n        settings_window.transient(self)  # Set to be on top of the main window\n        settings_window.grab_set()  # Make window modal\n        \n        # Create a scrollable frame for all settings\n        scrollable_frame = customtkinter.CTkScrollableFrame(settings_window)\n        scrollable_frame.pack(fill=\"both\", expand=True, padx=20, pady=20)\n        \n        # Title label\n        title_label = customtkinter.CTkLabel(\n            scrollable_frame, \n            text=\"Model Parameter Settings\",\n            font=customtkinter.CTkFont(size=16, weight=\"bold\")\n        )\n        title_label.pack(pady=(0, 20))\n        \n        # Temperature setting\n        self.create_slider_setting(\n            scrollable_frame, \n            \"Temperature:\", \n            \"Controls randomness (higher = more creative, lower = more deterministic)\",\n            self.temperature, \n            0.0, \n            2.0, \n            0.1\n        )\n        \n        # Max tokens setting\n        self.create_slider_setting(\n            scrollable_frame, \n            \"Max Tokens:\", \n            \"Maximum number of tokens to generate\",\n            self.max_tokens, \n            256, \n            8192, \n            256,\n            is_int=True\n        )\n        \n        # Context length setting\n        self.create_slider_setting(\n            scrollable_frame, \n            \"Context Length:\", \n            \"Maximum context length for the model\",\n            self.context_length, \n            1024, \n            8192, \n            1024,\n            is_int=True\n        )\n        \n        # Output token length setting\n        self.create_slider_setting(\n            scrollable_frame, \n            \"Default Output Length:\", \n            \"Default length of generated responses\",\n            self.output_token_length, \n            50, \n            1000, \n            50,\n            is_int=True\n        )\n        \n        # Top P setting\n        self.create_slider_setting(\n            scrollable_frame, \n            \"Top P:\", \n            \"Nucleus sampling parameter (lower = more focused)\",\n            self.top_p, \n            0.0, \n            1.0, \n            0.05\n        )\n        \n        # Frequency penalty setting\n        self.create_slider_setting(\n            scrollable_frame, \n            \"Frequency Penalty:\", \n            \"Penalty for frequent tokens (higher = less repetition)\",\n            self.frequency_penalty, \n            0.0, \n            2.0, \n            0.1\n        )\n        \n        # Presence penalty setting\n        self.create_slider_setting(\n            scrollable_frame, \n            \"Presence Penalty:\", \n            \"Penalty for new tokens (higher = more topic changes)\",\n            self.presence_penalty, \n            0.0, \n            2.0, \n            0.1\n        )\n        \n        # Buttons frame\n        buttons_frame = customtkinter.CTkFrame(settings_window)\n        buttons_frame.pack(fill=\"x\", padx=20, pady=20)\n        \n        # Reset button\n        reset_button = customtkinter.CTkButton(\n            buttons_frame, \n            text=\"Reset to Defaults\", \n            command=self.reset_model_settings\n        )\n        reset_button.pack(side=\"left\", padx=10)\n        \n        # Apply button\n        apply_button = customtkinter.CTkButton(\n            buttons_frame, \n            text=\"Apply\", \n            command=settings_window.destroy\n        )\n        apply_button.pack(side=\"right\", padx=10)\n        \n        if config.LOGGING_ENABLED:\n            logger.debug(\"Model settings dialog opened\")\n    \n    def create_slider_setting(self, parent, label_text, help_text, variable, min_val, max_val, step, is_int=False):\n        \"\"\"Helper method to create a slider setting with label and value display.\"\"\"\n        # Container frame\n        frame = customtkinter.CTkFrame(parent)\n        frame.pack(fill=\"x\", padx=5, pady=10)\n        \n        # Label frame\n        label_frame = customtkinter.CTkFrame(frame)\n        label_frame.pack(fill=\"x\", pady=5)\n        \n        # Parameter label\n        label = customtkinter.CTkLabel(label_frame, text=label_text, anchor=\"w\")\n        label.pack(side=\"left\", padx=10)\n        \n        # Value display\n        if is_int:\n            value_text = str(variable.get())\n        else:\n            value_text = f\"{variable.get():.2f}\"\n            \n        value_label = customtkinter.CTkLabel(label_frame, text=value_text)\n        value_label.pack(side=\"right\", padx=10)\n        \n        # Help text\n        help_label = customtkinter.CTkLabel(\n            frame, \n            text=help_text, \n            font=customtkinter.CTkFont(size=12),\n            text_color=\"gray\"\n        )\n        help_label.pack(fill=\"x\", padx=10, pady=(0, 5))\n        \n        # Slider\n        slider = customtkinter.CTkSlider(\n            frame, \n            from_=min_val, \n            to=max_val, \n            variable=variable,\n            width=450\n        )\n        slider.pack(padx=10, pady=5)\n        \n        # Update value label when slider changes\n        def update_value_label(value):\n            if is_int:\n                value_int = int(float(value))\n                variable.set(value_int)\n                value_label.configure(text=str(value_int))\n            else:\n                value_label.configure(text=f\"{float(value):.2f}\")\n        \n        slider.configure(command=update_value_label)\n        \n        return frame\n    \n    def reset_model_settings(self):\n        \"\"\"Reset all model parameters to their default values.\"\"\"\n        self.temperature.set(config.DEFAULT_TEMPERATURE)\n        self.max_tokens.set(config.DEFAULT_MAX_TOKENS)\n        self.context_length.set(config.DEFAULT_CONTEXT_LIMIT)\n        self.output_token_length.set(config.DEFAULT_OUTPUT_TOKEN_LENGTH)\n        self.top_p.set(config.DEFAULT_ADDITIONAL_SETTINGS[\"top_p\"])\n        self.frequency_penalty.set(config.DEFAULT_ADDITIONAL_SETTINGS[\"frequency_penalty\"])\n        self.presence_penalty.set(config.DEFAULT_ADDITIONAL_SETTINGS[\"presence_penalty\"])\n        \n        if config.LOGGING_ENABLED:\n            logger.info(\"Model settings reset to defaults\")\n            \n        # Show confirmation\n        messagebox = customtkinter.CTkLabel(\n            self,\n            text=\"Settings reset to defaults\",\n            text_color=\"green\"\n        )\n        messagebox.place(relx=0.5, rely=0.9, anchor=\"center\")\n        \n        # Remove message after a delay\n        self.after(2000, lambda: messagebox.destroy())\n\n    # --- File Upload Handling ---\n    def upload_file(self):\n        \"\"\"Open a file dialog to select a file for upload.\"\"\"\n        file_path = filedialog.askopenfilename(\n            title=\"Select File\",\n            filetypes=[\n                (\"Text files\", \"*.txt\"),\n                (\"Markdown files\", \"*.md\"),\n                (\"JSON files\", \"*.json\"),\n                (\"CSV files\", \"*.csv\"),\n                (\"Python files\", \"*.py\"),\n                (\"All files\", \"*.*\")\n            ]\n        )\n        \n        if not file_path:\n            return  # User canceled\n        \n        # Get the filename\n        filename = os.path.basename(file_path)\n        \n        # Copy the file to the uploads directory\n        destination = os.path.join(config.UPLOAD_DIR, filename)\n        \n        try:\n            # Read the file content\n            with open(file_path, 'rb') as source_file:\n                file_content = source_file.read()\n                \n            # Save to destination\n            with open(destination, 'wb') as dest_file:\n                dest_file.write(file_content)\n            \n            # Update the UI to show the selected file\n            self.selected_file = destination\n            self.file_label.configure(text=f\"Selected file: {filename}\")\n            \n            # Add message to chat\n            self.add_message(\"System\", f\"File uploaded: {filename}\\n\", tag=\"file\")\n            \n            if config.LOGGING_ENABLED:\n                logger.info(f\"File uploaded: {filename}\")\n        \n        except Exception as e:\n            error_message = f\"Error uploading file: {str(e)}\\n\"\n            self.add_message(\"System\", error_message, tag=\"error\")\n            \n            if config.LOGGING_ENABLED:\n                logger.error(f\"File upload error: {str(e)}\")\n\n    # --- Conversation Management ---\n    def new_conversation(self):\n        \"\"\"Start a new conversation, saving the current one to history.\"\"\"\n        if self.current_conversation:\n            self.conversations.append(self.current_conversation)\n            self.current_conversation = []\n            \n            # Clear the chat history\n            self.chat_history.configure(state=\"normal\")\n            self.chat_history.delete(\"1.0\", tkinter.END)\n            self.chat_history.configure(state=\"disabled\")\n            \n            # Clear selected file\n            self.selected_file = None\n            self.file_label.configure(text=\"\")\n            \n            self.add_message(\"System\", \"Started a new conversation.\\n\")\n            \n            if config.LOGGING_ENABLED:\n                logger.info(\"New conversation started\")\n\n    def save_conversation(self):\n        \"\"\"Save the current conversation to a file.\"\"\"\n        if not self.current_conversation:\n            self.add_message(\"System\", \"No conversation to save.\\n\", tag=\"error\")\n            return\n            \n        # Ask user for save location\n        file_path = filedialog.asksaveasfilename(\n            defaultextension=\".txt\",\n            filetypes=[(\"Text files\", \"*.txt\"), (\"Markdown files\", \"*.md\"), (\"All files\", \"*.*\")],\n            title=\"Save Conversation\"\n        )\n        \n        if not file_path:\n            return  # User canceled\n            \n        try:\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(f\"# Ollama Conversation - {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n                \n                # Write model information if available\n                if hasattr(self, 'selected_model') and self.selected_model.get() not in [\"Select Model\", \"Fetching models...\"]:\n                    f.write(f\"Model: {self.selected_model.get()}\\n\\n\")\n                \n                # Write conversation\n                for message in self.current_conversation:\n                    if message[\"sender\"] == \"User\":\n                        f.write(f\"## User\\n\\n{message['content']}\\n\\n\")\n                    elif message[\"sender\"] == \"Model\":\n                        f.write(f\"## Model\\n\\n{message['content']}\\n\\n\")\n                        \n            self.add_message(\"System\", f\"Conversation saved to {file_path}\\n\")\n            \n            if config.LOGGING_ENABLED:\n                logger.info(f\"Conversation saved to {file_path}\")\n                \n        except Exception as e:\n            self.add_message(\"System\", f\"Error saving conversation: {e}\\n\", tag=\"error\")\n            \n            if config.LOGGING_ENABLED:\n                logger.error(f\"Error saving conversation: {e}\")\n\n    def show_about(self):\n        \"\"\"Show information about the application.\"\"\"\n        about_window = customtkinter.CTkToplevel(self)\n        about_window.title(\"About Ollama Desktop GUI\")\n        about_window.geometry(\"400x300\")\n        about_window.transient(self)\n        \n        title_label = customtkinter.CTkLabel(\n            about_window, \n            text=\"Ollama Desktop GUI\",\n            font=customtkinter.CTkFont(size=20, weight=\"bold\")\n        )\n        title_label.pack(pady=20)\n        \n        info_text = (\n            \"A desktop GUI for Ollama local LLM models.\\n\\n\"\n            \"Features:\\n\"\n            \"- Chat with multiple Ollama models\\n\"\n            \"- Adjust model parameters\\n\"\n            \"- Save conversations\\n\"\n            \"- Upload reference files\\n\"\n            \"- Cancel running generations\\n\\n\"\n            \"Created with Python and CustomTkinter\"\n        )\n        \n        info_label = customtkinter.CTkLabel(\n            about_window, \n            text=info_text,\n            justify=\"left\"\n        )\n        info_label.pack(padx=20, pady=10)\n        \n        ok_button = customtkinter.CTkButton(\n            about_window, \n            text=\"OK\", \n            command=about_window.destroy\n        )\n        ok_button.pack(pady=20)\n        \n        if config.LOGGING_ENABLED:\n            logger.debug(\"About dialog opened\")\n\n    # --- Model Handling ---\n    def fetch_models_async(self):\n        \"\"\"Fetches models in a separate thread to avoid blocking the GUI.\"\"\"\n        self.add_message(\"System\", \"Fetching available Ollama models...\\n\")\n        threading.Thread(target=self._fetch_models_worker, daemon=True).start()\n\n    def _fetch_models_worker(self):\n        \"\"\"Worker function to fetch models from the Ollama API.\"\"\"\n        try:\n            response = requests.get(f\"{config.OLLAMA_BASE_URL}/api/tags\", timeout=10)\n            response.raise_for_status()  # Raise an exception for bad status codes\n            data = response.json()\n            self.models = sorted([model['name'] for model in data.get('models', [])])\n\n            if self.models:\n                # Schedule GUI update in the main thread\n                self.after(0, self.update_model_menu, self.models)\n                self.add_message(\"System\", f\"Found models: {', '.join(self.models)}\\n\")\n                \n                if config.LOGGING_ENABLED:\n                    logger.info(f\"Found {len(self.models)} models\")\n            else:\n                self.after(0, self.update_model_menu, [\"No models found\"])\n                self.add_message(\"System\", \"No Ollama models found. Is Ollama running and have you pulled models (e.g., `ollama pull llama3`)?\\n\", tag=\"error\")\n                \n                if config.LOGGING_ENABLED:\n                    logger.warning(\"No Ollama models found\")\n\n        except requests.exceptions.RequestException as e:\n            error_message = f\"Error fetching models: {e}\\nIs Ollama running at {config.OLLAMA_BASE_URL}?\\n\"\n            self.add_message(\"System\", error_message, tag=\"error\")\n            # Schedule GUI update in the main thread\n            self.after(0, self.update_model_menu, [\"Error fetching\"])\n            \n            if config.LOGGING_ENABLED:\n                logger.error(f\"Error fetching models: {e}\")\n                \n        except json.JSONDecodeError:\n            error_message = \"Error decoding response from Ollama API.\\n\"\n            self.add_message(\"System\", error_message, tag=\"error\")\n            self.after(0, self.update_model_menu, [\"API Error\"])\n            \n            if config.LOGGING_ENABLED:\n                logger.error(\"Error decoding response from Ollama API\")\n\n    def update_model_menu(self, models_list):\n        \"\"\"Updates the model dropdown menu (runs in the main thread).\"\"\"\n        if models_list:\n            self.model_menu.configure(values=models_list)\n            if models_list[0] not in [\"Error fetching\", \"No models found\", \"API Error\"]:\n                self.selected_model.set(models_list[0])  # Select the first model by default\n                self.model_menu.configure(state=\"normal\")\n                self.prompt_entry.configure(state=\"normal\")\n                self.send_button.configure(state=\"normal\")\n            else:\n                self.selected_model.set(models_list[0])\n                self.model_menu.configure(state=\"disabled\")\n                self.prompt_entry.configure(state=\"disabled\")\n                self.send_button.configure(state=\"disabled\")\n        else:\n            self.model_menu.configure(values=[\"No models available\"], state=\"disabled\")\n            self.selected_model.set(\"No models available\")\n            self.prompt_entry.configure(state=\"disabled\")\n            self.send_button.configure(state=\"disabled\")\n\n    def on_model_select(self, selected):\n        \"\"\"Callback when a model is selected.\"\"\"\n        self.add_message(\"System\", f\"Model selected: {selected}\\n\")\n        \n        if config.LOGGING_ENABLED:\n            logger.info(f\"Model selected: {selected}\")\n\n    # --- Chat Interaction ---\n    def add_message(self, sender, message, tag=None):\n        \"\"\"\n        Adds a message to the chat history (runs in the main thread).\n        \n        Args:\n            sender (str): The sender of the message ('User', 'Model', or 'System')\n            message (str): The message content\n            tag (str, optional): Styling tag to apply. Defaults to None.\n        \"\"\"\n        # Store message in conversation history\n        if sender in [\"User\", \"Model\"]:\n            self.current_conversation.append({\n                \"sender\": sender,\n                \"content\": message,\n                \"timestamp\": datetime.datetime.now().isoformat()\n            })\n        \n        # Update chat display\n        self.chat_history.configure(state=\"normal\")  # Enable editing\n        if sender == \"User\":\n            self.chat_history.insert(tkinter.END, f\"You: {message}\\n\\n\", \"user\")\n        elif sender == \"Model\":\n            # Append model responses without extra labels if streaming\n            self.chat_history.insert(tkinter.END, message, \"model\")\n        elif sender == \"System\":\n            self.chat_history.insert(tkinter.END, f\"[System] {message}\", tag or \"system\")\n        else:  # Error case from Ollama response etc.\n            self.chat_history.insert(tkinter.END, f\"[Error] {message}\\n\", \"error\")\n\n        self.chat_history.see(tkinter.END)  # Scroll to the bottom\n        self.chat_history.configure(state=\"disabled\")  # Disable editing\n\n    def add_model_response_chunk(self, chunk):\n        \"\"\"\n        Appends a chunk of the model's streaming response.\n        \n        Args:\n            chunk (str): Text chunk from the model's response\n        \"\"\"\n        self.chat_history.configure(state=\"normal\")  # Enable editing\n        self.chat_history.insert(tkinter.END, chunk, \"model\")\n        self.chat_history.see(tkinter.END)  # Scroll to the bottom\n        self.chat_history.configure(state=\"disabled\")  # Disable editing\n\n    def send_prompt_event(self, event=None):\n        \"\"\"\n        Handles sending the prompt when the button is clicked or Enter is pressed.\n        \n        Args:\n            event: The event that triggered this function (optional)\n        \"\"\"\n        if self.is_generating:\n            return  # Don't send if already generating\n\n        prompt = self.prompt_entry.get().strip()\n        model = self.selected_model.get()\n\n        if not prompt:\n            self.add_message(\"System\", \"Please enter a prompt.\\n\", tag=\"error\")\n            return\n        if model in [\"Select Model\", \"Fetching models...\", \"No models found\", \"Error fetching\", \"API Error\", \"No models available\"]:\n            self.add_message(\"System\", \"Please select a valid model first.\\n\", tag=\"error\")\n            return\n\n        # Display user prompt\n        self.add_message(\"User\", prompt)\n        self.prompt_entry.delete(0, tkinter.END)  # Clear input field\n\n        # Disable input elements while generating and show cancel button\n        self.set_generating_state(True)\n\n        # If a file is selected, include it in the context\n        file_content = None\n        if self.selected_file and os.path.exists(self.selected_file):\n            try:\n                with open(self.selected_file, 'r', encoding='utf-8') as f:\n                    file_content = f.read()\n                \n                if config.LOGGING_ENABLED:\n                    logger.info(f\"Including file in context: {os.path.basename(self.selected_file)}\")\n            except Exception as e:\n                self.add_message(\"System\", f\"Error reading file: {str(e)}\\n\", tag=\"error\")\n                \n                if config.LOGGING_ENABLED:\n                    logger.error(f\"Error reading file: {str(e)}\")\n\n        # Start generation in a background thread\n        threading.Thread(\n            target=self._generate_worker,\n            args=(prompt, model, file_content),\n            daemon=True\n        ).start()\n\n    def cancel_generation(self):\n        \"\"\"Cancels the current model generation if one is running.\"\"\"\n        if self.is_generating and self.active_request:\n            try:\n                # Close the active request connection\n                self.active_request.close()\n                \n                # Indicate that cancellation is in progress\n                self.cancel_button.configure(text=\"Canceling...\", state=\"disabled\")\n                \n                # Message will be added when the generation thread finishes\n                if config.LOGGING_ENABLED:\n                    logger.info(\"Generation canceled by user\")\n                    \n            except Exception as e:\n                self.add_message(\"System\", f\"Error canceling generation: {e}\\n\", tag=\"error\")\n                \n                if config.LOGGING_ENABLED:\n                    logger.error(f\"Error canceling generation: {e}\")\n\n    def _generate_worker(self, prompt, model, file_content=None):\n        \"\"\"\n        Worker function to send prompt to Ollama and handle streaming response.\n        \n        Args:\n            prompt (str): The user's prompt text\n            model (str): The selected model name\n            file_content (str, optional): Content of the selected file\n        \"\"\"\n        url = f\"{config.OLLAMA_BASE_URL}/api/generate\"\n        \n        # Prepare the context with file content if available\n        full_prompt = prompt\n        if file_content:\n            full_prompt = f\"I'm providing you with the following file content for reference:\\n\\n```\\n{file_content}\\n```\\n\\nNow, here's my question/request:\\n\\n{prompt}\"\n        \n        # Prepare the payload with all model parameters\n        payload = {\n            \"model\": model,\n            \"prompt\": full_prompt,\n            \"stream\": True,  # Enable streaming\n            \"options\": {\n                \"temperature\": self.temperature.get(),\n                \"num_predict\": self.max_tokens.get(),\n                \"top_p\": self.top_p.get(),\n                \"frequency_penalty\": self.frequency_penalty.get(),\n                \"presence_penalty\": self.presence_penalty.get()\n            }\n        }\n\n        response_text = \"\"  # Collect the full response\n        first_chunk = True\n        canceled = False\n        \n        if config.LOGGING_ENABLED:\n            logger.info(f\"Generating response with model {model}\")\n            logger.debug(f\"Parameters: {payload['options']}\")\n        \n        try:\n            # Store reference to the request for potential cancellation\n            with requests.post(url, json=payload, stream=True, timeout=120) as response:\n                self.active_request = response\n                response.raise_for_status()  # Check for HTTP errors like 404 or 500\n\n                # Add the initial \"Model: \" label once\n                self.response_queue.put((\"label\", \"Model: \"))\n\n                for line in response.iter_lines():\n                    # Check if response is closed (due to cancellation)\n                    if getattr(response, 'closed', False):\n                        canceled = True\n                        break\n                        \n                    if line:\n                        try:\n                            # Each line is a JSON object\n                            data = json.loads(line.decode('utf-8'))\n                            response_chunk = data.get(\"response\", \"\")\n                            is_done = data.get(\"done\", False)\n                            \n                            # Add to complete response\n                            response_text += response_chunk\n\n                            # Put the received chunk into the queue for the main thread\n                            self.response_queue.put((\"chunk\", response_chunk))\n\n                            if is_done:\n                                self.response_queue.put((\"done\", \"\\n\\n\"))  # Signal completion with newline\n                                \n                                if config.LOGGING_ENABLED:\n                                    logger.info(\"Generation completed successfully\")\n                                    \n                                break  # Exit loop once done\n\n                        except json.JSONDecodeError:\n                            self.response_queue.put((\"error\", f\"Failed to decode JSON line: {line}\\n\"))\n                            \n                            if config.LOGGING_ENABLED:\n                                logger.error(f\"Failed to decode JSON line: {line}\")\n                                \n                            break  # Stop processing on decode error\n                        except Exception as e:  # Catch other potential errors during processing\n                            self.response_queue.put((\"error\", f\"Error processing stream: {e}\\n\"))\n                            \n                            if config.LOGGING_ENABLED:\n                                logger.error(f\"Error processing stream: {e}\")\n                                \n                            break\n\n        except requests.exceptions.ConnectionError:\n            self.response_queue.put((\"error\", f\"Connection Error: Could not connect to Ollama at {config.OLLAMA_BASE_URL}. Is it running?\\n\"))\n            \n            if config.LOGGING_ENABLED:\n                logger.error(f\"Connection Error: Could not connect to Ollama at {config.OLLAMA_BASE_URL}\")\n                \n        except requests.exceptions.Timeout:\n            self.response_queue.put((\"error\", \"Request timed out. The model might be taking too long.\\n\"))\n            \n            if config.LOGGING_ENABLED:\n                logger.error(\"Request timed out\")\n                \n        except requests.exceptions.RequestException as e:\n            self.response_queue.put((\"error\", f\"API Request Error: {e}\\n\"))\n            \n            if config.LOGGING_ENABLED:\n                logger.error(f\"API Request Error: {e}\")\n                \n        finally:\n            # Clean up\n            self.active_request = None\n            \n            # Add message about cancellation if needed\n            if canceled:\n                self.response_queue.put((\"error\", \"Generation was canceled.\\n\"))\n                \n                if config.LOGGING_ENABLED:\n                    logger.info(\"Generation was canceled\")\n            \n            # Update conversation history with the complete response if it was generated\n            if response_text and not canceled:\n                # The first message is already added with the label\n                # This full response is stored in the conversation history\n                self.current_conversation[-1][\"content\"] = response_text\n            \n            # Always signal the main thread that generation is finished, even on error\n            self.response_queue.put((\"finished\", None))\n\n    def process_response_queue(self):\n        \"\"\"Processes items from the response queue in the main GUI thread.\"\"\"\n        try:\n            while True:  # Process all available messages in the queue\n                message_type, data = self.response_queue.get_nowait()\n\n                if message_type == \"label\":\n                    self.add_message(\"Model\", data)  # Adds \"Model: \" prefix\n                elif message_type == \"chunk\":\n                    self.add_model_response_chunk(data)\n                elif message_type == \"done\":\n                    self.add_model_response_chunk(data)  # Add final newline\n                    # Don't set generating state to false here, wait for \"finished\"\n                elif message_type == \"error\":\n                    self.add_message(\"Error\", data)\n                    # Still wait for \"finished\" to re-enable UI in case of stream errors\n                elif message_type == \"finished\":\n                    self.set_generating_state(False)  # Re-enable UI now\n\n                self.response_queue.task_done()  # Mark task as done\n\n        except queue.Empty:  # No more items in the queue right now\n            pass\n        finally:\n            # Schedule this method to run again after a short delay\n            self.after(100, self.process_response_queue)\n\n    def set_generating_state(self, is_generating):\n        \"\"\"\n        Enable/disable UI elements based on generation state.\n        \n        Args:\n            is_generating (bool): Whether the model is currently generating a response\n        \"\"\"\n        self.is_generating = is_generating\n        \n        # Show/hide cancel button and adjust input UI\n        if is_generating:\n            # Disable input controls\n            self.prompt_entry.configure(state=\"disabled\")\n            self.send_button.configure(text=\"Generating...\", state=\"disabled\")\n            self.model_menu.configure(state=\"disabled\")\n            self.upload_button.configure(state=\"disabled\")\n            \n            # Show cancel button\n            self.send_button.grid_remove()  # Hide send button\n            self.cancel_button.configure(state=\"normal\")\n            self.cancel_button.grid(row=1, column=1, padx=0, pady=0)  # Show cancel button\n            \n            if config.LOGGING_ENABLED:\n                logger.debug(\"UI set to generating state\")\n                \n        else:\n            # Re-enable input controls\n            self.prompt_entry.configure(state=\"normal\")\n            self.send_button.configure(text=\"Send\", state=\"normal\")\n            self.upload_button.configure(state=\"normal\")\n            \n            # Hide cancel button\n            self.cancel_button.grid_remove()  # Hide cancel button\n            self.send_button.grid(row=1, column=1, padx=0, pady=0)  # Show send button\n            \n            # Only re-enable model menu if models were successfully loaded\n            if self.models and self.selected_model.get() not in [\"Error fetching\", \"No models found\"]:\n                self.model_menu.configure(state=\"normal\")\n                \n            # Focus back on the entry field\n            self.prompt_entry.focus()\n            \n            if config.LOGGING_ENABLED:\n                logger.debug(\"UI set to idle state\")\n\n# --- Run the Application ---\nif __name__ == \"__main__\":\n    app = OllamaGUI()\n    app.mainloop()",
  "D:\\AI\\IrintAI Assistant\\core\\config_manager.py": "\"\"\"\nConfiguration management for the Irintai Assistant\n\"\"\"\nimport os\nimport json\nimport threading\nfrom typing import Any, Dict, Optional, List, Tuple\n\nclass ConfigManager:\n    \"\"\"Manages application configuration and settings\"\"\"\n    \n    def __init__(self, path: str = \"data/config.json\", auto_save: bool = True):\n        \"\"\"\n        Initialize the configuration manager\n        \n        Args:\n            path: Path to the configuration file\n            auto_save: Whether to automatically save changes\n        \"\"\"\n        self.config_path = path\n        self.auto_save = auto_save\n        self.config = {}\n        self.lock = threading.RLock()  # Reentrant lock for thread safety\n        \n        # Create parent directory if it doesn't exist\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        \n        # Load configuration\n        self.load_config()\n        \n    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a configuration value\n        \n        Args:\n            key: Configuration key\n            default: Default value if key doesn't exist\n            \n        Returns:\n            Configuration value\n        \"\"\"\n        with self.lock:\n            return self.config.get(key, default)\n        \n    def set(self, key: str, value: Any) -> None:\n        \"\"\"\n        Set a configuration value\n        \n        Args:\n            key: Configuration key\n            value: Configuration value\n        \"\"\"\n        with self.lock:\n            self.config[key] = value\n            \n            # Auto-save if enabled\n            if self.auto_save:\n                self.save_config()\n        \n    def load_config(self) -> bool:\n        \"\"\"\n        Load configuration from file\n        \n        Returns:\n            True if configuration loaded successfully, False otherwise\n        \"\"\"\n        with self.lock:\n            if not os.path.exists(self.config_path):\n                return False\n            \n            try:\n                with open(self.config_path, 'r', encoding='utf-8') as f:\n                    self.config = json.load(f)\n                return True\n            except Exception:\n                return False\n            \n    def save_config(self) -> bool:\n        \"\"\"\n        Save configuration to file\n        \n        Returns:\n            True if configuration saved successfully, False otherwise\n        \"\"\"\n        with self.lock:\n            try:\n                with open(self.config_path, 'w', encoding='utf-8') as f:\n                    json.dump(self.config, f, indent=2)\n                return True\n            except Exception:\n                return False\n            \n    def reset_to_defaults(self) -> None:\n        \"\"\"Reset configuration to default values\"\"\"\n        self.config = {}\n        \n    def get_all(self) -> Dict[str, Any]:\n        \"\"\"\n        Get all configuration values\n        \n        Returns:\n            Dictionary of all configuration values\n        \"\"\"\n        with self.lock:\n            return self.config.copy()\n        \n    def update(self, new_config: Dict[str, Any]) -> None:\n        \"\"\"\n        Update multiple configuration values\n        \n        Args:\n            new_config: Dictionary of configuration values to update\n        \"\"\"\n        with self.lock:\n            self.config.update(new_config)\n            \n            # Auto-save if enabled\n            if self.auto_save:\n                self.save_config()\n        \n    def set_system_environment(self, model_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Set system environment variables for model path\n        \n        Args:\n            model_path: Optional model path to set, uses the configured path if not provided\n            \n        Returns:\n            True if environment variables set successfully, False otherwise\n        \"\"\"\n        try:\n            # Use provided path or get from config\n            path = model_path or self.get(\"model_path\")\n            \n            # Ensure the parent directory path is extracted correctly\n            ollama_home = os.path.dirname(path)\n            \n            # Set environment variables\n            os.environ[\"OLLAMA_HOME\"] = ollama_home\n            os.environ[\"OLLAMA_MODELS\"] = path\n            \n            return True\n        except Exception:\n            return False\n    \n    def set_system_path_var(self, model_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Set system path environment variables using system commands (requires admin privileges)\n        \n        Args:\n            model_path: Optional model path to set, uses the configured path if not provided\n            \n        Returns:\n            True if system variables set successfully, False otherwise\n        \"\"\"\n        import subprocess\n        \n        # Use provided path or get from config\n        path = model_path or self.get(\"model_path\")\n        \n        try:\n            # For Windows, use setx command which requires admin privileges\n            if os.name == 'nt':\n                cmd = f'setx OLLAMA_MODELS \"{path}\" /M'\n                \n                # Run the command (requires elevation)\n                process = subprocess.run(\n                    cmd,\n                    capture_output=True, \n                    text=True,\n                    shell=True  # Required for setx\n                )\n                \n                if process.returncode == 0:\n                    return True\n                else:\n                    return False\n            else:\n                # For Unix-like systems, we would need to modify .bashrc, .profile, etc.\n                # This is more complex and would require different handling\n                return False\n        except Exception:\n            return False\n        \n    def export_config(self, export_path: str) -> bool:\n        \"\"\"\n        Export configuration to another file\n        \n        Args:\n            export_path: Path to export configuration to\n            \n        Returns:\n            True if configuration exported successfully, False otherwise\n        \"\"\"\n        try:\n            # Create directory if it doesn't exist\n            os.makedirs(os.path.dirname(export_path), exist_ok=True)\n            \n            # Export configuration\n            with open(export_path, 'w', encoding='utf-8') as f:\n                json.dump(self.config, f, indent=2)\n                \n            return True\n        except Exception:\n            return False\n        \n    def import_config(self, import_path: str, merge: bool = False) -> bool:\n        \"\"\"\n        Import configuration from another file\n        \n        Args:\n            import_path: Path to import configuration from\n            merge: Whether to merge with existing configuration or replace entirely\n            \n        Returns:\n            True if configuration imported successfully, False otherwise\n        \"\"\"\n        if not os.path.exists(import_path):\n            return False\n            \n        try:\n            # Load configuration from file\n            with open(import_path, 'r', encoding='utf-8') as f:\n                import_config = json.load(f)\n                \n            # Validate imported configuration\n            if not isinstance(import_config, dict):\n                return False\n                \n            # Replace or merge configuration\n            if merge:\n                self.config.update(import_config)\n            else:\n                self.config = import_config\n                \n            self.save_config()  # Save the imported configuration\n            return True\n        except Exception:\n            return False\n        \n    def get_nested(self, path: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a nested configuration value using dot notation\n        \n        Args:\n            path: Path to configuration value (e.g., 'database.host')\n            default: Default value if path doesn't exist\n            \n        Returns:\n            Configuration value\n        \"\"\"\n        parts = path.split('.')\n        current = self.config\n        \n        try:\n            for part in parts:\n                current = current[part]\n            return current\n        except (KeyError, TypeError):\n            return default\n        \n    def set_nested(self, path: str, value: Any) -> bool:\n        \"\"\"\n        Set a nested configuration value using dot notation\n        \n        Args:\n            path: Path to configuration value (e.g., 'database.host')\n            value: Value to set\n            \n        Returns:\n            True if value was set successfully, False otherwise\n        \"\"\"\n        parts = path.split('.')\n        current = self.config\n        \n        try:\n            # Navigate to the parent of the target key\n            for part in parts[:-1]:\n                if part not in current or not isinstance(current[part], dict):\n                    current[part] = {}\n                current = current[part]\n                \n            # Set the value\n            current[parts[-1]] = value\n            return True\n        except Exception:\n            return False\n        \n    def validate_config(self, schema: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"\n        Validate configuration against a schema\n        \n        Args:\n            schema: Dictionary defining validation rules (optional)\n            \n        Returns:\n            Dictionary of validation errors (empty if valid)\n        \"\"\"\n        errors = {}\n        \n        # Default schema based on expected types/ranges\n        default_schema = {\n            \"temperature\": {\"type\": float, \"range\": [0.0, 2.0]},\n            \"use_8bit\": {\"type\": bool},\n            \"inference_mode\": {\"type\": str, \"values\": [\"CPU\", \"GPU\", \"MPS\"]},\n            \"memory_mode\": {\"type\": str, \"values\": [\"Off\", \"Basic\", \"Advanced\"]},\n            \"nsfw_enabled\": {\"type\": bool},\n            \"model_path\": {\"type\": str}\n        }\n        \n        # Use provided schema or default\n        validation_schema = schema or default_schema\n        \n        # Check each field against the schema\n        for key, rules in validation_schema.items():\n            if key in self.config:\n                value = self.config[key]\n                \n                # Type checking\n                if \"type\" in rules and not isinstance(value, rules[\"type\"]):\n                    errors[key] = f\"Invalid type: expected {rules['type'].__name__}, got {type(value).__name__}\"\n                    continue\n                    \n                # Range checking for numeric values\n                if \"range\" in rules and isinstance(value, (int, float)):\n                    min_val, max_val = rules[\"range\"]\n                    if value < min_val or value > max_val:\n                        errors[key] = f\"Value out of range: {value} (range: {min_val}-{max_val})\"\n                        \n                # Value checking for strings/enums\n                if \"values\" in rules and isinstance(value, str):\n                    if value not in rules[\"values\"]:\n                        errors[key] = f\"Invalid value: {value} (valid values: {', '.join(rules['values'])})\"\n        \n        return errors\n    \n    def set_secure(self, key: str, value: Any) -> None:\n        \"\"\"\n        Set a secure configuration value (will be masked in logs)\n        \n        Args:\n            key: Configuration key\n            value: Configuration value\n        \"\"\"\n        self.config[key] = value\n        \n        # Add to secure keys set if not already\n        if not hasattr(self, '_secure_keys'):\n            self._secure_keys = set()\n        \n        self._secure_keys.add(key)\n        \n    def get_secure(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a secure configuration value\n        \n        Args:\n            key: Configuration key\n            default: Default value if key doesn't exist\n            \n        Returns:\n            Configuration value\n        \"\"\"\n        return self.config.get(key, default)\n        \n    def get_all_secure(self) -> Dict[str, str]:\n        \"\"\"\n        Get a masked representation of all configuration values (for display)\n        \n        Returns:\n            Dictionary with sensitive values masked\n        \"\"\"\n        if not hasattr(self, '_secure_keys'):\n            self._secure_keys = set()\n            \n        # Create a copy with masked secure values\n        display_config = {}\n        \n        for key, value in self.config.items():\n            if key in self._secure_keys:\n                display_config[key] = \"********\"\n            else:\n                display_config[key] = value\n                \n        return display_config\n    \n    def get_category(self, category: str) -> Dict[str, Any]:\n        \"\"\"\n        Get all configuration values for a specific category\n        \n        Args:\n            category: Configuration category prefix (e.g., 'ui', 'model')\n            \n        Returns:\n            Dictionary of configuration values in the category\n        \"\"\"\n        prefix = category + \".\"\n        result = {}\n        \n        for key, value in self.config.items():\n            if key.startswith(prefix):\n                # Extract the key without prefix\n                short_key = key[len(prefix):]\n                result[short_key] = value\n                \n        return result\n        \n    def set_category(self, category: str, values: Dict[str, Any]) -> None:\n        \"\"\"\n        Set multiple configuration values for a specific category\n        \n        Args:\n            category: Configuration category prefix\n            values: Dictionary of values to set\n        \"\"\"\n        prefix = category + \".\"\n        \n        for key, value in values.items():\n            # Combine category prefix with key\n            full_key = prefix + key\n            self.config[full_key] = value",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\config_diagnostic.py": "\"\"\"\nConfiguration Diagnostic Module for IrintAI Assistant\n\nThis module provides diagnostics for configuration files including:\n- Config file existence and validity\n- Required settings presence\n- Configuration permissions\n- Path validation for referenced directories and files\n\"\"\"\nimport os\nimport json\nimport sys\nfrom typing import Dict, Any, List\nimport time\n\n# Add project root to sys.path to allow importing core modules\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nif project_root not in sys.path:\n    sys.path.insert(0, project_root)\n\ntry:\n    from core.config_manager import ConfigManager\nexcept ImportError as e:\n    print(f\"Error importing ConfigManager: {e}\")\n    sys.exit(1)\n\nclass ConfigDiagnostic:\n    \"\"\"Diagnostic tool for configuration checks\"\"\"\n    \n    def __init__(self, config_path='data/config.json'):\n        \"\"\"Initialize the configuration diagnostic module\"\"\"\n        self.config_path = config_path\n        self.results = {}\n        \n        # Define required configuration settings\n        self.required_settings = {\n            'main': ['ollama_url', 'default_model'],\n            'ui': ['theme', 'window_size', 'font_size'],\n            'plugins': ['enabled_plugins', 'plugin_directory'],\n            'logging': ['log_level', 'log_directory']\n        }\n        \n        # Initialize config manager if possible\n        try:\n            self.config_manager = ConfigManager(config_path)\n            self.config_loaded = True\n        except Exception:\n            self.config_loaded = False\n            self.config_manager = None\n        \n    def log(self, message):\n        \"\"\"Simple print-based logging for diagnostics\"\"\"\n        print(f\"[CONFIG DIAG] {message}\")\n    \n    def check_config_existence(self):\n        \"\"\"Check if the configuration file exists\"\"\"\n        self.log(f\"Checking configuration file existence: {self.config_path}\")\n        \n        # Get absolute path\n        if not os.path.isabs(self.config_path):\n            abs_path = os.path.join(project_root, self.config_path)\n        else:\n            abs_path = self.config_path\n            \n        if os.path.exists(abs_path):\n            self.results['config_existence'] = {\n                'status': 'Success',\n                'message': f\"Configuration file exists: {abs_path}\"\n            }\n            self.log(\"Configuration file exists\")\n            return True\n        else:\n            self.results['config_existence'] = {\n                'status': 'Failure',\n                'message': f\"Configuration file does not exist: {abs_path}\"\n            }\n            self.log(\"Configuration file does not exist\")\n            return False\n    \n    def check_config_validity(self):\n        \"\"\"Check if the configuration file contains valid JSON\"\"\"\n        if not self.check_config_existence():\n            self.results['config_validity'] = {\n                'status': 'Skipped',\n                'message': 'Configuration file does not exist'\n            }\n            self.log(\"Skipping validity check - file does not exist\")\n            return False\n            \n        self.log(\"Checking configuration file validity\")\n        \n        # Get absolute path\n        if not os.path.isabs(self.config_path):\n            abs_path = os.path.join(project_root, self.config_path)\n        else:\n            abs_path = self.config_path\n            \n        try:\n            with open(abs_path, 'r') as f:\n                json.load(f)\n            \n            self.results['config_validity'] = {\n                'status': 'Success',\n                'message': 'Configuration file contains valid JSON'\n            }\n            self.log(\"Configuration file is valid JSON\")\n            return True\n        except json.JSONDecodeError as e:\n            self.results['config_validity'] = {\n                'status': 'Failure',\n                'message': f\"Configuration file contains invalid JSON: {e}\"\n            }\n            self.log(f\"Configuration file contains invalid JSON: {e}\")\n            return False\n        except Exception as e:\n            self.results['config_validity'] = {\n                'status': 'Failure',\n                'message': f\"Error reading configuration file: {e}\"\n            }\n            self.log(f\"Error reading configuration file: {e}\")\n            return False\n    \n    def check_required_settings(self):\n        \"\"\"Check if all required configuration settings are present\"\"\"\n        if not self.config_loaded:\n            self.results['required_settings'] = {\n                'status': 'Skipped',\n                'message': 'Configuration file not loaded'\n            }\n            self.log(\"Skipping required settings check - config not loaded\")\n            return False\n            \n        self.log(\"Checking required configuration settings\")\n        \n        # Get configuration\n        config = self.config_manager.config\n        \n        # Check each required setting\n        missing_settings = {}\n        for category, settings in self.required_settings.items():\n            missing_in_category = []\n            for setting in settings:\n                # For top-level settings\n                if category == 'main':\n                    if setting not in config:\n                        missing_in_category.append(setting)\n                # For nested settings\n                elif category in config:\n                    if setting not in config[category]:\n                        missing_in_category.append(setting)\n                else:\n                    missing_in_category.append(setting)\n            \n            if missing_in_category:\n                missing_settings[category] = missing_in_category\n        \n        # Determine status based on missing settings\n        if not missing_settings:\n            self.results['required_settings'] = {\n                'status': 'Success',\n                'message': 'All required configuration settings are present'\n            }\n            self.log(\"All required settings are present\")\n            return True\n        else:\n            # Create message with missing settings\n            message_parts = [\"Missing required settings:\"]\n            for category, settings in missing_settings.items():\n                message_parts.append(f\"- {category}: {', '.join(settings)}\")\n                \n            self.results['required_settings'] = {\n                'status': 'Failure',\n                'message': '\\n'.join(message_parts),\n                'missing': missing_settings\n            }\n            self.log(f\"Missing {sum(len(s) for s in missing_settings.values())} required settings\")\n            return False\n    \n    def check_config_permissions(self):\n        \"\"\"Check if the configuration file has correct permissions\"\"\"\n        if not self.check_config_existence():\n            self.results['config_permissions'] = {\n                'status': 'Skipped',\n                'message': 'Configuration file does not exist'\n            }\n            self.log(\"Skipping permissions check - file does not exist\")\n            return False\n            \n        self.log(\"Checking configuration file permissions\")\n        \n        # Get absolute path\n        if not os.path.isabs(self.config_path):\n            abs_path = os.path.join(project_root, self.config_path)\n        else:\n            abs_path = self.config_path\n        \n        try:\n            # Check if file is readable\n            is_readable = os.access(abs_path, os.R_OK)\n            # Check if file is writable\n            is_writable = os.access(abs_path, os.W_OK)\n            \n            if is_readable and is_writable:\n                self.results['config_permissions'] = {\n                    'status': 'Success',\n                    'message': 'Configuration file has correct read/write permissions'\n                }\n                self.log(\"Configuration file has correct permissions\")\n                return True\n            else:\n                issues = []\n                if not is_readable:\n                    issues.append(\"not readable\")\n                if not is_writable:\n                    issues.append(\"not writable\")\n                    \n                self.results['config_permissions'] = {\n                    'status': 'Failure',\n                    'message': f\"Configuration file is {' and '.join(issues)}\"\n                }\n                self.log(f\"Configuration file has permission issues: {' and '.join(issues)}\")\n                return False\n        except Exception as e:\n            self.results['config_permissions'] = {\n                'status': 'Failure',\n                'message': f\"Error checking configuration file permissions: {e}\"\n            }\n            self.log(f\"Error checking permissions: {e}\")\n            return False\n    \n    def check_path_validations(self):\n        \"\"\"Check if paths referenced in configuration exist\"\"\"\n        if not self.config_loaded:\n            self.results['path_validations'] = {\n                'status': 'Skipped',\n                'message': 'Configuration file not loaded'\n            }\n            self.log(\"Skipping path validations - config not loaded\")\n            return False\n            \n        self.log(\"Checking path validations in configuration\")\n        \n        # Define paths to validate (key is config path, value is whether it's required)\n        paths_to_validate = {\n            'plugins.plugin_directory': True,\n            'logging.log_directory': True,\n            'data_directory': False,\n            'models.models_directory': False\n        }\n        \n        # Get configuration\n        config = self.config_manager.config\n        \n        # Check each path\n        invalid_paths = {}\n        for path_key, is_required in paths_to_validate.items():\n            # Parse path from config using dot notation\n            config_value = config\n            path_parts = path_key.split('.')\n            \n            try:\n                for part in path_parts:\n                    config_value = config_value[part]\n                    \n                # Skip if path is not set and not required\n                if not config_value and not is_required:\n                    continue\n                    \n                # Convert to absolute path if relative\n                if not os.path.isabs(config_value):\n                    abs_path = os.path.join(project_root, config_value)\n                else:\n                    abs_path = config_value\n                \n                if not os.path.exists(abs_path):\n                    invalid_paths[path_key] = {\n                        'path': config_value,\n                        'absolute_path': abs_path,\n                        'reason': 'Path does not exist'\n                    }\n                elif not os.path.isdir(abs_path):\n                    invalid_paths[path_key] = {\n                        'path': config_value,\n                        'absolute_path': abs_path,\n                        'reason': 'Path is not a directory'\n                    }\n            except (KeyError, TypeError):\n                if is_required:\n                    invalid_paths[path_key] = {\n                        'path': None,\n                        'reason': 'Path not found in configuration'\n                    }\n        \n        # Determine status based on invalid paths\n        if not invalid_paths:\n            self.results['path_validations'] = {\n                'status': 'Success',\n                'message': 'All configured paths exist and are valid'\n            }\n            self.log(\"All configured paths are valid\")\n            return True\n        else:\n            # Create message with invalid paths\n            message_parts = [\"Invalid configured paths:\"]\n            for path_key, details in invalid_paths.items():\n                reason = details['reason']\n                path = details.get('path', 'Not set')\n                message_parts.append(f\"- {path_key}: {path} ({reason})\")\n                \n            self.results['path_validations'] = {\n                'status': 'Failure' if any(paths_to_validate[k] for k in invalid_paths if k in paths_to_validate) else 'Warning',\n                'message': '\\n'.join(message_parts),\n                'invalid_paths': invalid_paths\n            }\n            self.log(f\"Found {len(invalid_paths)} invalid configured paths\")\n            return False\n    \n    def check_ollama_url_setting(self):\n        \"\"\"Specific check for the Ollama URL setting\"\"\"\n        if not self.config_loaded:\n            self.results['ollama_url'] = {\n                'status': 'Skipped',\n                'message': 'Configuration file not loaded'\n            }\n            self.log(\"Skipping Ollama URL check - config not loaded\")\n            return False\n            \n        self.log(\"Checking Ollama URL configuration\")\n        \n        # Get Ollama URL from config\n        ollama_url = self.config_manager.get('ollama_url', None)\n        \n        if not ollama_url:\n            self.results['ollama_url'] = {\n                'status': 'Failure',\n                'message': 'Ollama URL is not set in configuration'\n            }\n            self.log(\"Ollama URL is not configured\")\n            return False\n        \n        # Validate URL format (basic check)\n        if not ollama_url.startswith(('http://', 'https://')):\n            self.results['ollama_url'] = {\n                'status': 'Warning',\n                'message': f\"Ollama URL '{ollama_url}' does not start with http:// or https://\"\n            }\n            self.log(f\"Ollama URL has invalid format: {ollama_url}\")\n            return False\n            \n        # If URL is valid format, consider it a success\n        self.results['ollama_url'] = {\n            'status': 'Success',\n            'message': f\"Ollama URL is configured: {ollama_url}\"\n        }\n        self.log(f\"Ollama URL is properly configured: {ollama_url}\")\n        return True\n    \n    def check_models_configuration(self):\n        \"\"\"Check models configuration settings\"\"\"\n        if not self.config_loaded:\n            self.results['models_configuration'] = {\n                'status': 'Skipped',\n                'message': 'Configuration file not loaded'\n            }\n            self.log(\"Skipping models configuration check - config not loaded\")\n            return False\n            \n        self.log(\"Checking models configuration\")\n        \n        # Get model-related settings\n        default_model = self.config_manager.get('default_model', None)\n        models_config = self.config_manager.get('models', {})\n        \n        issues = []\n        \n        # Check default model\n        if not default_model:\n            issues.append(\"Default model is not configured\")\n        \n        # Check models configuration\n        if not models_config:\n            issues.append(\"Models section is missing from configuration\")\n        else:\n            # Check for available models list\n            available_models = models_config.get('available_models', [])\n            if not available_models:\n                issues.append(\"No available models are configured\")\n            \n            # Check if default model is in available models\n            elif default_model and default_model not in available_models:\n                issues.append(f\"Default model '{default_model}' is not in the list of available models\")\n        \n        # Determine status based on issues\n        if not issues:\n            self.results['models_configuration'] = {\n                'status': 'Success',\n                'message': 'Models configuration is valid'\n            }\n            self.log(\"Models configuration is valid\")\n            return True\n        else:\n            self.results['models_configuration'] = {\n                'status': 'Warning',\n                'message': f\"Models configuration has issues: {', '.join(issues)}\"\n            }\n            self.log(f\"Models configuration has issues: {', '.join(issues)}\")\n            return False\n    \n    def run_all_checks(self):\n        \"\"\"Run all configuration diagnostic checks\"\"\"\n        self.log(\"Starting configuration diagnostics...\")\n        start_time = time.time()\n        \n        # Run checks\n        self.check_config_existence()\n        self.check_config_validity()\n        self.check_config_permissions()\n        self.check_required_settings()\n        self.check_path_validations()\n        self.check_ollama_url_setting()\n        self.check_models_configuration()\n        \n        elapsed_time = time.time() - start_time\n        self.log(f\"Configuration diagnostics completed in {elapsed_time:.2f} seconds\")\n        return self.results\n",
  "D:\\AI\\IrintAI Assistant\\irintai.py": "#!/usr/bin/env python3\n\"\"\"\nIrintai - Local AI Assistant\nA modular, user-friendly interface for local language models\n\nThis application provides a graphical interface for interacting with local AI models,\nmanaging embeddings for context-aware responses, and configuring various aspects\nof the assistant.\n\"\"\"\n\n# Suppress TensorFlow logging messages\nimport os\nimport sys\nimport warnings\n\nimport tkinter as tk\nfrom tkinter import ttk\nimport traceback\nimport threading\nimport time\n\n# Define base data directory - can be overridden by environment variable\nBASE_DATA_DIR = os.environ.get(\"IRINTAI_DATA_DIR\", \"data\")\n\n# Create dictionary of data directories\nDATA_DIRS = {\n    \"models\": os.path.join(BASE_DATA_DIR, \"models\"),\n    \"logs\": os.path.join(BASE_DATA_DIR, \"logs\"),\n    \"vector_store\": os.path.join(BASE_DATA_DIR, \"vector_store\"),\n    \"reflections\": os.path.join(BASE_DATA_DIR, \"reflections\"),\n    \"plugins\": os.path.join(BASE_DATA_DIR, \"plugins\"),\n    \"plugins_config\": os.path.join(BASE_DATA_DIR, \"plugins\", \"config\"),\n    \"plugins_data\": os.path.join(BASE_DATA_DIR, \"plugins\", \"data\"),\n}\n\n# Create required directories\nfor dir_path in DATA_DIRS.values():\n    os.makedirs(dir_path, exist_ok=True)\n\n# Import core modules\nfrom core import (\n    ModelManager, \n    ChatEngine, \n    MemorySystem, \n    ConfigManager,\n    PluginManager,\n    PluginSDK\n)\n\n# Import utility modules\nfrom utils import (\n    IrintaiLogger,\n    SystemMonitor,\n    FileOps,\n    EventBus,\n    DependencyManager\n)\n\n# Import the new SettingsManager\nfrom core.settings_manager import SettingsManager\n\n# Import UI components\nfrom ui import MainWindow\n\ndef setup_exception_handler(logger):\n    \"\"\"Set up global exception handler to log errors\"\"\"\n    def handle_exception(exc_type, exc_value, exc_traceback):\n        # Log the exception\n        if issubclass(exc_type, KeyboardInterrupt):\n            # Special case for keyboard interrupt\n            sys.__excepthook__(exc_type, exc_value, exc_traceback)\n            return\n            \n        # Log the exception\n        logger.error(\"Uncaught exception:\", exc_info=(exc_type, exc_value, exc_traceback))\n        \n        # Show error dialog\n        import tkinter.messagebox as messagebox\n        error_msg = f\"An unexpected error occurred:\\n\\n{exc_value}\\n\\nSee log file for details.\"\n        messagebox.showerror(\"Error\", error_msg)\n        \n    # Install exception handler\n    sys.excepthook = handle_exception\n\ndef configure_theme():\n    \"\"\"Configure the application theme\"\"\"\n    style = ttk.Style()\n    \n    # Configure default style\n    style.configure(\"TButton\", padding=5)\n    style.configure(\"TFrame\", background=\"#f0f0f0\")\n    style.configure(\"TLabel\", background=\"#f0f0f0\")\n    \n    # Configure accent style for primary buttons\n    style.configure(\"Accent.TButton\", background=\"#007bff\", foreground=\"white\")\n    style.map(\"Accent.TButton\",\n        background=[(\"active\", \"#0069d9\"), (\"disabled\", \"#cccccc\")],\n        foreground=[(\"disabled\", \"#666666\")]\n    )\n    \n    # Configure warning style for critical buttons\n    style.configure(\"Warning.TButton\", background=\"#dc3545\", foreground=\"white\")\n    style.map(\"Warning.TButton\",\n        background=[(\"active\", \"#c82333\"), (\"disabled\", \"#cccccc\")],\n        foreground=[(\"disabled\", \"#666666\")]\n    )\n    \ndef main():\n\n\n\n    \"\"\"Main application entry point\"\"\"\n    # Create the main window\n    root = tk.Tk()\n    root.title(\"Irintai - Local AI Assistant\")\n    root.minsize(800, 600)\n    root.geometry(\"1024x768\")\n    \n    # Try to set the application icon\n    try:\n        if os.path.exists(\"resources/icons/irintai_icon.ico\"):\n            root.iconbitmap(\"resources/icons/irintai_icon.ico\")\n    except Exception:\n        pass  # Ignore icon errors\n    \n    # Configure theme\n    configure_theme()\n      # Handle uncaught exceptions\n    logger = IrintaiLogger(log_dir=DATA_DIRS[\"logs\"])\n    setup_exception_handler(logger.log)\n      # Start the application\n    try:        # Config file path - allow override through environment variable\n        config_file_path = os.environ.get(\"IRINTAI_CONFIG_FILE\", \n                                         os.path.join(BASE_DATA_DIR, \"config.json\"))\n        \n        # Initialize configuration manager first\n        config_manager = ConfigManager(path=config_file_path)\n          # Initialize core components with proper dependencies\n        # Get model path from config with fallback to a default location\n        model_path = config_manager.get(\"model_path\", os.path.join(os.path.expanduser(\"~\"), \"ollama\", \"models\"))\n        model_manager = ModelManager(\n            model_path=model_path,\n            logger=logger.log,\n            config=config_manager,\n            use_8bit=config_manager.get(\"model.use_8bit\", False)\n        )\n        \n        # Run Ollama diagnostics to identify version and path issues\n        try:\n            import subprocess\n            import shutil\n            \n            # Log the Ollama version\n            logger.log(\"[Diagnostics] Checking Ollama version...\")\n            version_result = subprocess.run(\n                [\"ollama\", \"--version\"],\n                capture_output=True,\n                text=True,\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                timeout=5\n            )\n            if version_result.returncode == 0:\n                logger.log(f\"[Diagnostics] Ollama version: {version_result.stdout.strip()}\")\n            else:\n                logger.log(f\"[Diagnostics] Error getting Ollama version: {version_result.stderr.strip()}\")\n            \n            # Log the path to the Ollama executable\n            ollama_path = shutil.which(\"ollama\")\n            logger.log(f\"[Diagnostics] Ollama executable path: {ollama_path}\")\n            \n            # Log the default list command to be used (using remote)\n            cmd = [\"ollama\", \"list\", \"remote\"]\n            logger.log(f\"[Diagnostics] Command to be executed: {cmd}\")\n            \n            # Log environment PATH\n            logger.log(f\"[Diagnostics] PATH environment variable: {os.environ.get('PATH')}\")\n            \n        except Exception as e:\n            logger.log(f\"[Diagnostics] Error during Ollama diagnostics: {e}\")\n        \n        # Initialize SystemMonitor for resource tracking\n        system_monitor = SystemMonitor(logger=logger.log, config=config_manager)\n        \n        # Start continuous monitoring with configurable interval\n        monitoring_interval = config_manager.get(\"system.monitoring_interval\", 1.0)        # Initialize EventBus for inter-plugin communication\n        event_bus = EventBus(logger=logger.log)\n        event_bus.start()  # Start the asynchronous event processing\n        \n        # Create file operations utility with proper sandboxing\n        file_ops = FileOps(\n            logger=logger.log\n        )\n        \n        # Create a partial core_system dictionary with components we already have\n        # This will be updated with additional components as they're initialized\n        core_system = {\n            \"config_manager\": config_manager,\n            \"logger\": logger,\n            \"system_monitor\": system_monitor,\n            \"event_bus\": event_bus,\n            \"file_ops\": file_ops\n        }\n        \n        # Create a settings manager to provide centralized settings management\n        settings_manager = SettingsManager(config_manager, logger=logger.log)\n        core_system[\"settings_manager\"] = settings_manager\n        \n        # Now pass event_bus to SystemMonitor\n        system_monitor.event_bus = event_bus\n        system_monitor.start_monitoring(interval=monitoring_interval)\n          # Initialize MemorySystem\n        memory_system = MemorySystem(\n            index_path=os.path.join(DATA_DIRS[\"vector_store\"], \"vector_store.json\"),\n            logger=logger.log\n        )\n\n        # Initialize DependencyManager for plugin dependencies\n        dependency_manager = DependencyManager(logger=logger.log)        # Create ChatEngine with model_manager dependency\n        chat_engine = ChatEngine(\n            model_manager=model_manager,\n            memory_system=memory_system,\n            session_file=os.path.join(BASE_DATA_DIR, \"chat_history.json\"),\n            logger=logger.log\n        )\n        \n        # Update the core_system with newly created components\n        core_system.update({\n            \"model_manager\": model_manager,\n            \"chat_engine\": chat_engine,\n            \"memory_system\": memory_system,\n            \"dependency_manager\": dependency_manager\n        })# Create plugin manager with all dependencies\n        plugin_manager = PluginManager(\n            plugin_dir=os.environ.get(\"IRINTAI_PLUGINS_DIR\", \"plugins\"),\n            config_dir=DATA_DIRS[\"plugins_config\"],\n            logger=logger.log,\n            core_system=core_system,\n        )\n        \n        # Log application start\n        logger.log(\"Irintai Assistant started successfully\")\n        \n        # Auto-load plugins if configured\n        if config_manager.get(\"plugins.auto_load\", True):\n            def delayed_plugin_loading():\n                # Wait for UI to initialize\n                time.sleep(1)\n                logger.log(\"Auto-loading plugins...\")\n                plugin_manager.auto_load_plugins()\n                \n            # Start plugin loading in a separate thread\n            threading.Thread(target=delayed_plugin_loading, daemon=True).start()\n        \n        # Start the UI main loop\n        root.mainloop()\n        \n        # Perform cleanup when the application exits\n        logger.log(\"Shutting down Irintai Assistant...\")\n        \n        # Stop event bus\n        event_bus.stop()\n        \n        # Stop system monitoring\n        system_monitor.stop_monitoring()\n        \n        # Unload all plugins\n        plugin_manager.unload_all_plugins()\n        \n        # Log application exit\n        logger.log(\"Irintai Assistant shut down successfully\")\n        \n    except Exception as e:\n        # Log the exception\n        logger.error(f\"Unhandled exception in main: {e}\")\n        logger.error(traceback.format_exc())\n        \n        # Show error dialog if UI is available\n        try:\n            import tkinter.messagebox as messagebox\n            error_msg = f\"An error occurred:\\n\\n{e}\\n\\nSee log for details.\"\n            messagebox.showerror(\"Error\", error_msg)\n        except:\n            pass\n\n    # Integrate enhanced diagnostics\n    try:\n        from diagnostics.diagnostics_integration import integrate_with_settings_manager, setup_runtime_patching\n        \n        # Set up runtime patching utilities\n        patch_plugin_manager, ensure_method_exists = setup_runtime_patching()\n        \n        # Apply runtime patching to plugin manager if needed\n        if plugin_manager is not None:\n            plugin_manager = patch_plugin_manager(plugin_manager)\n        \n        # Integrate with settings manager\n        if settings_manager is not None:\n            integrate_with_settings_manager(settings_manager)\n            \n        print(\"Enhanced diagnostics integrated successfully\")\n    except Exception as e:\n        print(f\"Warning: Could not integrate enhanced diagnostics: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\runtime_patching.py": "\"\"\"\nRuntime Patching Utilities\n\nThis module provides utility functions for runtime patching of objects\nto prevent AttributeError crashes and improve system resilience.\n\"\"\"\n\nimport logging\nfrom typing import Any, Callable, Optional\n\nlogger = logging.getLogger(__name__)\n\ndef ensure_attribute_exists(obj: Any, attribute_name: str, default_value: Any = None) -> None:\n    \"\"\"\n    Ensure that an object has a specified attribute, adding it with a default value if missing.\n    \n    Args:\n        obj: Object to check\n        attribute_name: Name of the attribute to ensure\n        default_value: Value to set if attribute doesn't exist\n    \"\"\"\n    if not hasattr(obj, attribute_name):\n        setattr(obj, attribute_name, default_value)\n        logger.warning(f\"Added missing attribute '{attribute_name}' to {obj.__class__.__name__}\")\n\ndef ensure_method_exists(obj: Any, method_name: str, default_impl: Optional[Callable] = None) -> None:\n    \"\"\"\n    Ensure that an object has a specified method, adding a default implementation if missing.\n    \n    Args:\n        obj: Object to check\n        method_name: Name of the method to ensure\n        default_impl: Function to use as default implementation if method doesn't exist.\n                     If None, a stub function that logs the call will be used.\n    \"\"\"\n    if not hasattr(obj, method_name):\n        if default_impl is None:\n            # Create a stub method that just logs the call\n            def stub_method(*args, **kwargs):\n                class_name = obj.__class__.__name__\n                logger.warning(f\"Called missing method '{method_name}' on {class_name}\")\n                return None\n            \n            default_impl = stub_method\n            \n        # Add the method to the object\n        setattr(obj, method_name, default_impl.__get__(obj, obj.__class__))\n        logger.warning(f\"Added missing method '{method_name}' to {obj.__class__.__name__}\")\n\ndef patch_plugin_manager(plugin_manager):\n    \"\"\"\n    Patch the plugin manager to ensure all required methods exist.\n    \n    Args:\n        plugin_manager: The plugin manager instance to patch\n        \n    Returns:\n        The patched plugin manager instance\n    \"\"\"\n    # Define required methods and their default implementations\n    required_methods = [\n        \"set_error_handler\",\n        \"discover_plugins\",\n        \"load_plugin\", \n        \"activate_plugin\", \n        \"deactivate_plugin\",\n        \"unload_plugin\",\n        \"unload_all_plugins\",\n        \"auto_load_plugins\",\n        \"get_plugin_metadata\",\n        \"get_all_plugins\",\n        \"reload_plugin\"\n    ]\n    \n    # Ensure each required method exists\n    for method in required_methods:\n        ensure_method_exists(plugin_manager, method)\n    \n    # Ensure required attributes exist\n    ensure_attribute_exists(plugin_manager, \"plugins\", {})\n    ensure_attribute_exists(plugin_manager, \"plugin_statuses\", {})\n    ensure_attribute_exists(plugin_manager, \"plugin_dir\", \"plugins\")\n    ensure_attribute_exists(plugin_manager, \"config_dir\", \"data/plugins\")\n    \n    return plugin_manager\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\plugin_event_bus.py": "\"\"\"\nPlugin Event Bus for IrintAI Assistant\nEnables inter-plugin communication through a publish/subscribe pattern\n\"\"\"\nimport threading\nimport time\nimport uuid\nimport queue\nfrom typing import Dict, List, Any, Callable, Set, Optional, Tuple, Union\n\nclass EventBus:\n    \"\"\"\n    Event bus for inter-plugin communication\n    Implements a publish/subscribe pattern with support for wildcards\n    \"\"\"\n    \n    def __init__(self, logger=None):\n        \"\"\"\n        Initialize the event bus\n        \n        Args:\n            logger: Optional logger for event logging\n        \"\"\"\n        self.logger = logger\n        self.subscribers = {}\n        self.wildcard_subscribers = {}\n        self.one_time_subscribers = {}\n        self.subscriptions = {}  # Track subscriptions by subscriber ID\n        self.lock = threading.RLock()\n        self.event_history = {}\n        self.history_limit = 100\n        self.event_queue = queue.Queue()\n        self.running = False\n        self.async_thread = None\n        \n    def start(self):\n        \"\"\"Start the async event processing thread\"\"\"\n        if self.running:\n            return\n            \n        self.running = True\n        self.async_thread = threading.Thread(target=self._process_event_queue, daemon=True)\n        self.async_thread.start()\n        self._log(\"Event Bus started\")\n        \n    def stop(self):\n        \"\"\"Stop the async event processing thread\"\"\"\n        self.running = False\n        if self.async_thread:\n            self.async_thread.join(timeout=2.0)\n            self.async_thread = None\n        self._log(\"Event Bus stopped\")\n        \n    def _log(self, message, level=\"INFO\"):\n        \"\"\"Log a message if logger is available\"\"\"\n        if self.logger:\n            if hasattr(self.logger, 'log'):\n                self.logger.log(f\"[EventBus] {message}\", level)\n            else:\n                print(f\"[EventBus] {message}\")\n        \n    def subscribe(self, event_pattern: str, callback: Callable, subscriber_id: str = None, \n                  one_time: bool = False) -> str:\n        \"\"\"\n        Subscribe to events matching the given pattern\n        \n        Args:\n            event_pattern: Event pattern to subscribe to (can include wildcards *)\n            callback: Function to call when event occurs\n            subscriber_id: Optional ID of the subscriber (used for unsubscribing)\n            one_time: Whether this is a one-time subscription\n            \n        Returns:\n            Subscription ID\n        \"\"\"\n        if not callable(callback):\n            raise ValueError(\"Callback must be callable\")\n            \n        # Generate subscriber ID if not provided\n        if subscriber_id is None:\n            subscriber_id = str(uuid.uuid4())\n            \n        # Generate a unique subscription ID\n        subscription_id = str(uuid.uuid4())\n        \n        with self.lock:\n            # Handle wildcard patterns\n            if '*' in event_pattern:\n                if event_pattern not in self.wildcard_subscribers:\n                    self.wildcard_subscribers[event_pattern] = {}\n                self.wildcard_subscribers[event_pattern][subscription_id] = callback\n            else:\n                if event_pattern not in self.subscribers:\n                    self.subscribers[event_pattern] = {}\n                self.subscribers[event_pattern][subscription_id] = callback\n                \n            # Store one-time subscriptions separately\n            if one_time:\n                self.one_time_subscribers[subscription_id] = event_pattern\n                \n            # Track subscription by subscriber ID\n            if subscriber_id not in self.subscriptions:\n                self.subscriptions[subscriber_id] = set()\n            self.subscriptions[subscriber_id].add(subscription_id)\n            \n        self._log(f\"Subscriber {subscriber_id} subscribed to {event_pattern} (ID: {subscription_id})\")\n        return subscription_id\n        \n    def unsubscribe(self, subscription_id: str) -> bool:\n        \"\"\"\n        Unsubscribe from an event using the subscription ID\n        \n        Args:\n            subscription_id: ID returned from subscribe()\n            \n        Returns:\n            True if unsubscribed successfully, False otherwise\n        \"\"\"\n        with self.lock:\n            # Check if this is a one-time subscription\n            one_time = False\n            if subscription_id in self.one_time_subscribers:\n                event_pattern = self.one_time_subscribers.pop(subscription_id)\n                one_time = True\n            else:\n                # Search for the subscription ID in all event patterns\n                event_pattern = None\n                for pattern, subscribers in self.subscribers.items():\n                    if subscription_id in subscribers:\n                        event_pattern = pattern\n                        break\n                        \n                if event_pattern is None:\n                    # Check wildcard patterns\n                    for pattern, subscribers in self.wildcard_subscribers.items():\n                        if subscription_id in subscribers:\n                            event_pattern = pattern\n                            break\n            \n            if not event_pattern:\n                return False\n                \n            # Remove the subscription\n            removed = False\n            if '*' in event_pattern:\n                if event_pattern in self.wildcard_subscribers:\n                    if subscription_id in self.wildcard_subscribers[event_pattern]:\n                        del self.wildcard_subscribers[event_pattern][subscription_id]\n                        removed = True\n            else:\n                if event_pattern in self.subscribers:\n                    if subscription_id in self.subscribers[event_pattern]:\n                        del self.subscribers[event_pattern][subscription_id]\n                        removed = True\n                        \n            # Remove from subscriber's list\n            for subscriber_id, subscriptions in self.subscriptions.items():\n                if subscription_id in subscriptions:\n                    subscriptions.remove(subscription_id)\n                    if not subscriptions:\n                        del self.subscriptions[subscriber_id]\n                    break\n                    \n            if removed:\n                self._log(f\"Unsubscribed from {event_pattern} (ID: {subscription_id})\")\n            return removed\n            \n    def unsubscribe_all(self, subscriber_id: str) -> int:\n        \"\"\"\n        Unsubscribe from all events for a given subscriber ID\n        \n        Args:\n            subscriber_id: Subscriber ID\n            \n        Returns:\n            Number of subscriptions removed\n        \"\"\"\n        with self.lock:\n            if subscriber_id not in self.subscriptions:\n                return 0\n                \n            subscriptions = list(self.subscriptions[subscriber_id])\n            count = 0\n            \n            for subscription_id in subscriptions:\n                if self.unsubscribe(subscription_id):\n                    count += 1\n                    \n            return count\n            \n    def publish(self, event_name: str, data: Any = None, \n                async_mode: bool = False, publisher_id: str = None) -> None:\n        \"\"\"\n        Publish an event\n        \n        Args:\n            event_name: Name of the event\n            data: Data to include with the event\n            async_mode: Whether to process the event asynchronously\n            publisher_id: Optional ID of the publisher\n        \"\"\"\n        event = {\n            'name': event_name,\n            'data': data,\n            'timestamp': time.time(),\n            'publisher_id': publisher_id\n        }\n        \n        # Add to event history\n        with self.lock:\n            if event_name not in self.event_history:\n                self.event_history[event_name] = []\n            self.event_history[event_name].append(event)\n            \n            # Trim history if needed\n            if len(self.event_history[event_name]) > self.history_limit:\n                self.event_history[event_name] = self.event_history[event_name][-self.history_limit:]\n        \n        if async_mode and self.running:\n            # Add to the event queue for async processing\n            self.event_queue.put(event)\n        else:\n            # Process synchronously\n            self._process_event(event)\n            \n    def _process_event_queue(self):\n        \"\"\"Process events from the queue asynchronously\"\"\"\n        while self.running:\n            try:\n                # Wait for an event with timeout to allow checking running status\n                try:\n                    event = self.event_queue.get(timeout=0.5)\n                    self._process_event(event)\n                    self.event_queue.task_done()\n                except queue.Empty:\n                    continue\n            except Exception as e:\n                self._log(f\"Error processing event queue: {e}\", \"ERROR\")\n                time.sleep(1)  # Avoid tight loop in case of persistent error\n    \n    def _process_event(self, event):\n        \"\"\"Process a single event\"\"\"\n        event_name = event['name']\n        \n        # Get all matching subscribers\n        matching_subscribers = {}\n        one_time_ids = set()\n        \n        with self.lock:\n            # Direct subscribers\n            if event_name in self.subscribers:\n                for sub_id, callback in self.subscribers[event_name].items():\n                    matching_subscribers[sub_id] = callback\n                    # Check if this is a one-time subscription\n                    if sub_id in self.one_time_subscribers:\n                        one_time_ids.add(sub_id)\n                        \n            # Wildcard subscribers\n            for pattern, subscribers in self.wildcard_subscribers.items():\n                if self._matches_pattern(event_name, pattern):\n                    for sub_id, callback in subscribers.items():\n                        matching_subscribers[sub_id] = callback\n                        # Check if this is a one-time subscription\n                        if sub_id in self.one_time_subscribers:\n                            one_time_ids.add(sub_id)\n        \n        # Call the subscribers\n        for sub_id, callback in matching_subscribers.items():\n            try:\n                callback(event_name, event['data'], event)\n            except Exception as e:\n                self._log(f\"Error in event callback for {event_name}: {e}\", \"ERROR\")\n                \n        # Remove one-time subscribers\n        if one_time_ids:\n            with self.lock:\n                for sub_id in one_time_ids:\n                    self.unsubscribe(sub_id)\n    \n    def _matches_pattern(self, event_name: str, pattern: str) -> bool:\n        \"\"\"\n        Check if an event name matches a pattern\n        \n        Args:\n            event_name: Event name to check\n            pattern: Pattern to match against\n            \n        Returns:\n            True if the event name matches the pattern, False otherwise\n        \"\"\"\n        # Simple wildcard matching\n        if pattern == '*':\n            return True\n            \n        if pattern.endswith('.*'):\n            prefix = pattern[:-2]\n            return event_name.startswith(prefix + '.')\n            \n        if pattern.startswith('*.'):\n            suffix = pattern[2:]\n            return event_name.endswith('.' + suffix)\n            \n        # Handle patterns with * in the middle\n        parts = pattern.split('*')\n        if len(parts) == 1:\n            return pattern == event_name\n            \n        # Check start\n        if not event_name.startswith(parts[0]):\n            return False\n        \n        # Check end\n        if not event_name.endswith(parts[-1]):\n            return False\n        \n        # Check middle parts\n        current_pos = len(parts[0])\n        for part in parts[1:-1]:\n            if part:\n                part_pos = event_name.find(part, current_pos)\n                if part_pos == -1:\n                    return False\n                current_pos = part_pos + len(part)\n                \n        return True\n        \n    def get_event_history(self, event_name: str = None, limit: int = None) -> List[Dict]:\n        \"\"\"\n        Get event history for a specific event or all events\n        \n        Args:\n            event_name: Optional event name to filter by\n            limit: Maximum number of events to return\n            \n        Returns:\n            List of events\n        \"\"\"\n        with self.lock:\n            result = []\n            \n            if event_name:\n                # Get history for specific event\n                events = self.event_history.get(event_name, [])\n                result = events.copy()\n            else:\n                # Get all events, flattened\n                for event_list in self.event_history.values():\n                    result.extend(event_list)\n                    \n                # Sort by timestamp\n                result.sort(key=lambda e: e['timestamp'])\n                \n            # Apply limit\n            if limit and len(result) > limit:\n                result = result[-limit:]\n                \n            return result\n            \n    def clear_event_history(self, event_name: str = None) -> None:\n        \"\"\"\n        Clear event history\n        \n        Args:\n            event_name: Optional event name to clear history for\n        \"\"\"\n        with self.lock:\n            if event_name:\n                if event_name in self.event_history:\n                    self.event_history[event_name] = []\n            else:\n                self.event_history = {}\n                \n    def wait_for_event(self, event_name: str, timeout: float = None, \n                       condition: Callable = None) -> Optional[Dict]:\n        \"\"\"\n        Wait for an event to occur\n        \n        Args:\n            event_name: Event name to wait for\n            timeout: Maximum time to wait in seconds\n            condition: Optional condition function to check event data\n            \n        Returns:\n            Event data or None if timeout\n        \"\"\"\n        result = [None]\n        event = threading.Event()\n        \n        def callback(name, data, event_data):\n            if condition and not condition(data):\n                return\n                \n            result[0] = event_data\n            event.set()\n            \n        # Subscribe to the event\n        sub_id = self.subscribe(event_name, callback, one_time=True)\n        \n        # Wait for the event or timeout\n        if not event.wait(timeout):\n            # Timeout, unsubscribe\n            self.unsubscribe(sub_id)\n            \n        return result[0]\n        \n    def list_subscribers(self, event_pattern: str = None) -> Dict:\n        \"\"\"\n        List subscribers\n        \n        Args:\n            event_pattern: Optional event pattern to filter by\n            \n        Returns:\n            Dictionary of event patterns and subscriber counts\n        \"\"\"\n        with self.lock:\n            result = {}\n            \n            if event_pattern:\n                # Count subscribers for specific pattern\n                if '*' in event_pattern:\n                    if event_pattern in self.wildcard_subscribers:\n                        result[event_pattern] = len(self.wildcard_subscribers[event_pattern])\n                else:\n                    if event_pattern in self.subscribers:\n                        result[event_pattern] = len(self.subscribers[event_pattern])\n            else:\n                # Count all subscribers\n                for pattern, subscribers in self.subscribers.items():\n                    result[pattern] = len(subscribers)\n                    \n                for pattern, subscribers in self.wildcard_subscribers.items():\n                    result[pattern] = len(subscribers)\n                    \n            return result\n            \n    def get_subscriber_info(self, subscriber_id: str) -> Dict:\n        \"\"\"\n        Get information about a subscriber\n        \n        Args:\n            subscriber_id: Subscriber ID\n            \n        Returns:\n            Dictionary of subscriber information\n        \"\"\"\n        with self.lock:\n            if subscriber_id not in self.subscriptions:\n                return {'subscriber_id': subscriber_id, 'subscriptions': []}\n                \n            subscriptions = []\n            for subscription_id in self.subscriptions[subscriber_id]:\n                # Find the event pattern for this subscription\n                event_pattern = None\n                one_time = subscription_id in self.one_time_subscribers\n                \n                # Check direct subscribers\n                for pattern, subs in self.subscribers.items():\n                    if subscription_id in subs:\n                        event_pattern = pattern\n                        break\n                        \n                # Check wildcard subscribers\n                if not event_pattern:\n                    for pattern, subs in self.wildcard_subscribers.items():\n                        if subscription_id in subs:\n                            event_pattern = pattern\n                            break\n                            \n                if event_pattern:\n                    subscriptions.append({\n                        'id': subscription_id,\n                        'event_pattern': event_pattern,\n                        'one_time': one_time\n                    })\n                    \n            return {\n                'subscriber_id': subscriber_id,\n                'subscriptions': subscriptions\n            }",
  "D:\\AI\\IrintAI Assistant\\ui\\panels\\memory_panel.py": "# File: ui/memory_panel.py\n\"\"\"\nMemory panel UI component for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, filedialog, messagebox, scrolledtext\nimport threading\nimport time\nimport os\nfrom typing import Callable, Dict, List, Any, Optional\n\n# Import enhanced PDF handling\nfrom memory_system.memory_pdf_integration import enhance_memory_system\n\nclass MemoryPanel:\n    \"\"\"Memory management panel for vector embeddings and knowledge retrieval\"\"\"\n\n    def __init__(self, parent, memory_system, file_ops, logger: Callable, chat_engine, settings_manager=None):\n        \"\"\"\n        Initialize the memory panel\n\n        Args:\n            parent: Parent widget\n            memory_system: MemorySystem instance\n            file_ops: FileOps instance\n            logger: Logging function\n            chat_engine: ChatEngine instance\n            settings_manager: SettingsManager instance (optional)\n        \"\"\"\n        self.parent = parent\n        self.memory_system = memory_system\n        self.file_ops = file_ops\n        self.log = logger\n        self.chat_engine = chat_engine\n        self.settings_manager = settings_manager\n        \n        # Get OCR setting from unified settings or use default\n        ocr_enabled = settings_manager.get_setting(\"memory.pdf.ocr_enabled\", False) if settings_manager else False\n        \n        # Create enhanced memory file handler\n        self.enhanced_memory = enhance_memory_system(memory_system, file_ops, enable_ocr=ocr_enabled)\n        \n        # Register for OCR setting changes if settings_manager is available\n        if settings_manager:\n            settings_manager.register_observer(\"memory.pdf.ocr_enabled\", self._on_ocr_setting_changed)\n\n        # Create the main frame\n        self.frame = ttk.Frame(parent)\n\n        # Initialize UI components\n        self.initialize_ui()\n\n        # Load memory stats\n        self.refresh_stats()\n        \n    def initialize_ui(self):\n        \"\"\"Initialize UI components\"\"\"\n        # Create notebook\n        self.notebook = ttk.Notebook(self.frame)\n        \n        # Create main tabs - removed redundant settings tab\n        self.search_tab = ttk.Frame(self.notebook)\n        self.manage_tab = ttk.Frame(self.notebook)\n        \n        self.notebook.add(self.search_tab, text=\"Memory Search\")\n        self.notebook.add(self.manage_tab, text=\"Management\")\n        \n        self.notebook.pack(expand=True, fill=\"both\", padx=10, pady=10)\n        \n        # Initialize tab contents - removed redundant settings tab\n        self.initialize_search_tab()\n        self.initialize_manage_tab()\n        \n    def initialize_search_tab(self):\n        \"\"\"Initialize search tab\"\"\"\n        # Create search frame with padding\n        search_frame = ttk.Frame(self.search_tab, padding=10)\n        search_frame.pack(fill=\"both\", expand=True)\n        \n        # Search input area\n        input_frame = ttk.Frame(search_frame)\n        input_frame.pack(fill=\"x\", pady=5)\n        \n        ttk.Label(input_frame, text=\"Search Memory:\").pack(side=\"left\", padx=5)\n        \n        self.search_var = tk.StringVar()\n        search_entry = ttk.Entry(input_frame, textvariable=self.search_var, width=50)\n        search_entry.pack(side=\"left\", fill=\"x\", expand=True, padx=5)\n        search_entry.bind(\"<Return>\", lambda e: self.search_memory())\n        \n        ttk.Button(\n            input_frame, \n            text=\"Search\",\n            command=self.search_memory\n        ).pack(side=\"left\", padx=5)\n        \n        # Results area\n        results_frame = ttk.LabelFrame(search_frame, text=\"Search Results\")\n        results_frame.pack(fill=\"both\", expand=True, pady=10)\n        \n        # Create scrolled text widget for results\n        self.results_text = scrolledtext.ScrolledText(\n            results_frame,\n            wrap=\"word\",\n            height=15,\n            font=(\"Consolas\", 10)\n        )\n        self.results_text.pack(fill=\"both\", expand=True, padx=5, pady=5)\n        self.results_text.config(state=\"disabled\")\n        \n        # Options frame\n        options_frame = ttk.LabelFrame(search_frame, text=\"Search Options\")\n        options_frame.pack(fill=\"x\", pady=10)\n        \n        # Number of results\n        results_frame = ttk.Frame(options_frame)\n        results_frame.pack(fill=\"x\", padx=10, pady=5)\n        \n        ttk.Label(results_frame, text=\"Max Results:\").pack(side=\"left\", padx=5)\n        \n        self.max_results_var = tk.IntVar(value=5)\n        ttk.Spinbox(\n            results_frame,\n            from_=1,\n            to=20,\n            width=5,\n            textvariable=self.max_results_var\n        ).pack(side=\"left\", padx=5)\n        \n    def initialize_manage_tab(self):\n        \"\"\"Initialize management tab\"\"\"\n        # Create scrollable frame\n        manage_frame = ttk.Frame(self.manage_tab)\n        manage_frame.pack(fill=\"both\", expand=True, padx=10, pady=10)\n        \n        # Create memory management section\n        self.create_memory_management(manage_frame)\n        \n        # Create documents tree view\n        docs_frame = ttk.LabelFrame(manage_frame, text=\"Memory Documents\")\n        docs_frame.pack(fill=\"both\", expand=True, padx=10, pady=10)\n        \n        # Create tree view with scrollbar\n        tree_frame = ttk.Frame(docs_frame)\n        tree_frame.pack(fill=\"both\", expand=True, padx=5, pady=5)\n        \n        # Create scrollbars\n        y_scroll = ttk.Scrollbar(tree_frame, orient=\"vertical\")\n        y_scroll.pack(side=\"right\", fill=\"y\")\n        \n        x_scroll = ttk.Scrollbar(tree_frame, orient=\"horizontal\")\n        x_scroll.pack(side=\"bottom\", fill=\"x\")\n        \n        # Create the treeview\n        self.docs_tree = ttk.Treeview(\n            tree_frame,\n            columns=(\"type\", \"chunks\", \"updated\"),\n            show=\"tree headings\",\n            yscrollcommand=y_scroll.set,\n            xscrollcommand=x_scroll.set\n        )\n        self.docs_tree.pack(fill=\"both\", expand=True)\n        \n        # Configure scrollbars\n        y_scroll.config(command=self.docs_tree.yview)\n        x_scroll.config(command=self.docs_tree.xview)\n        \n        # Set up columns\n        self.docs_tree.column(\"#0\", width=300, minwidth=200)\n        self.docs_tree.column(\"type\", width=100, minwidth=80)\n        self.docs_tree.column(\"chunks\", width=80, minwidth=50, anchor=\"center\")\n        self.docs_tree.column(\"updated\", width=150, minwidth=120)\n        \n        # Set up column headings\n        self.docs_tree.heading(\"#0\", text=\"Document Source\", anchor=\"w\")\n        self.docs_tree.heading(\"type\", text=\"Type\", anchor=\"w\")\n        self.docs_tree.heading(\"chunks\", text=\"Chunks\", anchor=\"center\")\n        self.docs_tree.heading(\"updated\", text=\"Last Updated\", anchor=\"w\")\n        \n        # Add context menu\n        self.create_tree_context_menu()\n        \n    def initialize_settings_tab(self):\n        \"\"\"Initialize settings tab\"\"\"\n        # Create settings frame with padding\n        settings_frame = ttk.Frame(self.settings_tab, padding=10)\n        settings_frame.pack(fill=\"both\", expand=True)\n        \n        # Memory mode settings\n        memory_mode_frame = ttk.LabelFrame(settings_frame, text=\"Memory Mode\")\n        memory_mode_frame.pack(fill=\"x\", pady=5)\n        \n        # Memory mode radio buttons\n        self.memory_mode_var = tk.StringVar(value=\"off\")\n        ttk.Radiobutton(memory_mode_frame, text=\"Off\", variable=self.memory_mode_var, \n                        value=\"off\", command=self.set_memory_mode).pack(anchor=\"w\", padx=10, pady=2)\n        ttk.Radiobutton(memory_mode_frame, text=\"Manual\", variable=self.memory_mode_var, \n                        value=\"manual\", command=self.set_memory_mode).pack(anchor=\"w\", padx=10, pady=2)\n        ttk.Radiobutton(memory_mode_frame, text=\"Auto\", variable=self.memory_mode_var, \n                        value=\"auto\", command=self.set_memory_mode).pack(anchor=\"w\", padx=10, pady=2)\n        ttk.Radiobutton(memory_mode_frame, text=\"Background\", variable=self.memory_mode_var, \n                        value=\"background\", command=self.set_memory_mode).pack(anchor=\"w\", padx=10, pady=2)\n        \n        # Enhanced PDF settings\n        pdf_frame = ttk.LabelFrame(settings_frame, text=\"PDF Processing\")\n        pdf_frame.pack(fill=\"x\", pady=10)\n        \n        # OCR Settings\n        self.ocr_enabled_var = tk.BooleanVar(value=False)\n        ttk.Checkbutton(pdf_frame, text=\"Enable OCR for image-based PDFs\", \n                       variable=self.ocr_enabled_var, \n                       command=self.toggle_ocr).pack(anchor=\"w\", padx=10, pady=5)\n        \n        ocr_note = \"Note: OCR requires pytesseract and Pillow packages.\"\n        ttk.Label(pdf_frame, text=ocr_note, font=(\"Helvetica\", 8), foreground=\"gray\").pack(anchor=\"w\", padx=10, pady=0)\n        \n        # Add test OCR button\n        ttk.Button(pdf_frame, text=\"Check OCR Installation\", \n                  command=self.check_ocr_installation).pack(anchor=\"w\", padx=10, pady=5)\n        \n        # Advanced settings\n        advanced_frame = ttk.LabelFrame(settings_frame, text=\"Advanced Settings\")\n        advanced_frame.pack(fill=\"x\", pady=10)\n        \n        # Clear memory button\n        ttk.Button(advanced_frame, text=\"Clear Memory Index\", \n                  command=self.clear_memory_index, style=\"Warning.TButton\").pack(anchor=\"w\", padx=10, pady=5)\n        \n    def toggle_ocr(self):\n        \"\"\"Toggle OCR functionality\"\"\"\n        ocr_enabled = self.ocr_enabled_var.get()\n        # Create a new enhanced memory handler with the updated OCR setting\n        self.enhanced_memory = enhance_memory_system(self.memory_system, self.file_ops, enable_ocr=ocr_enabled)\n        self.log(f\"[Memory] OCR for PDF processing: {'Enabled' if ocr_enabled else 'Disabled'}\")\n        \n    def check_ocr_installation(self):\n        \"\"\"Check if OCR dependencies are installed\"\"\"\n        try:\n            import pytesseract\n            from PIL import Image\n            pytesseract.get_tesseract_version()\n            messagebox.showinfo(\"OCR Check\", \"OCR dependencies are correctly installed.\")\n        except ImportError as e:\n            messagebox.showerror(\"OCR Check\", f\"Missing OCR dependency: {str(e)}\\n\\nInstall with:\\npip install pytesseract pillow\")\n        except Exception as e:\n            messagebox.showerror(\"OCR Check\", f\"OCR error: {str(e)}\\n\\nMake sure Tesseract OCR is installed on your system.\")\n            \n    def set_memory_mode(self):\n        \"\"\"Set the memory mode based on the selected radio button\"\"\"\n        mode = self.memory_mode_var.get()\n        \n        if mode == \"off\":\n            self.chat_engine.set_memory_mode(False)\n            self.log(\"[Memory Mode] Set to: Off\")\n        elif mode == \"manual\":\n            self.chat_engine.set_memory_mode(True, auto=False, background=False)\n            self.log(\"[Memory Mode] Set to: Manual\")\n        elif mode == \"auto\":\n            self.chat_engine.set_memory_mode(True, auto=True, background=False)\n            self.log(\"[Memory Mode] Set to: Auto\")\n        elif mode == \"background\":\n            self.chat_engine.set_memory_mode(True, auto=True, background=True)\n            self.log(\"[Memory Mode] Set to: Background\")\n        \n    def create_memory_management(self, parent):\n        \"\"\"Create the memory management section\"\"\"\n        mgmt_frame = ttk.LabelFrame(parent, text=\"Memory Management\")\n        mgmt_frame.pack(fill=tk.X, padx=10, pady=10, anchor=tk.N)\n        \n        # Load files section\n        load_frame = ttk.Frame(mgmt_frame)\n        load_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Button(\n            load_frame,\n            text=\"Load Files\",\n            command=self.load_files\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            load_frame,\n            text=\"Load Folder\",\n            command=self.load_folder\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Memory stats section\n        stats_frame = ttk.Frame(mgmt_frame)\n        stats_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(stats_frame, text=\"Document Count:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)\n        self.doc_count_var = tk.StringVar(value=\"0\")\n        ttk.Label(stats_frame, textvariable=self.doc_count_var, font=(\"Helvetica\", 10, \"bold\")).grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(stats_frame, text=\"Last Updated:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)\n        self.last_updated_var = tk.StringVar(value=\"Never\")\n        ttk.Label(stats_frame, textvariable=self.last_updated_var).grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(stats_frame, text=\"Index Path:\").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)\n        self.index_path_var = tk.StringVar(value=self.memory_system.index_path)\n        ttk.Label(stats_frame, textvariable=self.index_path_var, foreground=\"blue\").grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        # Action buttons\n        action_frame = ttk.Frame(mgmt_frame)\n        action_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Button(\n            action_frame,\n            text=\"Clear Index\",\n            command=self.clear_index\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            action_frame,\n            text=\"Save Index\",\n            command=self.save_index\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            action_frame,\n            text=\"Refresh Stats\",\n            command=self.refresh_stats\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Memory mode section\n        mode_frame = ttk.Frame(mgmt_frame)\n        mode_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(mode_frame, text=\"Memory Mode:\").pack(side=tk.LEFT)\n        \n        self.memory_mode_var = tk.StringVar(value=self.chat_engine.memory_mode)\n        memory_modes = [\"Off\", \"Manual\", \"Auto\", \"Background\"]\n        \n        mode_dropdown = ttk.Combobox(\n            mode_frame,\n            textvariable=self.memory_mode_var,\n            values=memory_modes,\n            state=\"readonly\",\n            width=15\n        )\n        mode_dropdown.pack(side=tk.LEFT, padx=5)\n        mode_dropdown.bind(\"<<ComboboxSelected>>\", self.on_memory_mode_changed)\n        \n        # Add mode description\n        self.mode_desc_var = tk.StringVar(value=self._get_mode_description(\"Off\"))\n        ttk.Label(mode_frame, textvariable=self.mode_desc_var, font=(\"Helvetica\", 9, \"italic\")).pack(side=tk.LEFT, padx=20)\n        \n    def create_memory_search(self):\n        \"\"\"Create the memory search section\"\"\"\n        search_frame = ttk.LabelFrame(self.frame, text=\"Memory Search\")\n        search_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Search input section\n        input_frame = ttk.Frame(search_frame)\n        input_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(input_frame, text=\"Query:\").pack(side=tk.LEFT)\n        \n        self.search_entry = ttk.Entry(input_frame, width=50)\n        self.search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n        self.search_entry.bind(\"<Return>\", self.search_memory)\n        \n        ttk.Button(\n            input_frame,\n            text=\"Search\",\n            command=self.search_memory\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Search options\n        options_frame = ttk.Frame(search_frame)\n        options_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(options_frame, text=\"Results:\").pack(side=tk.LEFT)\n        \n        self.results_count_var = tk.StringVar(value=\"5\")\n        results_spinbox = ttk.Spinbox(\n            options_frame,\n            from_=1,\n            to=20,\n            width=5,\n            textvariable=self.results_count_var\n        )\n        results_spinbox.pack(side=tk.LEFT, padx=5)\n        \n        # Search results section\n        results_frame = ttk.Frame(search_frame)\n        results_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Create scrolled text for results\n        self.results_text = scrolledtext.ScrolledText(\n            results_frame,\n            wrap=tk.WORD,\n            height=10,\n            font=(\"Helvetica\", 9)\n        )\n        self.results_text.pack(fill=tk.BOTH, expand=True)\n        \n        # Configure text tags\n        self.results_text.tag_configure(\n            \"heading\",\n            font=(\"Helvetica\", 10, \"bold\"),\n            foreground=\"#000080\"\n        )\n        self.results_text.tag_configure(\n            \"source\",\n            font=(\"Helvetica\", 9, \"italic\"),\n            foreground=\"#800000\"\n        )\n        self.results_text.tag_configure(\n            \"score\",\n            font=(\"Helvetica\", 9),\n            foreground=\"#008000\"\n        )\n        self.results_text.tag_configure(\n            \"content\",\n            font=(\"Helvetica\", 9)\n        )\n        \n    def create_documents_section(self):\n        \"\"\"Create the indexed documents section\"\"\"\n        docs_frame = ttk.LabelFrame(self.frame, text=\"Indexed Documents\")\n        docs_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create a tree view for documents\n        columns = (\"Source\", \"Type\", \"Chunks\", \"Last Updated\")\n        self.docs_tree = ttk.Treeview(\n            docs_frame,\n            columns=columns,\n            show=\"headings\",\n            selectmode=\"browse\"\n        )\n        \n        # Configure columns\n        self.docs_tree.heading(\"Source\", text=\"Document\")\n        self.docs_tree.heading(\"Type\", text=\"Type\")\n        self.docs_tree.heading(\"Chunks\", text=\"Chunks\")\n        self.docs_tree.heading(\"Last Updated\", text=\"Last Updated\")\n        \n        self.docs_tree.column(\"Source\", width=250, anchor=tk.W)\n        self.docs_tree.column(\"Type\", width=80, anchor=tk.CENTER)\n        self.docs_tree.column(\"Chunks\", width=60, anchor=tk.CENTER)\n        self.docs_tree.column(\"Last Updated\", width=150, anchor=tk.CENTER)\n        \n        # Add scrollbar\n        docs_scrollbar = ttk.Scrollbar(docs_frame, orient=\"vertical\", command=self.docs_tree.yview)\n        self.docs_tree.configure(yscrollcommand=docs_scrollbar.set)\n        \n        # Pack the tree and scrollbar\n        self.docs_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        docs_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        # Bind selection event\n        self.docs_tree.bind(\"<<TreeviewSelect>>\", self.on_document_selected)\n        \n        # Create document preview frame\n        preview_frame = ttk.LabelFrame(self.frame, text=\"Document Preview\")\n        preview_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create preview text\n        self.preview_text = scrolledtext.ScrolledText(\n            preview_frame,\n            wrap=tk.WORD,\n            height=6,\n            font=(\"Helvetica\", 9)\n        )\n        self.preview_text.pack(fill=tk.BOTH, expand=True)\n        \n        # Add Preview/Remove buttons\n        preview_buttons = ttk.Frame(preview_frame)\n        preview_buttons.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Button(\n            preview_buttons,\n            text=\"Open Document\",\n            command=self.open_selected_document\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            preview_buttons,\n            text=\"Remove from Index\",\n            command=self.remove_selected_document\n        ).pack(side=tk.LEFT, padx=5)\n        \n    def refresh_stats(self):\n        \"\"\"Refresh memory statistics\"\"\"\n        # Get stats from memory system\n        stats = self.memory_system.get_stats()\n        \n        # Update UI\n        self.doc_count_var.set(str(stats[\"documents_count\"]))\n        self.last_updated_var.set(stats[\"last_updated\"] or \"Never\")\n        self.index_path_var.set(stats[\"index_path\"])\n        \n        # Update document tree\n        self._update_document_tree(stats)\n        \n    def _update_document_tree(self, stats):\n        \"\"\"\n        Update the document tree with current index contents\n        \n        Args:\n            stats: Memory system statistics\n        \"\"\"\n        # Clear the current tree\n        for item in self.docs_tree.get_children():\n            self.docs_tree.delete(item)\n            \n        # Group documents by source\n        sources = {}\n        for doc in self.memory_system.documents:\n            source = doc.get(\"source\", \"Unknown\")\n            file_type = os.path.splitext(source)[1] if \".\" in source else \"Unknown\"\n            timestamp = doc.get(\"timestamp\", \"Unknown\")\n            \n            if source in sources:\n                sources[source][\"count\"] += 1\n                # Keep the most recent timestamp\n                if timestamp > sources[source][\"timestamp\"]:\n                    sources[source][\"timestamp\"] = timestamp\n            else:\n                sources[source] = {\n                    \"type\": file_type,\n                    \"count\": 1,\n                    \"timestamp\": timestamp\n                }\n                \n        # Add to tree\n        for source, info in sources.items():\n            self.docs_tree.insert(\n                \"\",\n                tk.END,\n                values=(\n                    source,\n                    info[\"type\"],\n                    info[\"count\"],\n                    info[\"timestamp\"]\n                )\n            )\n            \n    def on_document_selected(self, event):\n        \"\"\"Handle document selection in tree\"\"\"\n        selection = self.docs_tree.selection()\n        if not selection:\n            return\n            \n        # Get document info\n        item = selection[0]\n        values = self.docs_tree.item(item, \"values\")\n        source = values[0]\n        \n        # Find all chunks for this source\n        chunks = []\n        for doc in self.memory_system.documents:\n            if doc.get(\"source\") == source:\n                chunks.append(doc)\n                \n        if not chunks:\n            return\n            \n        # Take the first chunk as preview\n        preview = chunks[0].get(\"text\", \"\")\n        \n        # Limit preview length\n        if len(preview) > 1000:\n            preview = preview[:1000] + \"...\"\n            \n        # Update preview text\n        self.preview_text.delete(1.0, tk.END)\n        self.preview_text.insert(tk.END, preview)\n        \n    def load_files(self):\n        \"\"\"Load files into memory\"\"\"\n        # Get list of supported extensions\n        extensions = self.file_ops.get_supported_extensions()\n        \n        # Create file type string for dialog\n        file_types = [(\"Supported Files\", \" \".join(f\"*{ext}\" for ext in extensions))]\n        for ext in extensions:\n            content_types = self.file_ops.get_content_types()\n            desc = content_types.get(ext, ext[1:].upper() + \" Files\")\n            file_types.append((desc, f\"*{ext}\"))\n        \n        # Open file dialog\n        files = filedialog.askopenfilenames(\n            title=\"Select files to load\",\n            filetypes=file_types\n        )\n        \n        if not files:\n            return\n            \n        # Show progress dialog\n        progress_window = tk.Toplevel(self.frame)\n        progress_window.title(\"Loading Files\")\n        progress_window.geometry(\"300x150\")\n        progress_window.transient(self.frame)\n        progress_window.grab_set()\n        \n        ttk.Label(\n            progress_window,\n            text=\"Loading files into memory...\",\n            font=(\"Helvetica\", 10, \"bold\")\n        ).pack(pady=10)\n        \n        progress_var = tk.DoubleVar()\n        progress_bar = ttk.Progressbar(\n            progress_window,\n            variable=progress_var,\n            maximum=len(files)\n        )\n        progress_bar.pack(fill=tk.X, padx=20, pady=10)\n        \n        status_var = tk.StringVar(value=\"Starting...\")\n        status_label = ttk.Label(\n            progress_window,\n            textvariable=status_var\n        )\n        status_label.pack(pady=10)\n        \n        # Load files in a separate thread\n        def load_thread():\n            successful = 0\n            for i, file_path in enumerate(files):\n                # Update progress\n                progress_var.set(i)\n                filename = os.path.basename(file_path)\n                status_var.set(f\"Loading {filename}...\")\n                progress_window.update()\n                \n                # Use our enhanced memory handler which routes PDFs through enhanced processing\n                if self.enhanced_memory.add_file_to_memory(file_path):\n                    successful += 1\n                    self.log(f\"[Loaded] {filename}\")\n                else:\n                    self.log(f\"[Error] Failed to load {file_path}\")\n                    \n            # Finish up\n            progress_var.set(len(files))\n            status_var.set(\"Complete\")\n            progress_window.update()\n            \n            # Save the index\n            self.memory_system.save_index()\n            \n            # Refresh stats\n            self.refresh_stats()\n            \n            # Close the progress window after a short delay\n            progress_window.after(1000, progress_window.destroy)\n            \n            # Show confirmation\n            messagebox.showinfo(\n                \"Files Loaded\", \n                f\"Successfully loaded {successful} of {len(files)} files into memory.\"\n            )\n            \n        threading.Thread(target=load_thread, daemon=True).start()\n        \n    def load_folder(self):\n        \"\"\"Load all files from a folder into memory\"\"\"\n        # Open folder dialog\n        folder = filedialog.askdirectory(\n            title=\"Select folder to load\"\n        )\n        \n        if not folder:\n            return\n            \n        # Get list of supported extensions\n        extensions = self.file_ops.get_supported_extensions()\n        \n        # Use our enhanced memory handler to process the folder\n        # Create progress window\n        progress_window = tk.Toplevel(self.parent)\n        progress_window.title(\"Loading Files\")\n        progress_window.geometry(\"400x150\")\n        progress_window.transient(self.parent)\n        progress_window.grab_set()\n        \n        # Progress variables\n        progress_var = tk.IntVar(value=0)\n        status_var = tk.StringVar(value=\"Finding files...\")\n        \n        # Progress UI\n        ttk.Label(progress_window, text=\"Loading files into memory...\").pack(pady=10)\n        ttk.Progressbar(progress_window, variable=progress_var, maximum=100).pack(fill=tk.X, padx=20, pady=5)\n        ttk.Label(progress_window, textvariable=status_var).pack(pady=5)\n        \n        def load_thread():\n            # Find all supported files in the folder\n            files = []\n            for ext in extensions:\n                files.extend(self.file_ops.get_files_by_type(folder, ext))\n                \n            if not files:\n                progress_window.destroy()\n                messagebox.showinfo(\n                    \"No Files Found\",\n                    f\"No supported files found in {folder}\"\n                )\n                return\n                \n            # Set maximum value for progress bar\n            progress_window.nametowidget(progress_window.winfo_children()[1]).config(maximum=len(files))\n            \n            # Process each file with our enhanced handler\n            successful = 0\n            for i, file_path in enumerate(files):\n                status_var.set(f\"Loading {os.path.basename(file_path)}\")\n                progress_var.set(i)\n                progress_window.update()\n                \n                # Use our enhanced memory handler which routes PDFs through enhanced processing\n                if self.enhanced_memory.add_file_to_memory(file_path):\n                    successful += 1\n                    self.log(f\"[Loaded] {os.path.basename(file_path)}\")\n                else:\n                    self.log(f\"[Error] Failed to load {file_path}\")\n                    \n            # Finish up\n            progress_var.set(len(files))\n            status_var.set(\"Complete\")\n            progress_window.update()\n            \n            # Save the index\n            self.memory_system.save_index()\n            \n            # Refresh stats\n            self.refresh_stats()\n            \n            # Close the progress window after a short delay\n            progress_window.after(1000, progress_window.destroy)\n            \n            # Show confirmation\n            messagebox.showinfo(\n                \"Files Loaded\", \n                f\"Successfully loaded {successful} of {len(files)} files into memory.\"\n            )\n            \n        threading.Thread(target=load_thread, daemon=True).start()\n        \n    def clear_index(self):\n        \"\"\"Clear the memory index\"\"\"\n        # Confirm action\n        result = messagebox.askyesno(\n            \"Clear Index\",\n            \"Are you sure you want to clear the entire memory index? This cannot be undone.\",\n            icon=messagebox.WARNING\n        )\n        \n        if not result:\n            return\n            \n        # Clear the index\n        success = self.memory_system.clear_index()\n        \n        if success:\n            # Refresh stats\n            self.refresh_stats()\n            \n            # Clear preview\n            self.preview_text.delete(1.0, tk.END)\n            \n            # Show confirmation\n            messagebox.showinfo(\n                \"Index Cleared\",\n                \"Memory index has been cleared.\"\n            )\n        else:\n            messagebox.showerror(\n                \"Error\",\n                \"Failed to clear memory index.\"\n            )\n            \n    def save_index(self):\n        \"\"\"Save the memory index\"\"\"\n        # Save the index\n        success = self.memory_system.save_index()\n        \n        if success:\n            # Show confirmation\n            messagebox.showinfo(\n                \"Index Saved\",\n                f\"Memory index has been saved to {self.memory_system.index_path}\"\n            )\n        else:\n            messagebox.showerror(\n                \"Error\",\n                \"Failed to save memory index.\"\n            )\n            \n    def on_memory_mode_changed(self, event):\n        \"\"\"Handle memory mode changes\"\"\"\n        mode = self.memory_mode_var.get()\n        \n        # Update chat engine\n        self.chat_engine.set_memory_mode(mode)\n        \n        # Update description\n        self.mode_desc_var.set(self._get_mode_description(mode))\n        \n    def _get_mode_description(self, mode):\n        \"\"\"\n        Get description for a memory mode\n        \n        Args:\n            mode: Memory mode\n            \n        Returns:\n            Description text\n        \"\"\"\n        descriptions = {\n            \"Off\": \"Memory not used for responses\",\n            \"Manual\": \"Manual search only\",\n            \"Auto\": \"Automatically adds context to prompts\",\n            \"Background\": \"Silently adds context to all prompts\"\n        }\n        \n        return descriptions.get(mode, \"\")\n        \n    def search_memory(self, event=None):\n        \"\"\"Search the memory index\"\"\"\n        query = self.search_entry.get().strip()\n        if not query:\n            return\n            \n        # Get result count\n        try:\n            count = int(self.results_count_var.get())\n        except ValueError:\n            count = 5\n            \n        # Clear previous results\n        self.results_text.delete(1.0, tk.END)\n        self.results_text.insert(tk.END, f\"Searching for: {query}\\n\\n\", \"heading\")\n        \n        # Perform search\n        results = self.memory_system.search(query, top_k=count)\n        \n        if not results:\n            self.results_text.insert(tk.END, \"No results found.\\n\", \"content\")\n            return\n            \n        # Display results\n        for i, result in enumerate(results):\n            source = result.get(\"source\", \"Unknown\")\n            score = result.get(\"score\", 0.0)\n            text = result.get(\"text\", \"\")\n            \n            # Limit text length\n            if len(text) > 300:\n                text = text[:300] + \"...\"\n                \n            # Add result header\n            self.results_text.insert(tk.END, f\"Result {i+1}: \", \"heading\")\n            self.results_text.insert(tk.END, f\"{source}\\n\", \"source\")\n            self.results_text.insert(tk.END, f\"Relevance: {score:.2f}\\n\", \"score\")\n            self.results_text.insert(tk.END, f\"{text}\\n\\n\", \"content\")\n            \n    def open_selected_document(self):\n        \"\"\"Open the selected document\"\"\"\n        selection = self.docs_tree.selection()\n        if not selection:\n            return\n            \n        # Get document info\n        item = selection[0]\n        values = self.docs_tree.item(item, \"values\")\n        source = values[0]\n        \n        # Find path for this source\n        path = None\n        for doc in self.memory_system.documents:\n            if doc.get(\"source\") == source and \"path\" in doc:\n                path = doc[\"path\"]\n                break\n                \n        if not path or not os.path.exists(path):\n            messagebox.showerror(\n                \"Error\",\n                f\"Cannot find original file for {source}\"\n            )\n            return\n            \n        # Open the file using system default application\n        import subprocess\n        import sys\n        import os\n        \n        try:\n            if os.name == 'nt':  # Windows\n                os.startfile(path)\n            elif os.name == 'posix':  # macOS, Linux\n                subprocess.run(['open' if sys.platform == 'darwin' else 'xdg-open', path])\n                \n            self.log(f\"[Opened] {path}\")\n        except Exception as e:\n            self.log(f\"[Error] Cannot open file: {e}\")\n            messagebox.showerror(\"Error\", f\"Cannot open file: {e}\")\n            \n    def remove_selected_document(self):\n        \"\"\"Remove the selected document from memory\"\"\"\n        selected = self.docs_tree.selection()\n        if not selected:\n            return\n            \n        # Confirm deletion\n        response = messagebox.askyesno(\n            \"Confirm Removal\",\n            \"Are you sure you want to remove the selected document(s) from memory?\",\n            icon=\"warning\"\n        )\n        \n        if not response:\n            return\n            \n        # Process each selected item\n        for item_id in selected:\n            # Get the full path for the selected item\n            parent_id = self.docs_tree.parent(item_id)\n            \n            # Only process leaf nodes (actual documents, not categories)\n            if not self.docs_tree.get_children(item_id):\n                # Get the document ID from the item\n                doc_id = self.docs_tree.item(item_id, \"text\")\n                source = doc_id\n                \n                # If it's a child node, combine with parent to get full source\n                if parent_id:\n                    source = self.docs_tree.item(parent_id, \"text\") + \"/\" + doc_id\n                \n                # Remove from memory system\n                if self.memory_system.remove_document(source):\n                    self.log(f\"[Memory] Removed document: {source}\")\n                else:\n                    self.log(f\"[Memory Error] Failed to remove document: {source}\")\n                    \n        # Save changes and refresh view\n        self.memory_system.save_index()\n        self.refresh_stats()\n        \n    def view_document_info(self):\n        \"\"\"View detailed information about the selected document\"\"\"\n        selected = self.docs_tree.selection()\n        if not selected:\n            return\n            \n        # Get the selected item\n        item_id = selected[0]\n        \n        # Get the full path for the selected item\n        parent_id = self.docs_tree.parent(item_id)\n        \n        # Only process leaf nodes (actual documents, not categories)\n        if not self.docs_tree.get_children(item_id):\n            # Get the document ID from the item\n            doc_id = self.docs_tree.item(item_id, \"text\")\n            source = doc_id\n            \n            # If it's a child node, combine with parent to get full source\n            if parent_id:\n                source = self.docs_tree.item(parent_id, \"text\") + \"/\" + doc_id\n                \n            # Find document in memory system\n            doc_info = None\n            for doc in self.memory_system.documents:\n                if doc.get(\"source\") == source:\n                    doc_info = doc\n                    break\n                    \n            if doc_info:\n                # Show document info in a dialog\n                info_text = f\"Source: {doc_info.get('source', 'Unknown')}\\n\"\n                info_text += f\"Type: {doc_info.get('type', 'Unknown')}\\n\"\n                info_text += f\"Chunks: {doc_info.get('chunks', 0)}\\n\"\n                info_text += f\"Timestamp: {doc_info.get('timestamp', 'Unknown')}\\n\"\n                \n                if \"metadata\" in doc_info:\n                    info_text += \"\\nMetadata:\\n\"\n                    for key, value in doc_info[\"metadata\"].items():\n                        info_text += f\"  {key}: {value}\\n\"\n                \n                # Show the info\n                messagebox.showinfo(\"Document Information\", info_text)\n            else:\n                messagebox.showinfo(\"Document Information\", f\"No detailed information found for: {source}\")\n                \n    def register_plugin_extension(self, plugin_id, plugin):\n        \"\"\"\n        Register plugin extensions for the memory panel\n        \n        Args:\n            plugin_id: Plugin identifier\n            plugin: Plugin instance\n        \"\"\"\n        # Skip if plugin doesn't have memory extensions\n        if not hasattr(plugin, \"get_memory_extensions\"):\n            return\n            \n        try:\n            # Get extensions from plugin\n            extensions = plugin.get_memory_extensions()\n            \n            if not extensions or not isinstance(extensions, dict):\n                return\n                \n            # Register document importers\n            if \"importers\" in extensions and isinstance(extensions[\"importers\"], dict):\n                for name, importer_func in extensions[\"importers\"].items():\n                    if callable(importer_func):\n                        self.plugin_importers[f\"{plugin_id}.{name}\"] = importer_func\n                \n            # Register memory processors\n            if \"processors\" in extensions and isinstance(extensions[\"processors\"], dict):\n                for processor_name, processor_func in extensions[\"processors\"].items():\n                    if callable(processor_func):\n                        self.plugin_processors[f\"{plugin_id}.{processor_name}\"] = processor_func\n                        \n            # Register document exporters\n            if \"exporters\" in extensions and isinstance(extensions[\"exporters\"], dict):\n                for exporter_name, exporter_func in extensions[\"exporters\"].items():\n                    if callable(exporter_func):\n                        self.plugin_exporters[f\"{plugin_id}.{exporter_name}\"] = exporter_func\n            \n            # Register UI extensions\n            if \"ui_extensions\" in extensions and isinstance(extensions[\"ui_extensions\"], list):\n                self.add_plugin_ui_extensions(plugin_id, extensions[\"ui_extensions\"])\n                \n            # Update UI to reflect new extensions            \n            self.update_plugin_menus()\n            \n            self.log(f\"[Memory] Registered extensions from plugin: {plugin_id}\")\n            \n        except Exception as e:\n            self.log(f\"[Memory] Error registering extensions from plugin {plugin_id}: {e}\")\n\n    def unregister_plugin_extension(self, plugin_id):\n        \"\"\"\n        Unregister plugin extensions\n        \n        Args:\n            plugin_id: Plugin identifier\n        \"\"\"\n        # Remove importers\n        importers_to_remove = [k for k in self.plugin_importers if k.startswith(f\"{plugin_id}.\")]\n        for importer_id in importers_to_remove:\n            del self.plugin_importers[importer_id]\n        \n        # Remove processors\n        processors_to_remove = [k for k in self.plugin_processors if k.startswith(f\"{plugin_id}.\")]\n        for processor_id in processors_to_remove:\n            del self.plugin_processors[processor_id]\n        \n        # Remove exporters\n        exporters_to_remove = [k for k in self.plugin_exporters if k.startswith(f\"{plugin_id}.\")]\n        for exporter_id in exporters_to_remove:\n            del self.plugin_exporters[exporter_id]\n        \n        # Remove UI extensions\n        if plugin_id in self.plugin_ui_extensions:\n            for extension in self.plugin_ui_extensions[plugin_id]:\n                if extension.winfo_exists():\n                    extension.destroy()\n            del self.plugin_ui_extensions[plugin_id]\n        \n        # Update UI to reflect removed extensions\n        self.update_plugin_menus()\n        \n        # Hide plugin frame if no more extensions\n        if not any(self.plugin_ui_extensions.values()) and self.plugin_frame.winfo_ismapped():\n            self.plugin_frame.pack_forget()\n            \n        self.log(f\"[Memory] Unregistered extensions from plugin: {plugin_id}\")\n\n    def add_plugin_ui_extensions(self, plugin_id, extensions):\n        \"\"\"\n        Add plugin UI extensions to the memory panel\n        \n        Args:\n            plugin_id: Plugin identifier\n            extensions: List of UI extension widgets\n        \"\"\"\n        # Skip if no extensions\n        if not extensions:\n            return\n            \n        # Create container for this plugin if needed\n        if plugin_id not in self.plugin_ui_extensions:\n            self.plugin_ui_extensions[plugin_id] = []\n        \n        # Add each extension\n        for extension in extensions:\n            if isinstance(extension, tk.Widget):\n                # Add to plugin frame\n                extension.pack(in_=self.plugin_frame, fill=tk.X, padx=5, pady=2)\n                \n                # Add to our tracking list\n                self.plugin_ui_extensions[plugin_id].append(extension)\n        \n        # Show the plugin frame if not already visible\n        if not self.plugin_frame.winfo_ismapped() and any(self.plugin_ui_extensions.values()):\n            self.plugin_frame.pack(fill=tk.X, padx=10, pady=10, before=self.frame.winfo_children()[1])\n\n    def on_plugin_activated(self, plugin_id, plugin_instance):\n        \"\"\"\n        Handle plugin activation event\n        \n        Args:\n            plugin_id: ID of activated plugin\n            plugin_instance: Plugin instance\n        \"\"\"\n        # Register memory extensions for newly activated plugin\n        self.register_plugin_extension(plugin_id, plugin_instance)\n\n    def on_plugin_deactivated(self, plugin_id):\n        \"\"\"\n        Handle plugin deactivation event\n        \n        Args:\n            plugin_id: ID of deactivated plugin\n        \"\"\"\n        # Unregister memory extensions\n        self.unregister_plugin_extension(plugin_id)\n\n    def on_plugin_unloaded(self, plugin_id):\n        \"\"\"\n        Handle plugin unloading event\n        \n        Args:\n            plugin_id: ID of unloaded plugin\n        \"\"\"\n        # Ensure extensions are unregistered\n        self.unregister_plugin_extension(plugin_id)\n        \n    def run_plugin_importer(self, importer_id):\n        \"\"\"\n        Run a plugin importer\n        \n        Args:\n            importer_id: ID of the importer to run\n        \"\"\"\n        if importer_id not in self.plugin_importers:\n            messagebox.showerror(\"Error\", f\"Importer {importer_id} not found\")\n            return\n            \n        try:\n            # Get the importer function\n            importer_func = self.plugin_importers[importer_id]\n            \n            # Run the importer - should return a dictionary with at least:\n            # - 'content': The text content to index\n            # - 'source': Source name for the content\n            # May also include:\n            # - 'metadata': Additional metadata dict\n            import_result = importer_func(self.window)\n            \n            if not import_result:\n                # User probably cancelled\n                return\n                \n            if not isinstance(import_result, dict) or 'content' not in import_result or 'source' not in import_result:\n                messagebox.showerror(\"Import Error\", \"Invalid data returned by importer\")\n                return\n                \n            # Get the content and source\n            content = import_result['content']\n            source = import_result['source']\n            metadata = import_result.get('metadata', {})\n            \n            if not content.strip():\n                messagebox.showinfo(\"Import\", \"No content to import\")\n                return\n                \n            # Add to memory\n            success = self.memory_system.add_text_to_index(content, source, metadata)\n            \n            if success:\n                # Refresh stats\n                self.refresh_stats()\n                \n                # Show confirmation\n                messagebox.showinfo(\n                    \"Import Complete\",\n                    f\"Successfully imported content from {source}\"\n                )\n                \n                self.log(f\"[Memory] Imported content from {source}\")\n            else:\n                messagebox.showerror(\n                    \"Import Error\",\n                    \"Failed to import content\"\n                )\n                \n        except Exception as e:\n            messagebox.showerror(\"Import Error\", str(e))\n            self.log(f\"[Memory] Error during import: {e}\")\n\n    def run_plugin_exporter(self, exporter_id):\n        \"\"\"\n        Run a plugin exporter\n        \n        Args:\n            exporter_id: ID of the exporter to run\n        \"\"\"\n        if exporter_id not in self.plugin_exporters:\n            messagebox.showerror(\"Error\", f\"Exporter {exporter_id} not found\")\n            return\n            \n        try:\n            # Get the exporter function\n            exporter_func = self.plugin_exporters[exporter_id]\n            \n            # Run the exporter with access to memory system and parent window\n            result = exporter_func(self.memory_system, self.window)\n            \n            # Show result if provided\n            if result and isinstance(result, str):\n                messagebox.showinfo(\"Export Complete\", result)\n                \n            self.log(f\"[Memory] Ran exporter {exporter_id}\")\n                \n        except Exception as e:\n            messagebox.showerror(\"Export Error\", str(e))\n            self.log(f\"[Memory] Error during export: {e}\")\n\n    def import_clipboard(self):\n        \"\"\"Import text from clipboard\"\"\"\n        # Get clipboard content\n        clipboard_text = self.frame.clipboard_get()\n        \n        if not clipboard_text.strip():\n            messagebox.showinfo(\"Import\", \"Clipboard is empty\")\n            return\n            \n        # Show source dialog\n        source = tk.simpledialog.askstring(\n            \"Import from Clipboard\",\n            \"Enter source name for this content:\",\n            parent=self.frame\n        )\n        \n        if not source:\n            return\n            \n        # Add to memory\n        success = self.memory_system.add_text_to_index(clipboard_text, source)\n        \n        if success:\n            # Refresh stats\n            self.refresh_stats()\n            \n            # Show confirmation\n            messagebox.showinfo(\n                \"Import Complete\",\n                f\"Successfully imported clipboard content as '{source}'\"\n            )\n        else:\n            messagebox.showerror(\n                \"Import Error\",\n                \"Failed to import clipboard content\"\n            )\n\n    def import_url(self):\n        \"\"\"Import content from a URL\"\"\"\n        import requests\n        from bs4 import BeautifulSoup\n        \n        # Show URL dialog\n        url = tk.simpledialog.askstring(\n            \"Import from URL\",\n            \"Enter URL to import:\",\n            parent=self.frame\n        )\n        \n        if not url:\n            return\n            \n        # Add http:// if missing\n        if not url.startswith(\"http\"):\n            url = \"https://\" + url\n            \n        try:\n            # Show progress dialog\n            progress_window = tk.Toplevel(self.frame)\n            progress_window.title(\"Loading URL\")\n            progress_window.geometry(\"300x100\")\n            progress_window.transient(self.frame)\n            progress_window.grab_set()\n            \n            ttk.Label(\n                progress_window,\n                text=f\"Loading content from:\\n{url}\",\n                wraplength=280\n            ).pack(pady=10)\n            \n            progress_bar = ttk.Progressbar(\n                progress_window,\n                mode=\"indeterminate\"\n            )\n            progress_bar.pack(fill=tk.X, padx=20, pady=10)\n            progress_bar.start(10)\n            progress_window.update()\n            \n            # Function to load in background\n            def load_url():\n                try:\n                    # Fetch URL content\n                    response = requests.get(url, timeout=15)\n                    response.raise_for_status()\n                    \n                    # Parse HTML\n                    soup = BeautifulSoup(response.content, 'html.parser')\n                    \n                    # Get text content\n                    content = soup.get_text(separator='\\n', strip=True)\n                    \n                    # Get title as source name\n                    title = soup.title.string if soup.title else url\n                    \n                    # Add to memory\n                    success = self.memory_system.add_text_to_index(\n                        content, \n                        title,\n                        {\"url\": url, \"source_type\": \"web_page\"}\n                    )\n                    \n                    # Close progress window\n                    progress_window.destroy()\n                    \n                    if success:\n                        # Refresh stats\n                        self.refresh_stats()\n                        \n                        # Show confirmation\n                        messagebox.showinfo(\n                            \"Import Complete\",\n                            f\"Successfully imported content from {title}\"\n                        )\n                        \n                        self.log(f\"[Memory] Imported URL: {url}\")\n                    else:\n                        messagebox.showerror(\n                            \"Import Error\",\n                            \"Failed to import URL content\"\n                        )\n                except Exception as e:\n                    # Close progress window\n                    progress_window.destroy()\n                    messagebox.showerror(\"Import Error\", str(e))\n                    self.log(f\"[Memory] Error importing URL: {e}\")\n                    \n            threading.Thread(target=load_url, daemon=True).start()\n            \n        except Exception as e:\n            messagebox.showerror(\"Import Error\", str(e))\n            self.log(f\"[Memory] Error importing URL: {e}\")\n\n    def export_metadata(self):\n        \"\"\"Export memory index metadata\"\"\"\n        # Open file dialog\n        filename = filedialog.asksaveasfilename(\n            title=\"Export Memory Metadata\",\n            defaultextension=\".json\",\n            filetypes=[(\"JSON Files\", \"*.json\"), (\"All Files\", \"*.*\")]\n        )\n        \n        if not filename:\n            return\n            \n        try:\n            import json\n            \n            # Get metadata\n            metadata = {\n                \"index_path\": self.memory_system.index_path,\n                \"document_count\": len(self.memory_system.documents),\n                \"last_updated\": self.memory_system.last_updated,\n                \"sources\": {}\n            }\n            \n            # Group documents by source\n            for doc in self.memory_system.documents:\n                source = doc.get(\"source\", \"Unknown\")\n                if source in metadata[\"sources\"]:\n                    metadata[\"sources\"][source][\"chunk_count\"] += 1\n                else:\n                    metadata[\"sources\"][source] = {\n                        \"chunk_count\": 1,\n                        \"file_type\": os.path.splitext(source)[1] if \".\" in source else \"Unknown\",\n                        \"timestamp\": doc.get(\"timestamp\", \"Unknown\")\n                    }\n            \n            # Save to file\n            with open(filename, \"w\", encoding=\"utf-8\") as f:\n                json.dump(metadata, f, indent=2)\n                \n            messagebox.showinfo(\n                \"Export Complete\",\n                f\"Memory index metadata exported to {filename}\"\n            )\n            \n        except Exception as e:\n            messagebox.showerror(\"Export Error\", str(e))\n            self.log(f\"[Memory] Error exporting metadata: {e}\")\n            \n    import os  # Import needed for path operations\n\n    def clear_memory_index(self):\n        \"\"\"Clear the entire memory index after confirmation\"\"\"\n        # Ask for confirmation before clearing\n        response = messagebox.askyesno(\n            \"Confirm Clear Memory\",\n            \"Are you sure you want to clear the entire memory index?\\n\\nThis will remove all documents and cannot be undone.\",\n            icon=\"warning\"\n        )\n        \n        if response:\n            # Clear the index\n            self.memory_system.clear_index()\n            self.log(\"[Memory] Memory index cleared\")\n            \n            # Refresh stats\n            self.refresh_stats()\n            \n            messagebox.showinfo(\n                \"Memory Cleared\",\n                \"Memory index has been cleared successfully.\"\n            )\n            \n    def set_memory_mode(self):\n        \"\"\"Set the memory mode based on the selected radio button\"\"\"\n        mode = self.memory_mode_var.get()\n        \n        if mode == \"off\":\n            self.chat_engine.set_memory_mode(False)\n            self.log(\"[Memory Mode] Set to: Off\")\n        elif mode == \"manual\":\n            self.chat_engine.set_memory_mode(True, auto=False, background=False)\n            self.log(\"[Memory Mode] Set to: Manual\")\n        elif mode == \"auto\":\n            self.chat_engine.set_memory_mode(True, auto=True, background=False)\n            self.log(\"[Memory Mode] Set to: Auto\")\n        elif mode == \"background\":\n            self.chat_engine.set_memory_mode(True, auto=True, background=True)\n            self.log(\"[Memory Mode] Set to: Background\")\n            \n    def create_tree_context_menu(self):\n        \"\"\"Create context menu for the document tree\"\"\"\n        # Create a popup menu\n        self.tree_menu = tk.Menu(self.frame, tearoff=0)\n        self.tree_menu.add_command(label=\"Remove from Memory\", command=self.remove_selected_document)\n        self.tree_menu.add_command(label=\"View Document Info\", command=self.view_document_info)\n        self.tree_menu.add_separator()\n        self.tree_menu.add_command(label=\"Refresh List\", command=self.refresh_stats)\n        \n        # Bind right-click to show menu\n        self.docs_tree.bind(\"<Button-3>\", self.show_tree_menu)\n        \n    def show_tree_menu(self, event):\n        \"\"\"Show the context menu on right-click\"\"\"\n        # Get the item that was clicked on\n        item = self.docs_tree.identify_row(event.y)\n        if item:\n            # Select the item\n            self.docs_tree.selection_set(item)\n            # Show the menu\n            self.tree_menu.post(event.x_root, event.y_root)\n            \n    def remove_selected_document(self):\n        \"\"\"Remove the selected document from memory\"\"\"\n        selected = self.docs_tree.selection()\n        if not selected:\n            return\n            \n        # Confirm deletion\n        response = messagebox.askyesno(\n            \"Confirm Removal\",\n            \"Are you sure you want to remove the selected document(s) from memory?\",\n            icon=\"warning\"\n        )\n        \n        if not response:\n            return\n            \n        # Process each selected item\n        for item_id in selected:\n            # Get the full path for the selected item\n            parent_id = self.docs_tree.parent(item_id)\n            \n            # Only process leaf nodes (actual documents, not categories)\n            if not self.docs_tree.get_children(item_id):\n                # Get the document ID from the item\n                doc_id = self.docs_tree.item(item_id, \"text\")\n                source = doc_id\n                \n                # If it's a child node, combine with parent to get full source\n                if parent_id:\n                    source = self.docs_tree.item(parent_id, \"text\") + \"/\" + doc_id\n                \n                # Remove from memory system\n                if self.memory_system.remove_document(source):\n                    self.log(f\"[Memory] Removed document: {source}\")\n                else:\n                    self.log(f\"[Memory Error] Failed to remove document: {source}\")\n                    \n        # Save changes and refresh view\n        self.memory_system.save_index()\n        self.refresh_stats()\n        \n    def view_document_info(self):\n        \"\"\"View detailed information about the selected document\"\"\"\n        selected = self.docs_tree.selection()\n        if not selected:\n            return\n            \n        # Get the selected item\n        item_id = selected[0]\n        \n        # Get the full path for the selected item\n        parent_id = self.docs_tree.parent(item_id)\n        \n        # Only process leaf nodes (actual documents, not categories)\n        if not self.docs_tree.get_children(item_id):\n            # Get the document ID from the item\n            doc_id = self.docs_tree.item(item_id, \"text\")\n            source = doc_id\n            \n            # If it's a child node, combine with parent to get full source\n            if parent_id:\n                source = self.docs_tree.item(parent_id, \"text\") + \"/\" + doc_id\n                \n            # Find document in memory system\n            doc_info = None\n            for doc in self.memory_system.documents:\n                if doc.get(\"source\") == source:\n                    doc_info = doc\n                    break\n                    \n            if doc_info:\n                # Show document info in a dialog\n                info_text = f\"Source: {doc_info.get('source', 'Unknown')}\\n\"\n                info_text += f\"Type: {doc_info.get('type', 'Unknown')}\\n\"\n                info_text += f\"Chunks: {doc_info.get('chunks', 0)}\\n\"\n                info_text += f\"Timestamp: {doc_info.get('timestamp', 'Unknown')}\\n\"\n                \n                if \"metadata\" in doc_info:\n                    info_text += \"\\nMetadata:\\n\"\n                    for key, value in doc_info[\"metadata\"].items():\n                        info_text += f\"  {key}: {value}\\n\"\n                \n                # Show the info\n                messagebox.showinfo(\"Document Information\", info_text)\n            else:\n                messagebox.showinfo(\"Document Information\", f\"No detailed information found for: {source}\")\n                \n    def _on_ocr_setting_changed(self, value):\n        \"\"\"Handler for when OCR setting changes in unified settings panel\"\"\"\n        # Update the enhanced memory handler with new OCR setting\n        self.enhanced_memory = enhance_memory_system(self.memory_system, self.file_ops, enable_ocr=value)\n        self.log(f\"[Memory] OCR for PDF processing: {'Enabled' if value else 'Disabled'}\")",
  "D:\\AI\\IrintAI Assistant\\ui\\dashboard.py": "\"\"\"\nDashboard UI component for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, scrolledtext\nimport time\nimport datetime\nimport os\nimport sys\nfrom typing import Dict, List, Any, Optional, Callable\n\nclass Dashboard:\n    \"\"\"Dashboard for displaying session statistics and system information\"\"\"\n    \n    def __init__(self, parent, chat_engine, model_manager, memory_system, system_monitor, logger: Callable):\n        \"\"\"\n        Initialize the dashboard\n        \n        Args:\n            parent: Parent widget\n            chat_engine: ChatEngine instance\n            model_manager: ModelManager instance\n            memory_system: MemorySystem instance\n            system_monitor: SystemMonitor instance\n            logger: Logging function\n        \"\"\"\n        self.parent = parent\n        self.chat_engine = chat_engine\n        self.model_manager = model_manager\n        self.memory_system = memory_system\n        self.system_monitor = system_monitor\n        self.log = logger\n        \n        # Create top-level window\n        self.window = tk.Toplevel(parent)\n        self.window.title(\"Irintai Dashboard\")\n        self.window.geometry(\"800x600\")\n        self.window.minsize(600, 400)\n        \n        # Initialize UI components\n        self.initialize_ui()\n        \n        # Initialize plugin extensions\n        self.initialize_plugin_extensions()\n        \n        # Update statistics\n        self.update_statistics()\n        \n        # Schedule periodic updates\n        self.schedule_updates()\n        \n    def initialize_ui(self):\n        \"\"\"Initialize the UI components\"\"\"\n        # Create notebook for tabbed interface\n        self.notebook = ttk.Notebook(self.window)\n        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create overview tab\n        self.create_overview_tab()\n        \n        # Create chat statistics tab\n        self.create_chat_stats_tab()\n        \n        # Create system information tab\n        self.create_system_info_tab()\n        \n        # Create memory statistics tab\n        self.create_memory_stats_tab()\n        \n        # Create status bar\n        self.status_var = tk.StringVar(value=\"Ready\")\n        status_bar = ttk.Label(\n            self.window, \n            textvariable=self.status_var, \n            relief=tk.SUNKEN, \n            anchor=tk.W\n        )\n        status_bar.pack(side=tk.BOTTOM, fill=tk.X)\n        \n        # Add refresh button\n        refresh_button = ttk.Button(\n            self.window,\n            text=\"Refresh Stats\",\n            command=self.update_statistics\n        )\n        refresh_button.pack(side=tk.BOTTOM, pady=5)\n        \n    def create_overview_tab(self):\n        \"\"\"Create the overview tab\"\"\"\n        overview_frame = ttk.Frame(self.notebook)\n        self.notebook.add(overview_frame, text=\"Overview\")\n        \n        # Add header\n        ttk.Label(\n            overview_frame, \n            text=\"Session Overview\", \n            font=(\"Helvetica\", 16, \"bold\")\n        ).pack(pady=10)\n        \n        # Create stats grid\n        stats_frame = ttk.Frame(overview_frame)\n        stats_frame.pack(fill=tk.X, padx=20, pady=10)\n        \n        # Configure grid columns\n        for i in range(2):\n            stats_frame.columnconfigure(i, weight=1)\n            \n        # Row 1: Total interactions\n        ttk.Label(\n            stats_frame, \n            text=\"Total Interactions:\", \n            font=(\"Helvetica\", 12)\n        ).grid(row=0, column=0, sticky=tk.W, padx=10, pady=5)\n        \n        self.total_interactions_var = tk.StringVar(value=\"0\")\n        ttk.Label(\n            stats_frame, \n            textvariable=self.total_interactions_var,\n            font=(\"Helvetica\", 12, \"bold\"),\n            foreground=\"blue\"\n        ).grid(row=0, column=1, sticky=tk.W, padx=10, pady=5)\n        \n        # Row 2: Current model\n        ttk.Label(\n            stats_frame, \n            text=\"Current Model:\", \n            font=(\"Helvetica\", 12)\n        ).grid(row=1, column=0, sticky=tk.W, padx=10, pady=5)\n        \n        self.current_model_var = tk.StringVar(value=\"None\")\n        ttk.Label(\n            stats_frame, \n            textvariable=self.current_model_var,\n            font=(\"Helvetica\", 12, \"bold\")\n        ).grid(row=1, column=1, sticky=tk.W, padx=10, pady=5)\n        \n        # Row 3: Memory mode\n        ttk.Label(\n            stats_frame, \n            text=\"Memory Mode:\", \n            font=(\"Helvetica\", 12)\n        ).grid(row=2, column=0, sticky=tk.W, padx=10, pady=5)\n        \n        self.memory_mode_var = tk.StringVar(value=\"Off\")\n        ttk.Label(\n            stats_frame, \n            textvariable=self.memory_mode_var,\n            font=(\"Helvetica\", 12)\n        ).grid(row=2, column=1, sticky=tk.W, padx=10, pady=5)\n        \n        # Row 4: Vector store size\n        ttk.Label(\n            stats_frame, \n            text=\"Vector Store:\", \n            font=(\"Helvetica\", 12)\n        ).grid(row=3, column=0, sticky=tk.W, padx=10, pady=5)\n        \n        self.vector_store_var = tk.StringVar(value=\"0 documents\")\n        ttk.Label(\n            stats_frame, \n            textvariable=self.vector_store_var,\n            font=(\"Helvetica\", 12)\n        ).grid(row=3, column=1, sticky=tk.W, padx=10, pady=5)\n        \n        # Performance frame\n        perf_frame = ttk.LabelFrame(overview_frame, text=\"System Performance\")\n        perf_frame.pack(fill=tk.X, padx=20, pady=10)\n        \n        # CPU usage\n        cpu_frame = ttk.Frame(perf_frame)\n        cpu_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Label(cpu_frame, text=\"CPU Usage:\").pack(side=tk.LEFT, padx=5)\n        \n        self.cpu_var = tk.StringVar(value=\"0%\")\n        ttk.Label(\n            cpu_frame, \n            textvariable=self.cpu_var,\n            width=8\n        ).pack(side=tk.LEFT, padx=5)\n        \n        self.cpu_progress = ttk.Progressbar(\n            cpu_frame, \n            length=200,\n            mode=\"determinate\",\n            maximum=100\n        )\n        self.cpu_progress.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)\n        \n        # RAM usage\n        ram_frame = ttk.Frame(perf_frame)\n        ram_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Label(ram_frame, text=\"RAM Usage:\").pack(side=tk.LEFT, padx=5)\n        \n        self.ram_var = tk.StringVar(value=\"0%\")\n        ttk.Label(\n            ram_frame, \n            textvariable=self.ram_var,\n            width=8\n        ).pack(side=tk.LEFT, padx=5)\n        \n        self.ram_progress = ttk.Progressbar(\n            ram_frame, \n            length=200,\n            mode=\"determinate\",\n            maximum=100\n        )\n        self.ram_progress.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)\n        \n        # GPU usage (if available)\n        gpu_frame = ttk.Frame(perf_frame)\n        gpu_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Label(gpu_frame, text=\"GPU Usage:\").pack(side=tk.LEFT, padx=5)\n        \n        self.gpu_var = tk.StringVar(value=\"N/A\")\n        ttk.Label(\n            gpu_frame, \n            textvariable=self.gpu_var,\n            width=8\n        ).pack(side=tk.LEFT, padx=5)\n        \n        self.gpu_progress = ttk.Progressbar(\n            gpu_frame, \n            length=200,\n            mode=\"determinate\",\n            maximum=100\n        )\n        self.gpu_progress.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)\n        \n        # Disk usage\n        disk_frame = ttk.Frame(perf_frame)\n        disk_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Label(disk_frame, text=\"Disk Space:\").pack(side=tk.LEFT, padx=5)\n        \n        self.disk_var = tk.StringVar(value=\"0 GB free\")\n        ttk.Label(\n            disk_frame, \n            textvariable=self.disk_var,\n            width=15\n        ).pack(side=tk.LEFT)\n        \n        # Recent activity section\n        activity_frame = ttk.LabelFrame(overview_frame, text=\"Recent Activity\")\n        activity_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)\n        \n        # Timeline of recent messages\n        self.activity_text = scrolledtext.ScrolledText(\n            activity_frame,\n            wrap=tk.WORD,\n            height=6,\n            font=(\"Helvetica\", 9)\n        )\n        self.activity_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Configure text tags\n        self.activity_text.tag_configure(\"timestamp\", foreground=\"gray\", font=(\"Helvetica\", 9, \"italic\"))\n        self.activity_text.tag_configure(\"user\", foreground=\"blue\", font=(\"Helvetica\", 9, \"bold\"))\n        self.activity_text.tag_configure(\"assistant\", foreground=\"green\", font=(\"Helvetica\", 9, \"bold\"))\n        self.activity_text.tag_configure(\"system\", foreground=\"purple\", font=(\"Helvetica\", 9, \"bold\"))\n        \n    def create_chat_stats_tab(self):\n        \"\"\"Create the chat statistics tab\"\"\"\n        chat_frame = ttk.Frame(self.notebook)\n        self.notebook.add(chat_frame, text=\"Chat Stats\")\n        \n        # Conversation analysis\n        analysis_frame = ttk.LabelFrame(chat_frame, text=\"Conversation Analysis\")\n        analysis_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Message counts\n        counts_frame = ttk.Frame(analysis_frame)\n        counts_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        # Create a grid for counts\n        for i in range(2):\n            counts_frame.columnconfigure(i, weight=1)\n            \n        # Row 1: User messages\n        ttk.Label(counts_frame, text=\"User Messages:\").grid(row=0, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.user_count_var = tk.StringVar(value=\"0\")\n        ttk.Label(counts_frame, textvariable=self.user_count_var, font=(\"Helvetica\", 10, \"bold\")).grid(row=0, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 2: Assistant messages\n        ttk.Label(counts_frame, text=\"Assistant Responses:\").grid(row=1, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.assistant_count_var = tk.StringVar(value=\"0\")\n        ttk.Label(counts_frame, textvariable=self.assistant_count_var, font=(\"Helvetica\", 10, \"bold\")).grid(row=1, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 3: Avg response length\n        ttk.Label(counts_frame, text=\"Avg Response Length:\").grid(row=2, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.avg_length_var = tk.StringVar(value=\"0 chars\")\n        ttk.Label(counts_frame, textvariable=self.avg_length_var, font=(\"Helvetica\", 10)).grid(row=2, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 4: Session duration\n        ttk.Label(counts_frame, text=\"Session Duration:\").grid(row=3, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.duration_var = tk.StringVar(value=\"0 minutes\")\n        ttk.Label(counts_frame, textvariable=self.duration_var, font=(\"Helvetica\", 10)).grid(row=3, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Models used section\n        models_frame = ttk.LabelFrame(chat_frame, text=\"Models Used\")\n        models_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create a tree view for models\n        columns = (\"Model\", \"Responses\", \"Last Used\")\n        self.models_tree = ttk.Treeview(\n            models_frame,\n            columns=columns,\n            show=\"headings\",\n            selectmode=\"browse\",\n            height=5\n        )\n        \n        # Configure columns\n        self.models_tree.heading(\"Model\", text=\"Model Name\")\n        self.models_tree.heading(\"Responses\", text=\"Responses\")\n        self.models_tree.heading(\"Last Used\", text=\"Last Used\")\n        \n        self.models_tree.column(\"Model\", width=250, anchor=tk.W)\n        self.models_tree.column(\"Responses\", width=100, anchor=tk.CENTER)\n        self.models_tree.column(\"Last Used\", width=150, anchor=tk.CENTER)\n        \n        # Add scrollbar\n        models_scrollbar = ttk.Scrollbar(models_frame, orient=\"vertical\", command=self.models_tree.yview)\n        self.models_tree.configure(yscrollcommand=models_scrollbar.set)\n        \n        # Pack the tree and scrollbar\n        self.models_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        models_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n    def create_system_info_tab(self):\n        \"\"\"Create the system information tab\"\"\"\n        system_frame = ttk.Frame(self.notebook)\n        self.notebook.add(system_frame, text=\"System Info\")\n        \n        # System information section\n        info_frame = ttk.LabelFrame(system_frame, text=\"System Information\")\n        info_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Create a grid for info\n        info_grid = ttk.Frame(info_frame)\n        info_grid.pack(fill=tk.X, padx=10, pady=5)\n        \n        for i in range(2):\n            info_grid.columnconfigure(i, weight=1)\n            \n        # Row 1: OS info\n        ttk.Label(info_grid, text=\"Operating System:\").grid(row=0, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.os_info_var = tk.StringVar(value=\"Unknown\")\n        ttk.Label(info_grid, textvariable=self.os_info_var).grid(row=0, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 2: Python version\n        ttk.Label(info_grid, text=\"Python Version:\").grid(row=1, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.python_var = tk.StringVar(value=f\"Python {sys.version.split()[0]}\")\n        ttk.Label(info_grid, textvariable=self.python_var).grid(row=1, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 3: CPU info\n        ttk.Label(info_grid, text=\"CPU:\").grid(row=2, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.cpu_info_var = tk.StringVar(value=\"Unknown\")\n        ttk.Label(info_grid, textvariable=self.cpu_info_var).grid(row=2, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 4: RAM info\n        ttk.Label(info_grid, text=\"RAM:\").grid(row=3, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.ram_info_var = tk.StringVar(value=\"Unknown\")\n        ttk.Label(info_grid, textvariable=self.ram_info_var).grid(row=3, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 5: GPU info\n        ttk.Label(info_grid, text=\"GPU:\").grid(row=4, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.gpu_info_var = tk.StringVar(value=\"Unknown\")\n        ttk.Label(info_grid, textvariable=self.gpu_info_var).grid(row=4, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Path information section\n        paths_frame = ttk.LabelFrame(system_frame, text=\"Path Information\")\n        paths_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        paths_grid = ttk.Frame(paths_frame)\n        paths_grid.pack(fill=tk.X, padx=10, pady=5)\n        \n        for i in range(2):\n            paths_grid.columnconfigure(i, weight=1)\n            \n        # Row 1: Model path\n        ttk.Label(paths_grid, text=\"Model Path:\").grid(row=0, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.model_path_var = tk.StringVar(value=self.model_manager.model_path)\n        ttk.Label(paths_grid, textvariable=self.model_path_var).grid(row=0, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 2: Log path\n        ttk.Label(paths_grid, text=\"Log Path:\").grid(row=1, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.log_path_var = tk.StringVar(value=\"data/logs\")\n        ttk.Label(paths_grid, textvariable=self.log_path_var).grid(row=1, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 3: Vector store path\n        ttk.Label(paths_grid, text=\"Vector Store Path:\").grid(row=2, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.vector_path_var = tk.StringVar(value=self.memory_system.index_path)\n        ttk.Label(paths_grid, textvariable=self.vector_path_var).grid(row=2, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Process information section\n        process_frame = ttk.LabelFrame(system_frame, text=\"Process Information\")\n        process_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create process info text area\n        self.process_text = scrolledtext.ScrolledText(\n            process_frame,\n            wrap=tk.WORD,\n            height=10,\n            font=(\"Courier New\", 9)\n        )\n        self.process_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n    def create_memory_stats_tab(self):\n        \"\"\"Create the memory statistics tab\"\"\"\n        memory_frame = ttk.Frame(self.notebook)\n        self.notebook.add(memory_frame, text=\"Memory Stats\")\n        \n        # Memory statistics section\n        stats_frame = ttk.LabelFrame(memory_frame, text=\"Vector Store Statistics\")\n        stats_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Stats grid\n        grid_frame = ttk.Frame(stats_frame)\n        grid_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        for i in range(2):\n            grid_frame.columnconfigure(i, weight=1)\n            \n        # Row 1: Document count\n        ttk.Label(grid_frame, text=\"Total Documents:\").grid(row=0, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.doc_count_var = tk.StringVar(value=\"0\")\n        ttk.Label(grid_frame, textvariable=self.doc_count_var, font=(\"Helvetica\", 10, \"bold\")).grid(row=0, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 2: Unique sources\n        ttk.Label(grid_frame, text=\"Unique Sources:\").grid(row=1, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.source_count_var = tk.StringVar(value=\"0\")\n        ttk.Label(grid_frame, textvariable=self.source_count_var).grid(row=1, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 3: Embedding model\n        ttk.Label(grid_frame, text=\"Embedding Model:\").grid(row=2, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.embedding_model_var = tk.StringVar(value=self.memory_system.model_name)\n        ttk.Label(grid_frame, textvariable=self.embedding_model_var).grid(row=2, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Row 4: Last updated\n        ttk.Label(grid_frame, text=\"Last Updated:\").grid(row=3, column=0, sticky=tk.W, padx=10, pady=2)\n        \n        self.last_updated_var = tk.StringVar(value=\"Unknown\")\n        ttk.Label(grid_frame, textvariable=self.last_updated_var).grid(row=3, column=1, sticky=tk.W, padx=10, pady=2)\n        \n        # Source breakdown section\n        sources_frame = ttk.LabelFrame(memory_frame, text=\"Source Types\")\n        sources_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create a tree view for source types\n        columns = (\"Type\", \"Count\", \"Percentage\")\n        self.sources_tree = ttk.Treeview(\n            sources_frame,\n            columns=columns,\n            show=\"headings\",\n            selectmode=\"browse\",\n            height=6\n        )\n        \n        # Configure columns\n        self.sources_tree.heading(\"Type\", text=\"File Type\")\n        self.sources_tree.heading(\"Count\", text=\"Count\")\n        self.sources_tree.heading(\"Percentage\", text=\"Percentage\")\n        \n        self.sources_tree.column(\"Type\", width=100, anchor=tk.W)\n        self.sources_tree.column(\"Count\", width=100, anchor=tk.CENTER)\n        self.sources_tree.column(\"Percentage\", width=100, anchor=tk.CENTER)\n        \n        # Add scrollbar\n        sources_scrollbar = ttk.Scrollbar(sources_frame, orient=\"vertical\", command=self.sources_tree.yview)\n        self.sources_tree.configure(yscrollcommand=sources_scrollbar.set)\n        \n        # Pack the tree and scrollbar\n        self.sources_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        sources_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        # Add recent searches section\n        searches_frame = ttk.LabelFrame(memory_frame, text=\"Recent Memory Searches\")\n        searches_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create searches listbox\n        self.searches_listbox = tk.Listbox(\n            searches_frame,\n            height=5,\n            font=(\"Helvetica\", 9)\n        )\n        self.searches_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        # Add scrollbar\n        searches_scrollbar = ttk.Scrollbar(searches_frame, orient=\"vertical\", command=self.searches_listbox.yview)\n        self.searches_listbox.configure(yscrollcommand=searches_scrollbar.set)\n        searches_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n    def update_statistics(self):\n        \"\"\"Update all statistics in the dashboard\"\"\"\n        # Update session statistics\n        self.update_session_stats()\n        \n        # Update system information\n        self.update_system_info()\n        \n        # Update memory statistics\n        self.update_memory_stats()\n        \n        # Update plugin statistics\n        self.update_plugin_stats()\n        \n        # Update status\n        self.status_var.set(f\"Statistics updated at {time.strftime('%H:%M:%S')}\")\n        \n    def update_plugin_stats(self):\n        \"\"\"Update statistics from plugin providers\"\"\"\n        # Skip if no providers registered\n        if not hasattr(self, \"plugin_stats_providers\") or not self.plugin_stats_providers:\n            return\n            \n        # Call each provider and process the stats\n        for plugin_id, provider in self.plugin_stats_providers.items():\n            try:\n                # Get statistics from plugin\n                stats = provider()\n                \n                # Skip if no stats provided\n                if not stats or not isinstance(stats, dict):\n                    continue\n                    \n                # Update the plugin's dashboard if it has one\n                if plugin_id in self.plugin_dashboards:\n                    component = self.plugin_dashboards[plugin_id][\"component\"]\n                    if hasattr(component, \"update_stats\") and callable(component.update_stats):\n                        component.update_stats(stats)\n                        \n            except Exception as e:\n                self.log(f\"[Dashboard] Error updating stats for plugin {plugin_id}: {e}\")\n\n    def update_session_stats(self):\n        \"\"\"Update session statistics\"\"\"\n        # Get chat history\n        history = self.chat_engine.chat_history\n        \n        # Count messages by role\n        user_count = sum(1 for msg in history if msg.get(\"role\") == \"user\")\n        assistant_count = sum(1 for msg in history if msg.get(\"role\") == \"assistant\")\n        \n        # Update counts\n        self.total_interactions_var.set(str(len(history)))\n        self.user_count_var.set(str(user_count))\n        self.assistant_count_var.set(str(assistant_count))\n        \n        # Get current model\n        current_model = self.model_manager.current_model or \"None\"\n        self.current_model_var.set(current_model)\n        \n        # Get memory mode\n        memory_mode = self.chat_engine.memory_mode\n        self.memory_mode_var.set(memory_mode)\n        \n        # Calculate average response length\n        if assistant_count > 0:\n            total_length = sum(len(msg.get(\"content\", \"\")) for msg in history if msg.get(\"role\") == \"assistant\")\n            avg_length = total_length / assistant_count\n            self.avg_length_var.set(f\"{int(avg_length)} chars\")\n        else:\n            self.avg_length_var.set(\"N/A\")\n            \n        # Calculate session duration if timestamps are available\n        if history and \"timestamp\" in history[0] and \"timestamp\" in history[-1]:\n            try:\n                start_time = datetime.datetime.strptime(history[0][\"timestamp\"], \"%Y-%m-%d %H:%M:%S\")\n                end_time = datetime.datetime.strptime(history[-1][\"timestamp\"], \"%Y-%m-%d %H:%M:%S\")\n                duration = end_time - start_time\n                minutes = duration.total_seconds() / 60\n                self.duration_var.set(f\"{int(minutes)} minutes\")\n            except (ValueError, TypeError, KeyError):\n                self.duration_var.set(\"Unknown\")\n        else:\n            self.duration_var.set(\"Unknown\")\n            \n        # Update models used tree\n        self.update_models_used()\n        \n        # Update timeline\n        self.update_timeline()\n        \n    def update_models_used(self):\n        \"\"\"Update the models used tree\"\"\"\n        # Clear the current tree\n        for item in self.models_tree.get_children():\n            self.models_tree.delete(item)\n            \n        # Count responses by model\n        model_counts = {}\n        model_last_used = {}\n        \n        for msg in self.chat_engine.chat_history:\n            if msg.get(\"role\") == \"assistant\" and \"model\" in msg:\n                model = msg[\"model\"]\n                model_counts[model] = model_counts.get(model, 0) + 1\n                model_last_used[model] = msg.get(\"timestamp\", \"Unknown\")\n                \n        # Add to tree\n        for model, count in model_counts.items():\n            last_used = model_last_used[model]\n            self.models_tree.insert(\n                \"\",\n                tk.END,\n                values=(model, count, last_used)\n            )\n            \n    def update_timeline(self):\n        \"\"\"Update the timeline of recent activity\"\"\"\n        # Clear the current timeline\n        self.activity_text.delete(1.0, tk.END)\n        \n        # Get the most recent messages (up to 10)\n        recent = self.chat_engine.chat_history[-min(10, len(self.chat_engine.chat_history)):]\n        \n        # Add each message to the timeline\n        for msg in recent:\n            role = msg.get(\"role\", \"\")\n            content = msg.get(\"content\", \"\")\n            timestamp = msg.get(\"timestamp\", \"\")\n            \n            # Limit content length for display\n            if len(content) > 100:\n                content = content[:100] + \"...\"\n                \n            if timestamp:\n                self.activity_text.insert(tk.END, f\"[{timestamp}] \", \"timestamp\")\n                \n            if role == \"user\":\n                self.activity_text.insert(tk.END, \"User: \", \"user\")\n                self.activity_text.insert(tk.END, f\"{content}\\n\\n\")\n            elif role == \"assistant\":\n                self.activity_text.insert(tk.END, \"Irintai: \", \"assistant\")\n                self.activity_text.insert(tk.END, f\"{content}\\n\\n\")\n            else:\n                self.activity_text.insert(tk.END, f\"{role}: {content}\\n\\n\")\n                \n    def update_system_info(self):\n        \"\"\"Update system information\"\"\"\n        # Get system information\n        info = self.system_monitor.get_system_info()\n        \n        # Update performance values\n        cpu_percent = info[\"cpu\"][\"usage_percent\"]\n        self.cpu_var.set(f\"{cpu_percent}%\")\n        self.cpu_progress[\"value\"] = cpu_percent\n        \n        ram_percent = info[\"ram\"][\"usage_percent\"]\n        self.ram_var.set(f\"{ram_percent}%\")\n        self.ram_progress[\"value\"] = ram_percent\n        \n        gpu_percent = info[\"gpu\"][\"usage_percent\"]\n        self.gpu_var.set(gpu_percent)\n        \n        if gpu_percent != \"N/A\":\n            try:\n                gpu_value = int(gpu_percent.replace(\"%\", \"\"))\n                self.gpu_progress[\"value\"] = gpu_value\n            except (ValueError, TypeError):\n                self.gpu_progress[\"value\"] = 0\n                \n        # Update disk space\n        free_space = info[\"disk\"][\"free_gb\"]\n        total_space = info[\"disk\"][\"total_gb\"]\n        self.disk_var.set(f\"{free_space} GB free of {total_space} GB\")\n        \n        # Get OS information\n        import platform\n        os_info = f\"{platform.system()} {platform.release()}\"\n        self.os_info_var.set(os_info)\n        \n        # Get CPU information\n        import psutil\n        try:\n            cpu_info = f\"{psutil.cpu_count(logical=False)} cores, {psutil.cpu_count()} threads\"\n        except:\n            cpu_info = f\"{psutil.cpu_count()} logical processors\"\n        self.cpu_info_var.set(cpu_info)\n        \n        # Get RAM information\n        ram_total = round(psutil.virtual_memory().total / (1024**3), 2)\n        self.ram_info_var.set(f\"{ram_total} GB\")\n        \n        # Get GPU information\n        gpu_info = \"Not available\"\n        if gpu_percent != \"N/A\":\n            gpu_info = info[\"gpu\"][\"memory\"]\n        self.gpu_info_var.set(gpu_info)\n        \n        # Update process information\n        self.update_process_info()\n        \n    def update_process_info(self):\n        \"\"\"Update process information\"\"\"\n        import psutil\n        \n        # Clear current text\n        self.process_text.delete(1.0, tk.END)\n        \n        # Add process information for current process\n        current_process = psutil.Process()\n        \n        # Add header\n        self.process_text.insert(tk.END, \"=== Irintai Process Information ===\\n\\n\")\n        \n        # Process details\n        pid = current_process.pid\n        memory_info = current_process.memory_info()\n        cpu_percent = current_process.cpu_percent()\n        create_time = datetime.datetime.fromtimestamp(current_process.create_time()).strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        self.process_text.insert(tk.END, f\"PID: {pid}\\n\")\n        self.process_text.insert(tk.END, f\"Started: {create_time}\\n\")\n        self.process_text.insert(tk.END, f\"CPU Usage: {cpu_percent}%\\n\")\n        self.process_text.insert(tk.END, f\"Memory Usage: {memory_info.rss / (1024**2):.2f} MB\\n\\n\")\n        \n        # Add Ollama process info if running\n        if self.model_manager.model_process and self.model_manager.model_process.poll() is None:\n            # Get PID from subprocess\n            ollama_pid = self.model_manager.model_process.pid\n            \n            try:\n                ollama_process = psutil.Process(ollama_pid)\n                \n                # Add header\n                self.process_text.insert(tk.END, \"=== Ollama Process Information ===\\n\\n\")\n                \n                # Process details\n                ollama_memory = ollama_process.memory_info()\n                ollama_cpu = ollama_process.cpu_percent()\n                ollama_create_time = datetime.datetime.fromtimestamp(ollama_process.create_time()).strftime(\"%Y-%m-%d %H:%M:%S\")\n                \n                self.process_text.insert(tk.END, f\"PID: {ollama_pid}\\n\")\n                self.process_text.insert(tk.END, f\"Started: {ollama_create_time}\\n\")\n                self.process_text.insert(tk.END, f\"CPU Usage: {ollama_cpu}%\\n\")\n                self.process_text.insert(tk.END, f\"Memory Usage: {ollama_memory.rss / (1024**2):.2f} MB\\n\")\n                \n                # Get current model\n                model_name = self.model_manager.current_model\n                if model_name:\n                    self.process_text.insert(tk.END, f\"Running Model: {model_name}\\n\")\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                self.process_text.insert(tk.END, \"Could not access Ollama process information.\\n\")\n                \n    def update_memory_stats(self):\n        \"\"\"Update memory statistics\"\"\"\n        # Get memory system stats\n        stats = self.memory_system.get_stats()\n        \n        # Update document count\n        doc_count = stats[\"documents_count\"]\n        self.doc_count_var.set(str(doc_count))\n        self.vector_store_var.set(f\"{doc_count} documents\")\n        \n        # Update last updated\n        last_updated = stats[\"last_updated\"] or \"Never\"\n        self.last_updated_var.set(last_updated)\n        \n        # Count unique sources\n        sources = set()\n        source_types = {}\n        \n        for doc in self.memory_system.documents:\n            source = doc.get(\"source\", \"Unknown\")\n            sources.add(source)\n            \n            # Get file extension\n            ext = os.path.splitext(source)[1].lower() if \".\" in source else \"unknown\"\n            source_types[ext] = source_types.get(ext, 0) + 1\n            \n        # Update unique sources count\n        self.source_count_var.set(str(len(sources)))\n        \n        # Update sources tree\n        self.update_sources_tree(source_types, doc_count)\n        \n        # Add recent searches (placeholder - would need to track searches)\n        self.searches_listbox.delete(0, tk.END)\n        \n    def update_sources_tree(self, source_types, total_count):\n        \"\"\"\n        Update the sources tree with file type breakdown\n        \n        Args:\n            source_types: Dictionary of file types and counts\n            total_count: Total document count\n        \"\"\"\n        # Clear the current tree\n        for item in self.sources_tree.get_children():\n            self.sources_tree.delete(item)\n            \n        # Add each file type\n        for ext, count in source_types.items():\n            # Calculate percentage\n            percentage = (count / total_count) * 100 if total_count > 0 else 0\n            \n            # Add to tree\n            self.sources_tree.insert(\n                \"\",\n                tk.END,\n                values=(ext, count, f\"{percentage:.1f}%\")\n            )\n            \n    def schedule_updates(self):\n        \"\"\"Schedule periodic updates\"\"\"\n        if self.window.winfo_exists():\n            # Update system info every 5 seconds\n            self.update_system_info()\n            \n            # Update plugin stats at their own rates\n            self.update_plugin_refresh_timers()\n            \n            # Schedule next system refresh\n            self.window.after(5000, self.schedule_updates)\n            \n    def update_plugin_refresh_timers(self):\n        \"\"\"Update plugin statistics based on their refresh rates\"\"\"\n        if not hasattr(self, \"plugin_extensions\") or not self.plugin_extensions:\n            return\n            \n        current_time = time.time()\n        \n        # Initialize last refresh time tracker if not exists\n        if not hasattr(self, \"last_plugin_refresh\"):\n            self.last_plugin_refresh = {}\n            \n        # Check each plugin extension\n        for plugin_id, extension in self.plugin_extensions.items():\n            # Get refresh rate (default to 10 seconds)\n            refresh_rate = extension.get(\"refresh_rate\", 10)\n            last_refresh = self.last_plugin_refresh.get(plugin_id, 0)\n            \n            # If it's time to refresh this plugin's stats\n            if current_time - last_refresh >= refresh_rate:\n                # Update last refresh time\n                self.last_plugin_refresh[plugin_id] = current_time\n                \n                # If plugin has a stats provider, call it\n                if plugin_id in self.plugin_stats_providers:\n                    try:\n                        stats = self.plugin_stats_providers[plugin_id]()\n                        \n                        # Update dashboard component if available\n                        if plugin_id in self.plugin_dashboards:\n                            component = self.plugin_dashboards[plugin_id][\"component\"]\n                            if hasattr(component, \"update_stats\") and callable(component.update_stats):\n                                component.update_stats(stats)\n                    except Exception as e:\n                        self.log(f\"[Dashboard] Error refreshing stats for plugin {plugin_id}: {e}\")\n\n    def initialize_plugin_extensions(self):\n        \"\"\"Initialize extensions for plugins in the dashboard\"\"\"\n        # Dictionary of registered plugin extensions\n        self.plugin_extensions = {}\n        \n        # Create plugins tab to contain plugin-specific dashboards\n        self.create_plugins_tab()\n        \n        # Register with plugin manager if available\n        if hasattr(self.parent, \"plugin_manager\"):\n            plugin_manager = self.parent.plugin_manager\n            \n            # Register for plugin events\n            plugin_manager.register_event_handler(\"dashboard\", \"plugin_activated\", \n                                                 self.on_plugin_activated)\n            plugin_manager.register_event_handler(\"dashboard\", \"plugin_deactivated\", \n                                                 self.on_plugin_deactivated)\n                                                 \n            # Get all active plugins and register them\n            active_plugins = plugin_manager.get_active_plugins()\n            for plugin_id, plugin in active_plugins.items():\n                self.register_plugin_extension(plugin_id, plugin)\n\n    def create_plugins_tab(self):\n        \"\"\"Create a tab for plugin-specific dashboards\"\"\"\n        # Create main plugins tab\n        self.plugins_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.plugins_tab, text=\"Plugins\")\n        \n        # Create notebook for plugin tabs\n        self.plugins_notebook = ttk.Notebook(self.plugins_tab)\n        self.plugins_notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Empty message for when no plugins have dashboards\n        self.no_plugins_label = ttk.Label(\n            self.plugins_notebook, \n            text=\"No plugins with dashboard components are currently active.\",\n            font=(\"Helvetica\", 10, \"italic\")\n        )\n        self.no_plugins_label.pack(pady=50)\n        \n        # Dictionary to track plugin dashboard components\n        self.plugin_dashboards = {}\n        self.plugin_stats_providers = {}\n\n    def register_plugin_extension(self, plugin_id, plugin):\n        \"\"\"\n        Register a plugin extension for the dashboard\n        \n        Args:\n            plugin_id: Plugin identifier\n            plugin: Plugin instance\n        \"\"\"\n        # Skip if plugin doesn't have dashboard extension\n        if not hasattr(plugin, \"get_dashboard_extension\"):\n            return\n            \n        try:\n            # Check if already registered\n            if plugin_id in self.plugin_extensions:\n                return\n                \n            # Get dashboard extension from plugin\n            extension = plugin.get_dashboard_extension(self)\n            \n            if not extension or not isinstance(extension, dict):\n                return\n                \n            # Store extension specification\n            self.plugin_extensions[plugin_id] = extension\n            \n            # Add dashboard tab if provided\n            if \"dashboard_tab\" in extension:\n                self.add_plugin_dashboard_tab(plugin_id, extension[\"dashboard_tab\"])\n                \n            # Register statistics provider if provided\n            if \"stats_provider\" in extension and callable(extension[\"stats_provider\"]):\n                self.plugin_stats_providers[plugin_id] = extension[\"stats_provider\"]\n                \n            # Register overview widgets if provided\n            if \"overview_widgets\" in extension:\n                self.add_plugin_overview_widgets(plugin_id, extension[\"overview_widgets\"])\n                \n            self.log(f\"[Dashboard] Registered extension for plugin: {plugin_id}\")\n            \n        except Exception as e:\n            self.log(f\"[Dashboard] Error registering extension for plugin {plugin_id}: {e}\")\n\n    def unregister_plugin_extension(self, plugin_id):\n        \"\"\"\n        Unregister a plugin extension\n        \n        Args:\n            plugin_id: Plugin identifier\n        \"\"\"\n        if plugin_id not in self.plugin_extensions:\n            return\n            \n        # Remove dashboard tab if present\n        if plugin_id in self.plugin_dashboards:\n            self.remove_plugin_dashboard_tab(plugin_id)\n            \n        # Remove statistics provider if present\n        if plugin_id in self.plugin_stats_providers:\n            del self.plugin_stats_providers[plugin_id]\n            \n        # Remove from extensions dictionary\n        del self.plugin_extensions[plugin_id]\n        \n        self.log(f\"[Dashboard] Unregistered extension for plugin: {plugin_id}\")\n\n    def add_plugin_dashboard_tab(self, plugin_id, dashboard_component):\n        \"\"\"\n        Add a plugin dashboard tab\n        \n        Args:\n            plugin_id: Plugin identifier\n            dashboard_component: Dashboard component to add\n        \"\"\"\n        # Hide the no plugins label if it's visible\n        if self.no_plugins_label.winfo_ismapped():\n            self.no_plugins_label.pack_forget()\n            \n        # Create tab frame\n        tab_frame = ttk.Frame(self.plugins_notebook)\n        \n        # Get plugin metadata\n        plugin_manager = getattr(self.parent, \"plugin_manager\", None)\n        plugin_name = plugin_id.capitalize()\n        \n        if plugin_manager:\n            plugin = plugin_manager.get_plugin_instance(plugin_id)\n            if plugin and hasattr(plugin, \"METADATA\"):\n                plugin_name = plugin.METADATA.get(\"name\", plugin_name)\n        \n        # Add to notebook\n        self.plugins_notebook.add(tab_frame, text=plugin_name)\n        \n        # Add component to frame\n        if isinstance(dashboard_component, tk.Widget):\n            dashboard_component.pack(in_=tab_frame, fill=tk.BOTH, expand=True)\n            \n        # Store reference\n        self.plugin_dashboards[plugin_id] = {\n            \"tab\": tab_frame,\n            \"component\": dashboard_component\n        }\n\n    def remove_plugin_dashboard_tab(self, plugin_id):\n        \"\"\"\n        Remove a plugin dashboard tab\n        \n        Args:\n            plugin_id: Plugin identifier\n        \"\"\"\n        if plugin_id not in self.plugin_dashboards:\n            return\n            \n        # Get tab info\n        tab_info = self.plugin_dashboards[plugin_id]\n        tab_frame = tab_info[\"tab\"]\n        \n        # Remove from notebook\n        tab_index = self.plugins_notebook.index(tab_frame)\n        if tab_index is not None:\n            self.plugins_notebook.forget(tab_index)\n        \n        # Clean up reference\n        del self.plugin_dashboards[plugin_id]\n        \n        # Show no plugins label if no more plugin dashboards\n        if not self.plugin_dashboards and not self.no_plugins_label.winfo_ismapped():\n            self.no_plugins_label.pack(pady=50)\n\n    def add_plugin_overview_widgets(self, plugin_id, widgets):\n        \"\"\"\n        Add plugin widgets to the overview tab\n        \n        Args:\n            plugin_id: Plugin identifier\n            widgets: List of widgets to add\n        \"\"\"\n        if not widgets or not isinstance(widgets, list):\n            return\n            \n        # Create section for plugin widgets if not exists\n        if not hasattr(self, \"plugin_overview_frame\"):\n            # Get the overview frame (first tab)\n            overview_tab = self.notebook.nametowidget(self.notebook.tabs()[0])\n            \n            # Create frame for plugin widgets\n            self.plugin_overview_frame = ttk.LabelFrame(overview_tab, text=\"Plugin Statistics\")\n            self.plugin_overview_frame.pack(fill=tk.X, padx=20, pady=(5, 10), before=overview_tab.winfo_children()[-1])\n            \n        # Add widgets to section\n        for widget in widgets:\n            if isinstance(widget, tk.Widget):\n                widget.pack(in_=self.plugin_overview_frame, fill=tk.X, padx=5, pady=2)\n\n    def on_plugin_activated(self, plugin_id, plugin_instance):\n        \"\"\"\n        Handle plugin activation event\n        \n        Args:\n            plugin_id: ID of activated plugin\n            plugin_instance: Plugin instance\n        \"\"\"\n        # Register dashboard extension for newly activated plugin\n        self.register_plugin_extension(plugin_id, plugin_instance)\n        \n        # Update dashboard with new plugin data\n        self.update_statistics()\n\n    def on_plugin_deactivated(self, plugin_id):\n        \"\"\"\n        Handle plugin deactivation event\n        \n        Args:\n            plugin_id: ID of deactivated plugin\n        \"\"\"\n        # Unregister dashboard extension\n        self.unregister_plugin_extension(plugin_id)\n        \n        # Update dashboard to remove plugin data\n        self.update_statistics()\n\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\core\\ollama_client.py": "\"\"\"\nOllama Client - Direct interface to Ollama API\n\"\"\"\nimport os\nimport subprocess\nimport json\nimport re  # For stripping ANSI escape codes\nfrom typing import Dict, Any, Tuple, Optional, Callable\n\nclass OllamaClient:\n    \"\"\"Provides direct access to Ollama API for generating text responses\"\"\"\n    \n    def __init__(self, logger: Optional[Callable] = None):\n        \"\"\"\n        Initialize the Ollama client\n        \n        Args:\n            logger: Optional logging function\n        \"\"\"\n        self.log = logger or print\n        \n    def generate(self, model: str, prompt: str, params: Dict[str, Any] = None) -> Tuple[bool, str]:\n        \"\"\"\n        Generate a response by invoking Ollama's run subcommand with prompt as argument\n        Strips ANSI escape sequences from model output.\n        \n        Args:\n            model: Model name\n            prompt: The prompt to send\n            params: Optional parameters for generation\n            \n        Returns:\n            Tuple of (success, response)\n        \"\"\"\n        try:\n            # Build command\n            cmd = [\"ollama\", \"run\", model]\n            # Add any parameters\n            if params:\n                for key, value in params.items():\n                    if key in [\"temperature\", \"top_p\", \"top_k\", \"repeat_penalty\", \"context\", \"seed\"]:\n                        cmd.extend([f\"--{key}\", str(value)])\n            # Append the prompt as positional argument\n            cmd.append(prompt)\n            self.log(f\"[Run] Running command: {' '.join(cmd)}\")\n            # Execute command\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                env=os.environ.copy()\n            )\n            # Strip ANSI escape codes from output\n            raw = result.stdout or \"\"\n            clean = re.compile(r'\\x1B[@-_][0-?]*[ -/]*[@-~]')\n            output = clean.sub('', raw).strip()\n            # Handle errors\n            if result.stderr:\n                err = result.stderr.strip()\n                self.log(f\"[Error] Model error: {err}\")\n                return False, err\n            return True, output\n        except Exception as e:\n            self.log(f\"[Error] Failed to generate response: {e}\")\n            return False, f\"Error: {str(e)}\"\n    def list_models(self, remote=False) -> Tuple[bool, Dict[str, Any]]:\n        \"\"\"\n        List models available in Ollama\n        \n        Args:\n            remote: Whether to list remote models (True) or local models (False)\n            \n        Returns:\n            Tuple of (success, model_list_dict)\n        \"\"\"\n        try:\n            # Define command based on whether we're fetching remote or local models\n            if remote:\n                cmd = [\"ollama\", \"list\", \"remote\"]\n                self.log(f\"[Ollama] Listing remote models from Ollama Hub\")\n            else:\n                cmd = [\"ollama\", \"list\"]\n                self.log(f\"[Ollama] Listing locally installed models\")\n            \n            # Add timeout to prevent hanging\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                encoding='utf-8',\n                errors='replace',\n                timeout=30,  # Add a reasonable timeout\n                env=os.environ.copy()\n            )\n            \n            if result.returncode != 0:\n                error_msg = result.stderr.strip()\n                self.log(f\"[Ollama] Error listing {'remote' if remote else 'local'} models: {error_msg}\")\n                \n                # If we get a connection error for remote models, try an alternative command\n                if remote and \"connection refused\" in error_msg.lower():\n                    self.log(\"[Ollama] Connection refused. Checking if Ollama service is running...\")\n                    \n                    # Check Ollama service status\n                    try:\n                        check_result = subprocess.run(\n                            [\"ollama\", \"--version\"],\n                            capture_output=True,\n                            text=True,\n                            timeout=5\n                        )\n                        if check_result.returncode == 0:\n                            self.log(f\"[Ollama] Ollama is installed (version: {check_result.stdout.strip()})\")\n                            self.log(\"[Ollama] But service might not be running. Please start the Ollama service.\")\n                    except Exception as e:\n                        self.log(f\"[Ollama] Error checking Ollama installation: {e}\")\n                \n                return False, {\"error\": error_msg}\n                \n            # Parse the output to get model list\n            # Ollama returns a table-like format, we need to parse it\n            models = []\n            lines = result.stdout.strip().split('\\n')\n            \n            if len(lines) > 1:  # First line is header, skip it\n                header = lines[0].lower()\n                has_tags = \"tags\" in header\n                \n                for line in lines[1:]:\n                    if not line.strip():\n                        continue\n                    \n                    # Split by whitespace but keep quotes together\n                    parts = re.findall(r'(?:[^\\s,\"]|\"(?:\\\\.|[^\"])*\")++', line)\n                    \n                    if len(parts) >= 2:\n                        name = parts[0].strip()\n                        size = parts[1].strip() if len(parts) > 1 else \"Unknown\"\n                        \n                        # Extract parameter info from model name if possible\n                        param_match = re.search(r'(\\d+)b', name, re.IGNORECASE)\n                        parameters = f\"{param_match.group(1)}B\" if param_match else \"\"\n                        \n                        # Extract tags if available\n                        tags = []\n                        if has_tags and len(parts) > 3:\n                            # Tags might be in the last column\n                            potential_tags = parts[-1].strip()\n                            if potential_tags and potential_tags != \"-\":\n                                tags = [tag.strip() for tag in potential_tags.split(\",\")]\n                        \n                        model_info = {\n                            \"name\": name,\n                            \"size\": size,\n                            \"parameters\": parameters,\n                            \"digest\": parts[2] if len(parts) > 2 else \"\",\n                            \"modified\": \" \".join(parts[3:len(parts)-1 if has_tags else None]) if len(parts) > 3 else \"\",\n                            \"tags\": tags\n                        }\n                        \n                        models.append(model_info)\n            self.log(f\"[Ollama] Successfully found {len(models)} {'remote' if remote else 'local'} models\")\n            return True, {\"models\": models}\n            \n        except subprocess.TimeoutExpired:\n            self.log(f\"[Ollama] Timeout while listing {'remote' if remote else 'local'} models\")\n            return False, {\"error\": \"Timeout while listing models. The Ollama service might be slow or not responding.\"}\n        except Exception as e:\n            self.log(f\"[Ollama] Exception listing {'remote' if remote else 'local'} models: {e}\")\n            return False, {\"error\": str(e)}\n            \n        except Exception as e:\n            self.log(f\"[Ollama] Exception listing models: {e}\")\n            return False, {\"error\": str(e)}\n    \n    def pull_model(self, model_name: str, progress_callback=None) -> Tuple[bool, str]:\n        \"\"\"\n        Pull a model from Ollama library\n        \n        Args:\n            model_name: Name of the model to pull\n            progress_callback: Optional callback function to report download progress\n            \n        Returns:\n            Tuple of (success, message)\n        \"\"\"\n        try:\n            cmd = [\"ollama\", \"pull\", model_name]\n            self.log(f\"[Ollama] Pulling model: {model_name}\")\n            \n            # Use Popen to stream output for real-time progress tracking\n            process = subprocess.Popen(\n                cmd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                bufsize=1,\n                universal_newlines=True,\n                env=os.environ.copy()\n            )\n            \n            # Initialize variables\n            success = True\n            error_message = \"\"\n            progress_pattern = re.compile(r'(\\d+\\.\\d+)%')\n            \n            # Process stdout in real-time\n            for line in iter(process.stdout.readline, ''):\n                self.log(f\"[Ollama Pull] {line.strip()}\")\n                \n                # Check for progress indication and call the progress callback if provided\n                if progress_callback and \"%\" in line:\n                    match = progress_pattern.search(line)\n                    if match:\n                        try:\n                            percentage = float(match.group(1))\n                            progress_callback(percentage)\n                        except ValueError:\n                            pass\n            \n            # Process potential errors from stderr\n            for line in iter(process.stderr.readline, ''):\n                line = line.strip()\n                if line:\n                    error_message += line + \"\\n\"\n                    self.log(f\"[Ollama Pull Error] {line}\")\n                    success = False\n            \n            # Wait for process to complete\n            return_code = process.wait()\n            \n            if return_code != 0:\n                self.log(f\"[Ollama] Error pulling model: {error_message}\")\n                return False, error_message or f\"Process exited with return code {return_code}\"\n                \n            return True, \"Model pulled successfully\"\n            \n        except Exception as e:\n            self.log(f\"[Ollama] Exception pulling model: {e}\")\n            return False, str(e)\n    \n    def delete_model(self, model_name: str) -> Tuple[bool, str]:\n        \"\"\"\n        Delete a model from Ollama\n        \n        Args:\n            model_name: Name of the model to delete\n            \n        Returns:\n            Tuple of (success, message)\n        \"\"\"\n        try:\n            cmd = [\"ollama\", \"rm\", model_name]\n            self.log(f\"[Ollama] Deleting model: {model_name}\")\n            \n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                env=os.environ.copy()\n            )\n            \n            if result.returncode != 0:\n                self.log(f\"[Ollama] Error deleting model: {result.stderr}\")\n                return False, result.stderr\n                \n            return True, \"Model deleted successfully\"\n            \n        except Exception as e:\n            self.log(f\"[Ollama] Exception deleting model: {e}\")\n            return False, str(e)\n    \n    def get_model_info(self, model_name: str) -> Tuple[bool, Dict[str, Any]]:\n        \"\"\"\n        Get detailed information about a model\n        \n        Args:\n            model_name: Name of the model\n            \n        Returns:\n            Tuple of (success, model_info)\n        \"\"\"\n        try:\n            cmd = [\"ollama\", \"show\", model_name]\n            self.log(f\"[Ollama] Getting info for model: {model_name}\")\n            \n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                env=os.environ.copy()\n            )\n            \n            if result.returncode != 0:\n                self.log(f\"[Ollama] Error getting model info: {result.stderr}\")\n                return False, {\"error\": result.stderr}\n                \n            # Parse the output\n            info = {}\n            current_section = \"general\"\n            info[current_section] = {}\n            \n            for line in result.stdout.strip().split('\\n'):\n                if not line.strip():\n                    continue\n                    \n                if line.startswith(\"#\"):\n                    # New section header\n                    current_section = line.strip(\"# \").lower()\n                    info[current_section] = {}\n                    continue\n                \n                if \":\" in line:\n                    key, value = line.split(\":\", 1)\n                    info[current_section][key.strip()] = value.strip()\n            \n            return True, info\n            \n        except Exception as e:\n            self.log(f\"[Ollama] Exception getting model info: {e}\")\n            return False, {\"error\": str(e)}\n",
  "D:\\AI\\IrintAI Assistant\\utils\\terminal_utils.py": "\"\"\"\nTerminal utilities for handling escape sequences and other terminal-related functions\n\"\"\"\nimport re\n\n# Regular expression to match ANSI escape sequences\nANSI_ESCAPE_PATTERN = re.compile(r'(\\x1B\\[[0-?]*[ -/]*[@-~]|\\x1B[@-_]|[\\x00-\\x08\\x0B-\\x1F\\x7F])')\n\ndef strip_ansi_codes(text: str) -> str:\n    \"\"\"\n    Remove ANSI escape sequences from text\n    \n    Args:\n        text: Input text that may contain ANSI escape sequences\n        \n    Returns:\n        Clean text with escape sequences removed\n    \"\"\"\n    if not text:\n        return \"\"\n    return ANSI_ESCAPE_PATTERN.sub('', text)\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\ui\\__init__.py": "\"\"\"\nOllama Hub Plugin UI Module\n\nThis package contains user interface components for the Ollama Hub plugin.\n\"\"\"\n\nfrom plugins.ollama_hub.ui.ollama_tab import OllamaHubTab\n\n__all__ = ['OllamaHubTab']",
  "D:\\AI\\IrintAI Assistant\\plugins\\network_monitoring\\core\\network_monitoring.py": "\"\"\"\nNetwork monitor plugin for IrintAI Assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk\nimport time\nimport threading\nimport psutil\nimport json\nimport os\nfrom typing import Dict, Any, Callable, List, Optional\n\nclass IrintaiPlugin:\n    def __init__(self, plugin_id, core_system):\n        self.plugin_id = plugin_id\n        self.core_system = core_system\n        self.log = core_system.logger.log if hasattr(core_system, \"logger\") else print\n        \n        # Initialize plugin data\n        self.network_stats = {\n            \"bytes_sent\": 0,\n            \"bytes_recv\": 0,\n            \"packets_sent\": 0,\n            \"packets_recv\": 0,\n            \"bytes_sent_per_sec\": 0.0,\n            \"bytes_recv_per_sec\": 0.0\n        }\n        \n        # Previous values for calculating rates\n        self.prev_bytes_sent = 0\n        self.prev_bytes_recv = 0\n        self.prev_time = time.time()\n        \n        # Setup monitoring thread\n        self.running = False\n        self.monitor_thread = None\n        \n        # Create UI components\n        self.network_frame = None\n        \n    def activate(self):\n        \"\"\"Activate the plugin\"\"\"\n        self.log(f\"Network Monitor Plugin activated\")\n        \n        # Start monitoring\n        self.start_monitoring()\n        \n        return True\n        \n    def deactivate(self):\n        \"\"\"Deactivate the plugin\"\"\"\n        # Stop monitoring thread\n        self.stop_monitoring()\n        \n        self.log(f\"Network Monitor Plugin deactivated\")\n        return True\n        \n    def get_resource_monitor_extensions(self):\n        \"\"\"\n        Get extensions for the resource monitor panel\n        \n        Returns:\n            Dictionary of resource monitor extensions\n        \"\"\"\n        return {\n            \"metrics\": {\n                \"network_download\": self.get_download_speed,\n                \"network_upload\": self.get_upload_speed\n            },\n            \"ui_components\": [\n                self._create_network_ui()\n            ]\n        }\n        \n    def _create_network_ui(self):\n        \"\"\"\n        Create UI for network monitoring\n        \n        Returns:\n            UI frame component\n        \"\"\"\n        # Create the network frame\n        self.network_frame = ttk.LabelFrame(None, text=\"Network Monitor\")\n        \n        # Add information labels\n        info_frame = ttk.Frame(self.network_frame)\n        info_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Create a grid of labels\n        ttk.Label(info_frame, text=\"Download:\").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)\n        self.download_label = ttk.Label(info_frame, text=\"0.0 KB/s\")\n        self.download_label.grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(info_frame, text=\"Upload:\").grid(row=0, column=2, sticky=tk.W, padx=5, pady=2)\n        self.upload_label = ttk.Label(info_frame, text=\"0.0 KB/s\")\n        self.upload_label.grid(row=0, column=3, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(info_frame, text=\"Total Received:\").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)\n        self.total_recv_label = ttk.Label(info_frame, text=\"0.0 MB\")\n        self.total_recv_label.grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)\n        \n        ttk.Label(info_frame, text=\"Total Sent:\").grid(row=1, column=2, sticky=tk.W, padx=5, pady=2)\n        self.total_sent_label = ttk.Label(info_frame, text=\"0.0 MB\")\n        self.total_sent_label.grid(row=1, column=3, sticky=tk.W, padx=5, pady=2)\n        \n        # Add status indicator\n        status_frame = ttk.Frame(self.network_frame)\n        status_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Label(status_frame, text=\"API Endpoints:\").pack(side=tk.LEFT, padx=5)\n        self.endpoint_status = ttk.Label(status_frame, text=\"OK\", foreground=\"green\")\n        self.endpoint_status.pack(side=tk.LEFT, padx=5)\n        \n        # Add reset button\n        ttk.Button(\n            status_frame,\n            text=\"Reset Stats\",\n            command=self.reset_stats\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        return self.network_frame\n    \n    def start_monitoring(self):\n        \"\"\"Start the network monitoring thread\"\"\"\n        if self.running:\n            return\n            \n        self.running = True\n        self.monitor_thread = threading.Thread(target=self._monitor_thread_func, daemon=True)\n        self.monitor_thread.start()\n        \n        self.log(\"Network monitoring started\")\n    \n    def stop_monitoring(self):\n        \"\"\"Stop the network monitoring thread\"\"\"\n        self.running = False\n        \n        if hasattr(self, 'monitor_thread') and self.monitor_thread:\n            self.monitor_thread.join(timeout=1.0)\n            self.monitor_thread = None\n            \n        self.log(\"Network monitoring stopped\")\n        \n    def reset_stats(self):\n        \"\"\"Reset monitoring statistics\"\"\"\n        # Get current values as new baseline\n        net_stats = psutil.net_io_counters()\n        self.prev_bytes_sent = net_stats.bytes_sent\n        self.prev_bytes_recv = net_stats.bytes_recv\n        self.prev_time = time.time()\n        \n        self.network_stats = {\n            \"bytes_sent\": 0,\n            \"bytes_recv\": 0,\n            \"packets_sent\": 0,\n            \"packets_recv\": 0,\n            \"bytes_sent_per_sec\": 0.0,\n            \"bytes_recv_per_sec\": 0.0\n        }\n        \n        self.log(\"Network monitoring statistics reset\")\n        \n    def _monitor_thread_func(self):\n        \"\"\"Background thread for monitoring network performance\"\"\"\n        # Initialize previous values\n        try:\n            net_stats = psutil.net_io_counters()\n            self.prev_bytes_sent = net_stats.bytes_sent\n            self.prev_bytes_recv = net_stats.bytes_recv\n        except Exception as e:\n            self.log(f\"Error initializing network monitoring: {e}\")\n            self.prev_bytes_sent = 0\n            self.prev_bytes_recv = 0\n            \n        self.prev_time = time.time()\n        \n        while self.running:\n            try:\n                # Get network stats\n                net_stats = psutil.net_io_counters()\n                current_time = time.time()\n                \n                # Calculate rates\n                bytes_sent = net_stats.bytes_sent\n                bytes_recv = net_stats.bytes_recv\n                \n                # Calculate bytes per second\n                time_diff = current_time - self.prev_time\n                if time_diff > 0:\n                    bytes_sent_per_sec = (bytes_sent - self.prev_bytes_sent) / time_diff\n                    bytes_recv_per_sec = (bytes_recv - self.prev_bytes_recv) / time_diff\n                else:\n                    bytes_sent_per_sec = 0\n                    bytes_recv_per_sec = 0\n                    \n                # Update stats\n                self.network_stats[\"bytes_sent\"] = bytes_sent\n                self.network_stats[\"bytes_recv\"] = bytes_recv\n                self.network_stats[\"packets_sent\"] = net_stats.packets_sent\n                self.network_stats[\"packets_recv\"] = net_stats.packets_recv\n                self.network_stats[\"bytes_sent_per_sec\"] = bytes_sent_per_sec\n                self.network_stats[\"bytes_recv_per_sec\"] = bytes_recv_per_sec\n                \n                # Store current values for next iteration\n                self.prev_bytes_sent = bytes_sent\n                self.prev_bytes_recv = bytes_recv\n                self.prev_time = current_time\n                \n                # Update UI\n                self._update_labels()\n                \n                # Check API endpoints periodically\n                if int(current_time) % 10 == 0:  # Every 10 seconds\n                    self._check_endpoints()\n                    \n            except Exception as e:\n                self.log(f\"Error in network monitoring thread: {e}\")\n                \n            time.sleep(1.0)\n    \n    def _update_labels(self):\n        \"\"\"Update the UI labels with current stats\"\"\"\n        if not hasattr(self, 'download_label') or not self.download_label:\n            return\n            \n        # Use after() to safely update from another thread\n        if hasattr(self.download_label, 'after'):\n            self.download_label.after(0, lambda: self._do_update_labels())\n    \n    def _do_update_labels(self):\n        \"\"\"Update labels on the main thread\"\"\"\n        try:\n            # Format download/upload speeds\n            download_speed = self.format_bytes_per_sec(self.network_stats[\"bytes_recv_per_sec\"])\n            upload_speed = self.format_bytes_per_sec(self.network_stats[\"bytes_sent_per_sec\"])\n            \n            # Format total received/sent\n            total_recv = self.format_bytes(self.network_stats[\"bytes_recv\"])\n            total_sent = self.format_bytes(self.network_stats[\"bytes_sent\"])\n            \n            # Update labels\n            self.download_label.config(text=download_speed)\n            self.upload_label.config(text=upload_speed)\n            self.total_recv_label.config(text=total_recv)\n            self.total_sent_label.config(text=total_sent)\n        except Exception:\n            # Widget may have been destroyed\n            pass\n    \n    def _check_endpoints(self):\n        \"\"\"Check API endpoints status\"\"\"\n        # In a real plugin, this would check actual endpoints\n        import random\n        \n        # Simulate endpoint check for demo\n        if random.random() < 0.9:  # 90% chance to be OK\n            if hasattr(self, 'endpoint_status'):\n                self.endpoint_status.after(0, lambda: self.endpoint_status.config(\n                    text=\"OK\", foreground=\"green\"))\n        else:\n            if hasattr(self, 'endpoint_status'):\n                self.endpoint_status.after(0, lambda: self.endpoint_status.config(\n                    text=\"Error\", foreground=\"red\"))\n    \n    def get_download_speed(self):\n        \"\"\"\n        Get network download speed in KB/s\n        \n        Returns:\n            Current download speed in KB/s\n        \"\"\"\n        return self.network_stats[\"bytes_recv_per_sec\"] / 1024.0\n    \n    def get_upload_speed(self):\n        \"\"\"\n        Get network upload speed in KB/s\n        \n        Returns:\n            Current upload speed in KB/s\n        \"\"\"\n        return self.network_stats[\"bytes_sent_per_sec\"] / 1024.0\n    \n    @staticmethod\n    def format_bytes_per_sec(bytes_per_sec):\n        \"\"\"Format bytes per second into human-readable form\"\"\"\n        if bytes_per_sec < 1024:\n            return f\"{bytes_per_sec:.1f} B/s\"\n        elif bytes_per_sec < 1024 * 1024:\n            return f\"{bytes_per_sec/1024:.1f} KB/s\"\n        else:\n            return f\"{bytes_per_sec/(1024*1024):.2f} MB/s\"\n    \n    @staticmethod\n    def format_bytes(bytes_val):\n        \"\"\"Format bytes into human-readable form\"\"\"\n        if bytes_val < 1024:\n            return f\"{bytes_val} B\"\n        elif bytes_val < 1024 * 1024:\n            return f\"{bytes_val/1024:.1f} KB\"\n        elif bytes_val < 1024 * 1024 * 1024:\n            return f\"{bytes_val/(1024*1024):.1f} MB\"\n        else:\n            return f\"{bytes_val/(1024*1024*1024):.2f} GB\"\n\n\n# Plugin metadata\nplugin_info = {\n    \"name\": \"Network Monitor\",\n    \"description\": \"Monitors network traffic and API endpoint status\",\n    \"version\": \"1.0.0\",\n    \"author\": \"Irintai\",\n    \"url\": \"https://example.com/plugins/network_monitor\",\n    \"plugin_class\": IrintaiPlugin,\n    \"compatibility\": \"0.5.0\",\n    \"tags\": [\"network\", \"monitoring\", \"performance\"]\n}",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\core\\ollama_hub_integrator.py": "\"\"\"\nIntegration module for Ollama Hub UI components\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport os\nimport sys\nimport threading\nimport webbrowser\n\ndef integrate_ollama_hub_ui(notebook, plugin_manager, logger):\n    \"\"\"\n    Integrates Ollama Hub UI if the plugin is available and active\n    \n    Args:\n        notebook: The tkinter notebook to add the tab to\n        plugin_manager: The plugin manager instance\n        logger: Logger function to log messages\n    \n    Returns:\n        bool: True if integration was successful, False otherwise\n    \"\"\"\n    # Check if the plugin manager is available\n    if not plugin_manager or not hasattr(plugin_manager, 'get_active_plugins'):\n        logger(\"[Ollama Hub] Plugin manager not available\")\n        return False\n      # Get active plugins (could be a list or a dictionary)\n    active_plugins = plugin_manager.get_active_plugins()\n    ollama_plugin = None\n    \n    # Handle both list and dictionary return types\n    if isinstance(active_plugins, dict):\n        # If it's a dictionary, use the get method\n        ollama_plugin = active_plugins.get('ollama_hub')\n    elif isinstance(active_plugins, list):\n        # If it's a list of plugin names (strings)\n        if 'ollama_hub' in active_plugins:\n            # Get the plugin instance\n            if hasattr(plugin_manager, 'get_plugin_instance'):\n                ollama_plugin = plugin_manager.get_plugin_instance('ollama_hub')\n            elif hasattr(plugin_manager, 'plugins'):\n                # Direct access to plugins dictionary\n                ollama_plugin = plugin_manager.plugins.get('ollama_hub')\n        # If it's a list of plugin objects\n        else:\n            for plugin in active_plugins:\n                if hasattr(plugin, 'plugin_id') and plugin.plugin_id == 'ollama_hub':\n                    ollama_plugin = plugin\n                    break\n    \n    if not ollama_plugin:\n        # Ollama plugin not active, don't add tab\n        logger(\"[Ollama Hub] Plugin not active, skipping UI integration\")\n        return False\n    \n    try:\n        # Check if the plugin provides a UI integration method\n        if hasattr(ollama_plugin, 'get_notebook_frame'):\n            # Create the frame using the plugin's method\n            ollama_frame = ollama_plugin.get_notebook_frame(notebook)\n            \n            if ollama_frame:\n                # Add the frame to the notebook\n                notebook.add(ollama_frame, text=\"Ollama Hub\")\n                logger(\"[Ollama Hub] UI integrated successfully\")\n                return True\n            else:\n                logger(\"[Ollama Hub] Plugin returned empty frame\")\n                return False\n        else:\n            # Create a basic frame with a link to Ollama website\n            ollama_frame = create_basic_ollama_frame(notebook)\n            notebook.add(ollama_frame, text=\"Ollama Hub\")\n            logger(\"[Ollama Hub] Basic UI integrated\")\n            return True\n    \n    except Exception as e:\n        logger(f\"[Ollama Hub] Error integrating UI: {str(e)}\")\n        return False\n\ndef create_basic_ollama_frame(parent):\n    \"\"\"\n    Creates a basic Ollama Hub frame with links to the website\n    \n    Args:\n        parent: Parent widget\n        \n    Returns:\n        ttk.Frame: The frame with basic Ollama Hub content\n    \"\"\"\n    frame = ttk.Frame(parent)\n    \n    # Create content\n    ttk.Label(\n        frame, \n        text=\"Ollama Hub Integration\", \n        font=(\"Arial\", 16)\n    ).pack(pady=20)\n    \n    ttk.Label(\n        frame,\n        text=\"The Ollama plugin is active, but no custom UI is available.\\n\"\n             \"You can use the buttons below to access Ollama services.\"\n    ).pack(pady=10)\n    \n    # Create buttons frame\n    btn_frame = ttk.Frame(frame)\n    btn_frame.pack(pady=20)\n    \n    # Add buttons\n    ttk.Button(\n        btn_frame,\n        text=\"Open Ollama Website\",\n        command=lambda: webbrowser.open(\"https://ollama.ai\")\n    ).grid(row=0, column=0, padx=10, pady=10)\n    \n    ttk.Button(\n        btn_frame,\n        text=\"View Ollama Models\",\n        command=lambda: webbrowser.open(\"https://ollama.ai/library\")\n    ).grid(row=0, column=1, padx=10, pady=10)\n    \n    ttk.Button(\n        btn_frame,\n        text=\"Ollama Documentation\",\n        command=lambda: webbrowser.open(\"https://github.com/ollama/ollama/blob/main/README.md\")\n    ).grid(row=1, column=0, padx=10, pady=10)\n    \n    ttk.Button(\n        btn_frame,\n        text=\"Refresh Integration\",\n        command=lambda: messagebox.showinfo(\"Not Implemented\", \"This functionality is not implemented yet.\")\n    ).grid(row=1, column=1, padx=10, pady=10)\n    \n    return frame\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\personality_plugin\\config_handler.py": "\"\"\"\nConfiguration handler for the Personality Plugin\n\"\"\"\nimport os\nimport json\nimport time\nfrom typing import Dict, Any, Optional\n\nclass ConfigHandler:\n    \"\"\"\n    Handles configuration loading, saving, and validation for the Personality Plugin\n    \"\"\"\n    \n    def __init__(self, config_path: str, logger=None):\n        \"\"\"\n        Initialize the configuration handler\n        \n        Args:\n            config_path: Path to the configuration file\n            logger: Optional logging function\n        \"\"\"\n        self.config_path = config_path\n        self.logger = logger or self._default_logger\n        self.config = {}\n        \n        # Ensure configuration directory exists\n        os.makedirs(os.path.dirname(self.config_path), exist_ok=True)\n        \n    def _default_logger(self, message: str, level: str = \"INFO\") -> None:\n        \"\"\"Default logging method if none provided\"\"\"\n        timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n        print(f\"{timestamp} [{level}] Personality Plugin Config: {message}\")\n        \n    def load(self) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from file\n        \n        Returns:\n            Configuration dictionary\n        \"\"\"\n        try:\n            # Check if configuration file exists\n            if os.path.exists(self.config_path):\n                with open(self.config_path, 'r', encoding='utf-8') as f:\n                    self.config = json.load(f)\n                    self.logger(f\"Configuration loaded successfully from {self.config_path}\", \"INFO\")\n            else:\n                # Create default configuration\n                self.config = {\n                    \"active_profile\": None,\n                    \"profiles\": {},\n                    \"auto_remember\": True\n                }\n                self.logger(\"Created default configuration\", \"INFO\")\n                self.save()\n                \n            return self.config\n            \n        except Exception as e:\n            self.logger(f\"Configuration loading error: {e}\", \"ERROR\")\n            # Create default configuration on error\n            self.config = {\n                \"active_profile\": None,\n                \"profiles\": {},\n                \"auto_remember\": True\n            }\n            return self.config\n            \n    def save(self) -> bool:\n        \"\"\"\n        Save the current configuration to disk\n        \n        Returns:\n            Success flag\n        \"\"\"\n        try:\n            with open(self.config_path, 'w', encoding='utf-8') as f:\n                json.dump(self.config, f, indent=2)\n                \n            self.logger(f\"Configuration saved successfully to {self.config_path}\", \"INFO\")\n            return True\n            \n        except Exception as e:\n            self.logger(f\"Failed to save configuration: {e}\", \"ERROR\")\n            return False\n            \n    def update(self, new_config: Dict[str, Any]) -> bool:\n        \"\"\"\n        Update the configuration with new values\n        \n        Args:\n            new_config: New configuration values\n            \n        Returns:\n            Success flag\n        \"\"\"\n        try:\n            # Update configuration\n            self.config.update(new_config)\n            \n            # Save to disk\n            return self.save()\n            \n        except Exception as e:\n            self.logger(f\"Failed to update configuration: {e}\", \"ERROR\")\n            return False\n            \n    def get_schema(self) -> Dict[str, Any]:\n        \"\"\"\n        Get the configuration schema for the UI\n        \n        Returns:\n            Schema dictionary for generating UI fields\n        \"\"\"\n        return {\n            \"active_profile\": {\n                \"type\": \"string\",\n                \"label\": \"Active Profile\",\n                \"description\": \"Currently active personality profile\"\n            },\n            \"auto_remember\": {\n                \"type\": \"boolean\",\n                \"label\": \"Store in Memory\",\n                \"description\": \"Whether to store personality attributes in the memory system\",\n                \"default\": True\n            }\n        }\n        \n    def get_configuration_for_ui(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a UI-friendly version of the configuration\n        \n        Returns:\n            UI-friendly configuration dictionary\n        \"\"\"\n        profiles = self.config.get(\"profiles\", {})\n        profile_names = list(profiles.keys())\n        \n        ui_config = {\n            \"active_profile\": self.config.get(\"active_profile\"),\n            \"available_profiles\": profile_names,\n            \"auto_remember\": self.config.get(\"auto_remember\", True)\n        }\n        \n        return ui_config\n",
  "D:\\AI\\IrintAI Assistant\\core\\plugin_manager.py": "\"\"\"\nPlugin Manager - Handles discovery, loading, and lifecycle of plugins\n\"\"\"\nimport os\nimport sys\nimport json\nimport importlib\nimport importlib.util\nimport threading\nimport time\nfrom typing import Dict, List, Any, Optional, Callable, Type\nfrom utils.version import VERSION\n\nclass PluginError(Exception):\n    \"\"\"Base exception for plugin-related errors\"\"\"\n    pass\n\nclass PluginLoadError(PluginError):\n    \"\"\"Exception raised when a plugin fails to load\"\"\"\n    pass\n\nclass PluginActivationError(PluginError):\n    \"\"\"Exception raised when a plugin fails to activate\"\"\"\n    pass\n\nclass PluginConfigurationError(PluginError):\n    \"\"\"Exception raised when plugin configuration fails\"\"\"\n    pass\n\nclass PluginManager:\n    \"\"\"Manages the discovery, loading, and lifecycle of plugins\"\"\"\n    \n    # Plugin status constants\n    PLUGIN_STATUS = {\n        \"NOT_LOADED\": \"Not Loaded\",\n        \"LOADING\": \"Loading...\",\n        \"LOADED\": \"Loaded\",\n        \"ACTIVE\": \"Active\",\n        \"INACTIVE\": \"Inactive\",\n        \"ERROR\": \"Error\"\n    }\n    \n    def __init__(\n        self, \n        plugin_dir: str = \"plugins\",\n        config_dir: str = \"data/plugins\",\n        logger: Optional[Callable] = None,\n        core_system: Any = None\n    ):\n        \"\"\"\n        Initialize the plugin manager\n        \n        Args:\n            plugin_dir: Directory containing plugins\n            config_dir: Directory for plugin configurations\n            logger: Optional logging function\n            core_system: Reference to the main application system\n        \"\"\"\n        self.plugin_dir = plugin_dir\n        self.config_dir = config_dir\n        self.log = logger or print\n        self.core_system = core_system\n        \n        # Plugin storage\n        self.plugins: Dict[str, Any] = {}\n        self.plugin_statuses: Dict[str, str] = {}\n        self.plugin_metadata: Dict[str, Dict[str, Any]] = {}\n        self.error_handler = None\n        \n        # Thread safety\n        self._lock = threading.Lock()\n        \n        # Ensure directories exist\n        os.makedirs(self.plugin_dir, exist_ok=True)\n        os.makedirs(self.config_dir, exist_ok=True)\n        \n        # Add plugin directory to path if not already there\n        if os.path.abspath(self.plugin_dir) not in sys.path:\n            sys.path.append(os.path.abspath(self.plugin_dir))\n            \n        self.log(f\"[Plugin Manager] Initialized with plugin directory: {self.plugin_dir}\")\n    \n    def discover_plugins(self) -> List[str]:\n        \"\"\"\n        Discover available plugins in the plugin directory\n        \n        Returns:\n            List of plugin names\n        \"\"\"\n        discovered = []\n        \n        try:\n            # Look for directories containing __init__.py\n            for item in os.listdir(self.plugin_dir):\n                item_path = os.path.join(self.plugin_dir, item)\n                init_path = os.path.join(item_path, \"__init__.py\")\n                \n                if os.path.isdir(item_path) and os.path.exists(init_path):\n                    discovered.append(item)\n                    self.plugin_statuses[item] = self.PLUGIN_STATUS[\"NOT_LOADED\"]\n                    self.log(f\"[Plugin Discovery] Found plugin: {item}\")\n        except Exception as e:\n            self.log(f\"[Plugin Error] Discovery failed: {e}\")\n            \n        return discovered\n    \n    def set_error_handler(self, handler_func):\n        \"\"\"\n        Set a callback function to handle plugin errors\n        \n        Args:\n            handler_func: Function that takes (plugin_name, error_message) parameters\n        \"\"\"\n        self.error_handler = handler_func\n    \n    def unload_plugin(self, plugin_name):\n        \"\"\"\n        Unload a specific plugin from memory\n\n        Args:\n            plugin_name (str): Name of the plugin to unload\n            \n        Returns:\n            bool: True if plugin was unloaded successfully, False otherwise\n        \"\"\"\n        if plugin_name not in self.plugins:\n            self.log(f\"[Plugin] Cannot unload '{plugin_name}': plugin not found\")\n            return False\n            \n        # Deactivate first if active\n        if self.plugin_statuses.get(plugin_name) == self.PLUGIN_STATUS[\"ACTIVE\"]:\n            self.deactivate_plugin(plugin_name)\n        \n        # Remove from plugins dict\n        if plugin_name in self.plugins:\n            del self.plugins[plugin_name]\n            \n        # Update status\n        self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"NOT_LOADED\"]\n        \n        self.log(f\"[Plugin] Unloaded plugin: {plugin_name}\")\n        return True\n    \n    def unload_all_plugins(self):\n        \"\"\"\n        Unload all plugins from memory\n        \n        Returns:\n            int: Number of plugins unloaded\n        \"\"\"\n        plugin_names = list(self.plugins.keys())\n        count = 0\n        \n        for plugin_name in plugin_names:\n            if self.unload_plugin(plugin_name):\n                count += 1\n                \n        self.log(f\"[Plugin] Unloaded {count} plugins\")\n        return count\n    \n    def auto_load_plugins(self):\n        \"\"\"\n        Automatically load and activate plugins marked for auto-loading\n        \n        Returns:\n            int: Number of plugins auto-loaded\n        \"\"\"\n        # Check if we have access to config_manager\n        if not hasattr(self, 'core_system') or not self.core_system or 'config_manager' not in self.core_system:\n            self.log(\"[Plugin] Cannot auto-load plugins: no access to config manager\")\n            return 0\n            \n        config_manager = self.core_system['config_manager']\n        autoload_plugins = config_manager.get(\"autoload_plugins\", [])\n        \n        if not autoload_plugins:\n            self.log(\"[Plugin] No plugins marked for auto-loading\")\n            return 0\n            \n        self.log(f\"[Plugin] Auto-loading {len(autoload_plugins)} plugins: {', '.join(autoload_plugins)}\")\n        \n        # First discover plugins if not already done\n        if not self.plugins:\n            self.discover_plugins()\n            \n        # Load and activate each plugin\n        count = 0\n        for plugin_name in autoload_plugins:\n            if plugin_name not in self.plugin_statuses or self.plugin_statuses[plugin_name] == self.PLUGIN_STATUS[\"NOT_LOADED\"]:\n                # Load the plugin\n                if self.load_plugin(plugin_name):\n                    # Attempt to activate\n                    if self.activate_plugin(plugin_name):\n                        count += 1\n                        self.log(f\"[Plugin] Auto-loaded and activated: {plugin_name}\")\n                    else:\n                        self.log(f\"[Plugin Warning] Auto-loaded but failed to activate: {plugin_name}\")\n                    \n        return count\n        \n    def register_service(self, service_name, service_obj):\n        \"\"\"\n        Register a service that plugins can access\n        \n        Args:\n            service_name (str): Name of the service\n            service_obj (object): Service object to register\n            \n        Returns:\n            bool: True if service was registered successfully\n        \"\"\"\n        if not hasattr(self, 'services'):\n            self.services = {}\n            \n        self.services[service_name] = service_obj\n        self.log(f\"[Plugin] Registered service: {service_name}\")\n        return True\n        \n    def get_active_plugins(self):\n        \"\"\"\n        Get a list of currently active plugins\n        \n        Returns:\n            list: List of active plugin names\n        \"\"\"\n        active_plugins = []\n        for plugin_name, status in self.plugin_statuses.items():\n            if status == self.PLUGIN_STATUS[\"ACTIVE\"]:\n                active_plugins.append(plugin_name)\n        return active_plugins\n    \n    def get_plugin_info(self, plugin_id):\n        \"\"\"\n        Get information about a specific plugin\n        \n        Args:\n            plugin_id (str): The ID/name of the plugin\n            \n        Returns:\n            dict: Dictionary containing plugin metadata, or empty dict if plugin not found\n        \"\"\"\n        if plugin_id in self.plugin_metadata:\n            return self.plugin_metadata[plugin_id]\n        else:\n            self.log(f\"[Plugin Warning] Requested info for unknown plugin: {plugin_id}\")\n            return {}\n    \n    def load_plugin(self, plugin_name: str) -> bool:\n        \"\"\"\n        Load a specific plugin\n        \n        Args:\n            plugin_name: Name of the plugin to load\n            \n        Returns:\n            True if plugin loaded successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Check if plugin exists\n            plugin_path = os.path.join(self.plugin_dir, plugin_name)\n            init_path = os.path.join(plugin_path, \"__init__.py\")\n            \n            if not os.path.exists(init_path):\n                self.log(f\"[Plugin Error] Plugin not found: {plugin_name}\")\n                self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"ERROR\"]\n                return False\n                \n            # Update status\n            self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"LOADING\"]\n            \n            try:\n                # Import the plugin module\n                spec = importlib.util.spec_from_file_location(\n                    f\"plugins.{plugin_name}\", \n                    init_path\n                )\n                if spec is None or spec.loader is None:\n                    raise ImportError(f\"Could not load spec for {plugin_name}\")\n                    \n                module = importlib.util.module_from_spec(spec)\n                spec.loader.exec_module(module)\n                \n                # Check for required plugin class\n                if not hasattr(module, \"IrintaiPlugin\"):\n                    raise PluginLoadError(f\"Missing IrintaiPlugin class in {plugin_name}\")\n                \n                # Get plugin class\n                plugin_class = getattr(module, \"IrintaiPlugin\")\n                \n                # Extract and validate metadata\n                if not hasattr(plugin_class, \"METADATA\"):\n                    raise PluginLoadError(f\"Missing METADATA in {plugin_name}\")\n                    \n                metadata = getattr(plugin_class, \"METADATA\")\n                self.plugin_metadata[plugin_name] = metadata\n                \n                # Create config path for this plugin\n                plugin_config_dir = os.path.join(self.config_dir, plugin_name)\n                os.makedirs(plugin_config_dir, exist_ok=True)\n                config_path = os.path.join(plugin_config_dir, \"config.json\")\n                \n                # Initialize plugin instance\n                plugin_instance = plugin_class(\n                    plugin_id=plugin_name,  # Pass plugin name as the plugin_id\n                    core_system=self.core_system,\n                    config_path=config_path,\n                    logger=self.log\n                )\n                \n                # Store the plugin instance\n                self.plugins[plugin_name] = plugin_instance\n                \n                # Update status\n                self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"LOADED\"]\n                self.log(f\"[Plugin] Loaded: {plugin_name}\")\n                \n                return True\n                \n            except Exception as e:\n                self.log(f\"[Plugin Error] Failed to load {plugin_name}: {e}\")\n                self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"ERROR\"]\n                return False\n    \n    def load_all_plugins(self) -> Dict[str, bool]:\n        \"\"\"\n        Discover and load all available plugins\n        \n        Returns:\n            Dictionary mapping plugin names to load success status\n        \"\"\"\n        plugins = self.discover_plugins()\n        results = {}\n        \n        for plugin in plugins:\n            results[plugin] = self.load_plugin(plugin)\n            \n        return results\n    \n    def activate_plugin(self, plugin_name: str) -> bool:\n        \"\"\"\n        Activate a loaded plugin\n        \n        Args:\n            plugin_name: Name of the plugin to activate\n            \n        Returns:\n            True if plugin activated successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Check if plugin is loaded\n            if plugin_name not in self.plugins:\n                self.log(f\"[Plugin Error] Cannot activate unloaded plugin: {plugin_name}\")\n                return False\n                \n            # Get the plugin instance\n            plugin = self.plugins[plugin_name]\n            \n            try:\n                # Call plugin's activate method\n                if hasattr(plugin, \"activate\") and callable(plugin.activate):\n                    result = plugin.activate()\n                    \n                    if result:\n                        self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"ACTIVE\"]\n                        self.log(f\"[Plugin] Activated: {plugin_name}\")\n                    else:\n                        self.log(f\"[Plugin Warning] Activation returned False: {plugin_name}\")\n                        return False\n                else:\n                    # No explicit activation method, just mark as active\n                    self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"ACTIVE\"]\n                    self.log(f\"[Plugin] Set active: {plugin_name}\")\n                \n                return True\n                \n            except Exception as e:\n                self.log(f\"[Plugin Error] Activation failed for {plugin_name}: {e}\")\n                self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"ERROR\"]\n                return False\n    \n    def deactivate_plugin(self, plugin_name: str) -> bool:\n        \"\"\"\n        Deactivate an active plugin\n        \n        Args:\n            plugin_name: Name of the plugin to deactivate\n            \n        Returns:\n            True if plugin deactivated successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Check if plugin is loaded\n            if plugin_name not in self.plugins:\n                self.log(f\"[Plugin Error] Cannot deactivate unloaded plugin: {plugin_name}\")\n                return False\n                \n            # Get the plugin instance\n            plugin = self.plugins[plugin_name]\n            \n            try:\n                # Call plugin's deactivate method\n                if hasattr(plugin, \"deactivate\") and callable(plugin.deactivate):\n                    result = plugin.deactivate()\n                    \n                    if result:\n                        self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"INACTIVE\"]\n                        self.log(f\"[Plugin] Deactivated: {plugin_name}\")\n                    else:\n                        self.log(f\"[Plugin Warning] Deactivation returned False: {plugin_name}\")\n                        return False\n                else:\n                    # No explicit deactivation method, just mark as inactive\n                    self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"INACTIVE\"]\n                    self.log(f\"[Plugin] Set inactive: {plugin_name}\")\n                \n                return True\n                \n            except Exception as e:\n                self.log(f\"[Plugin Error] Deactivation failed for {plugin_name}: {e}\")\n                self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"ERROR\"]\n                return False\n    \n    def get_plugin_status(self, plugin_name: str) -> str:\n        \"\"\"\n        Get the current status of a plugin\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            Current plugin status\n        \"\"\"\n        return self.plugin_statuses.get(plugin_name, self.PLUGIN_STATUS[\"NOT_LOADED\"])\n    \n    def get_plugin_metadata(self, plugin_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Get metadata for a specific plugin\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            Plugin metadata dictionary\n        \"\"\"\n        return self.plugin_metadata.get(plugin_name, {})\n    \n    def get_plugin_instance(self, plugin_id: str) -> Any:\n        \"\"\"\n        Get the instance of a loaded plugin\n        \n        Args:\n            plugin_id: Name/ID of the plugin\n            \n        Returns:\n            The plugin instance or None if not found or not loaded\n        \"\"\"\n        return self.plugins.get(plugin_id)\n    \n    def get_all_plugins(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Get information about all plugins\n        \n        Returns:\n            Dictionary mapping plugin names to info dictionaries\n        \"\"\"\n        result = {}\n        \n        for plugin_name in self.plugin_statuses:\n            metadata = self.get_plugin_metadata(plugin_name)\n            status = self.get_plugin_status(plugin_name)\n            \n            result[plugin_name] = {\n                \"name\": plugin_name,\n                \"status\": status,\n                \"version\": metadata.get(\"version\", \"Unknown\"),\n                \"description\": metadata.get(\"description\", \"No description\"),\n                \"author\": metadata.get(\"author\", \"Unknown\")\n            }\n            \n        return result\n    \n    def update_plugin_configuration(self, plugin_name: str, config: Dict[str, Any]) -> bool:\n        \"\"\"\n        Update configuration for a specific plugin\n        \n        Args:\n            plugin_name: Name of the plugin\n            config: Configuration dictionary\n            \n        Returns:\n            True if configuration updated successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Check if plugin is loaded\n            if plugin_name not in self.plugins:\n                self.log(f\"[Plugin Error] Cannot configure unloaded plugin: {plugin_name}\")\n                return False\n                \n            # Get the plugin instance\n            plugin = self.plugins[plugin_name]\n            \n            try:\n                # Call plugin's update_configuration method\n                if hasattr(plugin, \"update_configuration\") and callable(plugin.update_configuration):\n                    result = plugin.update_configuration(**config)\n                    \n                    if result:\n                        self.log(f\"[Plugin] Configuration updated: {plugin_name}\")\n                        return True\n                    else:\n                        self.log(f\"[Plugin Warning] Configuration update failed: {plugin_name}\")\n                        return False\n                else:\n                    self.log(f\"[Plugin Warning] No configuration update method: {plugin_name}\")\n                    return False\n                    \n            except Exception as e:\n                self.log(f\"[Plugin Error] Configuration update failed for {plugin_name}: {e}\")\n                return False\n    \n    def reload_plugin(self, plugin_name: str) -> bool:\n        \"\"\"\n        Reload a plugin (deactivate, unload, load, activate)\n        \n        Args:\n            plugin_name: Name of the plugin to reload\n            \n        Returns:\n            True if plugin reloaded successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Check if plugin was active\n            was_active = self.plugin_statuses.get(plugin_name) == self.PLUGIN_STATUS[\"ACTIVE\"]\n            \n            # Deactivate if active\n            if was_active:\n                if not self.deactivate_plugin(plugin_name):\n                    return False\n                    \n            # Remove from loaded plugins\n            if plugin_name in self.plugins:\n                del self.plugins[plugin_name]\n                \n            # Mark as not loaded\n            self.plugin_statuses[plugin_name] = self.PLUGIN_STATUS[\"NOT_LOADED\"]\n            \n            # Reload\n            if not self.load_plugin(plugin_name):\n                return False\n                \n            # Reactivate if it was active\n            if was_active:\n                return self.activate_plugin(plugin_name)\n                \n            return True\n    \n    def call_plugin_method(self, plugin_name: str, method_name: str, *args, **kwargs) -> Any:\n        \"\"\"\n        Call a method on a loaded plugin\n        \n        Args:\n            plugin_name: Name of the plugin\n            method_name: Name of the method to call\n            *args: Positional arguments to pass\n            **kwargs: Keyword arguments to pass\n            \n        Returns:\n            Result of the method call\n        \n        Raises:\n            PluginError: If the plugin or method doesn't exist\n        \"\"\"\n        with self._lock:\n            # Check if plugin is loaded\n            if plugin_name not in self.plugins:\n                raise PluginError(f\"Plugin not loaded: {plugin_name}\")\n                \n            # Get the plugin instance\n            plugin = self.plugins[plugin_name]\n            \n            # Check if method exists\n            if not hasattr(plugin, method_name) or not callable(getattr(plugin, method_name)):\n                raise PluginError(f\"Method {method_name} not found in plugin {plugin_name}\")\n                \n            # Call the method\n            try:\n                method = getattr(plugin, method_name)\n                return method(*args, **kwargs)\n            except Exception as e:\n                self.log(f\"[Plugin Error] Method call failed: {plugin_name}.{method_name}: {e}\")\n                raise\n\n    def register_plugin_ui(self, plugin_name: str, ui_container: Any) -> bool:\n        \"\"\"\n        Register a plugin's UI components with the main application\n        \n        Args:\n            plugin_name: Name of the plugin\n            ui_container: UI container to register into\n            \n        Returns:\n            True if UI registered successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Check if plugin is active\n            if self.get_plugin_status(plugin_name) != self.PLUGIN_STATUS[\"ACTIVE\"]:\n                self.log(f\"[Plugin UI] Cannot register UI for inactive plugin: {plugin_name}\")\n                return False\n                \n            # Get plugin instance\n            plugin = self.plugins.get(plugin_name)\n            if not plugin:\n                return False\n                \n            try:\n                # Check for UI activation function\n                if hasattr(plugin, \"activate_ui\") and callable(plugin.activate_ui):\n                    # Call the UI activation function\n                    result = plugin.activate_ui(ui_container)\n                    \n                    if result:\n                        self.log(f\"[Plugin UI] Registered UI components for {plugin_name}\")\n                        return True\n                    else:\n                        self.log(f\"[Plugin UI] Failed to register UI for {plugin_name}\")\n                        return False\n                else:\n                    # Check for UI module with panel\n                    try:\n                        # Attempt to import ui module\n                        module_name = f\"plugins.{plugin_name}.ui\"\n                        ui_module = importlib.import_module(module_name)\n                        \n                        # Look for activate_ui function at module level\n                        if hasattr(ui_module, \"activate_ui\") and callable(ui_module.activate_ui):\n                            result = ui_module.activate_ui(ui_container)\n                            \n                            if result:\n                                self.log(f\"[Plugin UI] Registered UI from module for {plugin_name}\")\n                                return True\n                        \n                        # If no activate_ui function, check for Panel class\n                        if hasattr(ui_module, \"Panel\"):\n                            panel_class = getattr(ui_module, \"Panel\")\n                            panel = panel_class(ui_container, plugin)\n                            \n                            # Store panel instance with the plugin\n                            if not hasattr(plugin, \"_ui_instances\"):\n                                setattr(plugin, \"_ui_instances\", [])\n                            getattr(plugin, \"_ui_instances\").append(panel)\n                            \n                            self.log(f\"[Plugin UI] Created UI panel for {plugin_name}\")\n                            return True\n                            \n                    except ImportError:\n                        self.log(f\"[Plugin UI] No UI module found for {plugin_name}\")\n                    except Exception as e:\n                        self.log(f\"[Plugin UI] Error creating UI for {plugin_name}: {e}\")\n                    \n                    return False\n                    \n            except Exception as e:\n                self.log(f\"[Plugin UI] Error registering UI for {plugin_name}: {e}\")\n                return False\n\n    def check_dependencies(self, plugin_name: str) -> Dict[str, bool]:\n        \"\"\"\n        Check if all dependencies for a plugin are satisfied\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            Dictionary mapping dependency names to satisfaction status\n        \"\"\"\n        metadata = self.get_plugin_metadata(plugin_name)\n        dependencies = metadata.get(\"dependencies\", {})\n        results = {}\n        \n        # Check Python version\n        if \"python\" in dependencies:\n            import pkg_resources\n            python_req = dependencies[\"python\"]\n            try:\n                # Use pkg_resources to check version requirement\n                pkg_resources.require(f\"python{python_req}\")\n                results[\"python\"] = True\n            except pkg_resources.VersionConflict:\n                results[\"python\"] = False\n        \n        # Check Irintai version\n        if \"irintai\" in dependencies:\n            irintai_req = dependencies[\"irintai\"]\n            try:\n                pkg_resources.require(f\"irintai{irintai_req}\")\n                results[\"irintai\"] = True\n            except (pkg_resources.VersionConflict, ImportError):\n                results[\"irintai\"] = False\n        \n        # Check external libraries\n        if \"external_libs\" in dependencies and isinstance(dependencies[\"external_libs\"], list):\n            for lib in dependencies[\"external_libs\"]:\n                try:\n                    importlib.import_module(lib.split(\">=\")[0].strip())\n                    results[lib] = True\n                except ImportError:\n                    results[lib] = False\n        \n        # Check plugin dependencies\n        if \"plugins\" in dependencies and isinstance(dependencies[\"plugins\"], list):\n            for dep_plugin in dependencies[\"plugins\"]:\n                # Check if plugin is loaded and active\n                is_satisfied = (\n                    dep_plugin in self.plugins and \n                    self.get_plugin_status(dep_plugin) == self.PLUGIN_STATUS[\"ACTIVE\"]\n                )\n                results[f\"plugin:{dep_plugin}\"] = is_satisfied\n        \n        return results\n\n    def install_dependencies(self, plugin_name: str) -> Dict[str, bool]:\n        \"\"\"\n        Attempt to install missing dependencies for a plugin\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            Dictionary mapping dependency names to installation success status\n        \"\"\"\n        results = {}\n        metadata = self.get_plugin_metadata(plugin_name)\n        dependencies = metadata.get(\"dependencies\", {})\n        \n        # Only attempt to install external libraries\n        if \"external_libs\" in dependencies and isinstance(dependencies[\"external_libs\"], list):\n            for lib in dependencies[\"external_libs\"]:\n                lib_name = lib.split(\">=\")[0].strip()\n                \n                try:\n                    # Check if already installed\n                    importlib.import_module(lib_name)\n                    results[lib] = True\n                    continue\n                except ImportError:\n                    pass\n                    \n                # Try to install with pip\n                try:\n                    import subprocess\n                    self.log(f\"[Plugin Dependencies] Installing {lib} for {plugin_name}\")\n                    \n                    # Run pip install in a subprocess\n                    process = subprocess.run(\n                        [sys.executable, \"-m\", \"pip\", \"install\", lib],\n                        capture_output=True,\n                        text=True,\n                        check=False\n                    )\n                    \n                    if process.returncode == 0:\n                        results[lib] = True\n                        self.log(f\"[Plugin Dependencies] Installed {lib}\")\n                    else:\n                        results[lib] = False\n                        self.log(f\"[Plugin Dependencies] Failed to install {lib}: {process.stderr}\")\n                \n                except Exception as e:\n                    results[lib] = False\n                    self.log(f\"[Plugin Dependencies] Error installing {lib}: {e}\")\n        \n        return results\n\n    def register_event_handler(self, plugin_name: str, event_type: str, handler: Callable) -> bool:\n        \"\"\"\n        Register a plugin's event handler for a specific event type\n        \n        Args:\n            plugin_name: Name of the plugin\n            event_type: Type of event to handle\n            handler: Function to call when event occurs\n            \n        Returns:\n            True if handler registered successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Initialize event handlers dictionary if needed\n            if not hasattr(self, \"_event_handlers\"):\n                self._event_handlers = {}\n                \n            # Initialize handlers list for this event type\n            if event_type not in self._event_handlers:\n                self._event_handlers[event_type] = []\n                \n            # Register the handler with plugin info\n            handler_info = {\"plugin\": plugin_name, \"handler\": handler}\n            self._event_handlers[event_type].append(handler_info)\n            \n            self.log(f\"[Plugin Events] Registered handler for {event_type} from {plugin_name}\")\n            return True\n\n    def unregister_event_handler(self, plugin_name: str, event_type: str, handler: Optional[Callable] = None) -> bool:\n        \"\"\"\n        Unregister a plugin's event handler\n        \n        Args:\n            plugin_name: Name of the plugin\n            event_type: Type of event to unregister from\n            handler: Specific handler to unregister (if None, unregister all for plugin)\n            \n        Returns:\n            True if handler(s) unregistered successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Check if we have any handlers for this event\n            if not hasattr(self, \"_event_handlers\") or event_type not in self._event_handlers:\n                return False\n                \n            # Find handlers to remove\n            handlers_to_remove = []\n            for handler_info in self._event_handlers[event_type]:\n                if handler_info[\"plugin\"] == plugin_name:\n                    if handler is None or handler_info[\"handler\"] == handler:\n                        handlers_to_remove.append(handler_info)\n            \n            # Remove the handlers\n            for handler_info in handlers_to_remove:\n                self._event_handlers[event_type].remove(handler_info)\n                \n            # Clean up empty lists\n            if not self._event_handlers[event_type]:\n                del self._event_handlers[event_type]\n                \n            self.log(f\"[Plugin Events] Unregistered {len(handlers_to_remove)} handlers for {event_type} from {plugin_name}\")\n            return len(handlers_to_remove) > 0\n\n    def trigger_event(self, event_type: str, **event_data) -> Dict[str, Any]:\n        \"\"\"\n        Trigger an event to be handled by registered plugins\n        \n        Args:\n            event_type: Type of event to trigger\n            **event_data: Data to pass to event handlers\n            \n        Returns:\n            Dictionary mapping plugin names to their handler results\n        \"\"\"\n        results = {}\n        \n        # Check if we have any handlers for this event\n        if not hasattr(self, \"_event_handlers\") or event_type not in self._event_handlers:\n            return results\n            \n        # Call each handler\n        for handler_info in self._event_handlers[event_type]:\n            plugin_name = handler_info[\"plugin\"]\n            handler = handler_info[\"handler\"]\n            \n            try:\n                # Skip handlers for inactive plugins\n                status = self.get_plugin_status(plugin_name)\n                if status != self.PLUGIN_STATUS[\"ACTIVE\"]:\n                    continue\n                    \n                # Call the handler and store result\n                result = handler(**event_data)\n                results[plugin_name] = result\n                \n            except Exception as e:\n                self.log(f\"[Plugin Events] Error in {event_type} handler from {plugin_name}: {e}\")\n                results[plugin_name] = {\"error\": str(e)}\n                \n        return results\n\n    def uninstall_plugin(self, plugin_name: str) -> bool:\n        \"\"\"\n        Safely uninstall a plugin\n        \n        Args:\n            plugin_name: Name of the plugin to uninstall\n            \n        Returns:\n            True if plugin uninstalled successfully, False otherwise\n        \"\"\"\n        with self._lock:\n            # Deactivate the plugin if active\n            if self.get_plugin_status(plugin_name) == self.PLUGIN_STATUS[\"ACTIVE\"]:\n                if not self.deactivate_plugin(plugin_name):\n                    self.log(f\"[Plugin] Cannot uninstall active plugin {plugin_name}\")\n                    return False\n                    \n            try:\n                # Call uninstall method if available\n                if plugin_name in self.plugins:\n                    plugin = self.plugins[plugin_name]\n                    if hasattr(plugin, \"uninstall\") and callable(plugin.uninstall):\n                        plugin.uninstall()\n                        \n                    # Remove from loaded plugins\n                    del self.plugins[plugin_name]\n                \n                # Remove configuration directory\n                plugin_config_dir = os.path.join(self.config_dir, plugin_name)\n                if os.path.exists(plugin_config_dir):\n                    import shutil\n                    shutil.rmtree(plugin_config_dir)\n                    \n                # Remove status and metadata\n                if plugin_name in self.plugin_statuses:\n                    del self.plugin_statuses[plugin_name]\n                if plugin_name in self.plugin_metadata:\n                    del self.plugin_metadata[plugin_name]\n                    \n                self.log(f\"[Plugin] Uninstalled plugin: {plugin_name}\")\n                return True\n                \n            except Exception as e:\n                self.log(f\"[Plugin Error] Failed to uninstall {plugin_name}: {e}\")\n                return False\n\n    def check_for_updates(self, plugin_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Check if a plugin has updates available\n        \n        Args:\n            plugin_name: Name of the plugin to check\n            \n        Returns:\n            Dictionary with update information\n        \"\"\"\n        result = {\n            \"has_update\": False,\n            \"current_version\": \"0.0.0\",\n            \"latest_version\": \"0.0.0\",\n            \"update_url\": None,\n            \"changelog\": None\n        }\n        \n        # Get current version\n        metadata = self.get_plugin_metadata(plugin_name)\n        current_version = metadata.get(\"version\", \"0.0.0\")\n        result[\"current_version\"] = current_version\n        \n        # Check if plugin has update URL defined\n        update_url = metadata.get(\"update_url\")\n        if not update_url:\n            return result\n            \n        try:\n            # Call plugin's update checking method if available\n            if plugin_name in self.plugins:\n                plugin = self.plugins[plugin_name]\n                if hasattr(plugin, \"check_for_updates\") and callable(plugin.check_for_updates):\n                    update_info = plugin.check_for_updates()\n                    if update_info and isinstance(update_info, dict):\n                        result.update(update_info)\n                        return result\n            \n            # Basic update check using a JSON file at the update URL\n            import urllib.request\n            import json\n            \n            # Try to fetch update info\n            with urllib.request.urlopen(update_url, timeout=5) as response:\n                update_data = json.loads(response.read().decode())\n                \n                # Get latest version\n                latest_version = update_data.get(\"version\", \"0.0.0\")\n                result[\"latest_version\"] = latest_version\n                \n                # Check if newer\n                from pkg_resources import parse_version\n                if parse_version(latest_version) > parse_version(current_version):\n                    result[\"has_update\"] = True\n                    result[\"update_url\"] = update_data.get(\"download_url\")\n                    result[\"changelog\"] = update_data.get(\"changelog\")\n                    \n                    self.log(f\"[Plugin] Update available for {plugin_name}: {current_version} \u2192 {latest_version}\")\n                    \n        except Exception as e:\n            self.log(f\"[Plugin] Failed to check updates for {plugin_name}: {e}\")\n            \n        return result\n    \n    def set_plugin_config(self, plugin_id: str, config_data: Dict[str, Any]) -> bool:\n        \"\"\"\n        Update a plugin's configuration\n        \n        Args:\n            plugin_id: Unique identifier for the plugin\n            config_data: Dictionary containing configuration settings\n            \n        Returns:\n            True if configuration updated successfully, False otherwise\n        \"\"\"\n        if plugin_id not in self.plugins:\n            self.log(f\"[Plugin Manager] Cannot set config for unknown plugin: {plugin_id}\")\n            return False\n            \n        try:\n            # Get the plugin instance\n            plugin_instance = self.plugins[plugin_id].get(\"instance\")\n            if not plugin_instance:\n                self.log(f\"[Plugin Manager] Plugin not loaded: {plugin_id}\")\n                return False\n                \n            # Update the plugin's configuration\n            if hasattr(plugin_instance, \"set_config\"):\n                plugin_instance.set_config(config_data)\n                \n            # Save the configuration to file\n            config_file = os.path.join(self.config_dir, f\"{plugin_id}.json\")\n            os.makedirs(os.path.dirname(config_file), exist_ok=True)\n            \n            with open(config_file, 'w', encoding='utf-8') as f:\n                json.dump(config_data, f, indent=2)\n                \n            self.log(f\"[Plugin Manager] Updated configuration for {plugin_id}\")\n            return True\n            \n        except Exception as e:\n            self.log(f\"[Plugin Manager] Failed to update config for {plugin_id}: {e}\")\n            return False",
  "D:\\AI\\IrintAI Assistant\\plugins\\ollama_hub\\ui\\ollama_hub_creator.py": "\"\"\"\nDirect method to create Ollama Hub tab in the main UI\n\nThis fixes the error: 'MainWindow' object has no attribute 'create_ollama_hub_tab'\n\"\"\"\nimport tkinter as ttk\ndef create_ollama_hub_tab_direct(self):\n    \"\"\"\n    Create the Ollama Hub tab if the plugin is active\n    \n    This method is implemented directly in the MainWindow class to create\n    and integrate the Ollama Hub UI tab into the application.\n    \"\"\"\n    try:\n        # Check if plugin manager is available\n        if not hasattr(self, 'plugin_manager'):\n            self.logger.log(\"[UI] Plugin manager not available, skipping Ollama Hub tab creation\")\n            return\n            \n        # Check if the ollama_hub plugin is active\n        active_plugins = self.plugin_manager.get_active_plugins()\n        \n        # Skip if ollama_hub plugin is not active\n        if 'ollama_hub' not in active_plugins:\n            self.logger.log(\"[UI] Ollama Hub plugin not active, skipping tab creation\")\n            return\n            \n        # Get the plugin instance\n        ollama_plugin = active_plugins.get('ollama_hub')\n        \n        # Create a frame for the tab\n        ollama_tab_frame = ttk.Frame(self.notebook)\n        \n        # Try direct import of OllamaHubTab\n        try:\n            # Import the OllamaHubTab class\n            import sys\n            import importlib.util\n            \n            # First try if the plugin has ui_components attribute\n            if hasattr(ollama_plugin, 'ui_components') and 'ollama_tab' in ollama_plugin.ui_components:\n                # Create an instance of the tab\n                OllamaHubTab = ollama_plugin.ui_components['ollama_tab']\n                tab_instance = OllamaHubTab(ollama_tab_frame, plugin_instance=ollama_plugin)\n                \n                # Add the tab to the notebook\n                self.notebook.add(ollama_tab_frame, text=\"Ollama Hub\")\n                \n                # Store reference for later access\n                self.ollama_hub_tab = tab_instance\n                \n                self.logger.log(\"[UI] Successfully added Ollama Hub tab\")\n                return True\n                \n            # If the plugin doesn't have ui_components, try direct import\n            module_name = \"plugins.ollama_hub.ui.ollama_tab\"\n            \n            if module_name in sys.modules:\n                module = sys.modules[module_name]\n            else:\n                # Find and load the module\n                spec = importlib.util.find_spec(module_name)\n                if spec:\n                    module = importlib.util.import_module(module_name)\n                else:\n                    self.logger.log(\"[UI] Could not find Ollama Hub tab module\", \"ERROR\")\n                    return False\n            \n            # Check if OllamaHubTab exists in the module\n            if hasattr(module, \"OllamaHubTab\"):\n                OllamaHubTab = getattr(module, \"OllamaHubTab\")\n                \n                # Create an instance of OllamaHubTab\n                tab_instance = OllamaHubTab(ollama_tab_frame, plugin_instance=ollama_plugin)\n                \n                # Add the tab to the notebook\n                self.notebook.add(ollama_tab_frame, text=\"Ollama Hub\")\n                \n                # Store reference for later access\n                self.ollama_hub_tab = tab_instance\n                \n                self.logger.log(\"[UI] Successfully added Ollama Hub tab\")\n                return True\n            else:\n                self.logger.log(\"[UI] OllamaHubTab class not found in module\", \"ERROR\")\n                return False\n                \n        except Exception as e:\n            self.logger.log(f\"[UI] Error creating Ollama Hub tab: {e}\", \"ERROR\")\n            import traceback\n            self.logger.log(f\"[UI] {traceback.format_exc()}\", \"DEBUG\")\n            return False\n            \n    except Exception as e:\n        self.logger.log(f\"[UI] Error in create_ollama_hub_tab: {e}\", \"ERROR\")\n        return False\n",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\enhanced_diagnostics.py": "#!/usr/bin/env python3\n\"\"\"\nIrintAI Assistant - Enhanced Diagnostic Tool\nThis script performs a comprehensive diagnostic check of the IrintAI Assistant system\nto identify configuration issues, missing dependencies, code problems, and attribute errors.\n\"\"\"\n\nimport os\nimport sys\nimport importlib\nimport traceback\nimport json\nimport subprocess\nimport platform\nimport time\nimport inspect\nimport re\nimport shutil\nfrom pathlib import Path\nimport logging\n\ndef extract_class_methods_from_code(code_content, class_name):\n    \"\"\"\n    Parse Python code to extract methods defined in a specific class\n    \n    Args:\n        code_content: String containing Python code\n        class_name: Name of the class to examine\n        \n    Returns:\n        List of method names defined in the class\n    \"\"\"\n    methods = []\n    \n    # Find the class definition\n    class_pattern = rf\"class\\s+{class_name}\\s*\\(.*?\\):\"\n    class_match = re.search(class_pattern, code_content)\n    \n    if not class_match:\n        return methods\n    \n    # Find the start position of the class body\n    start_pos = class_match.end()\n    \n    # Simple method to find proper indentation of the class\n    lines = code_content[start_pos:].split(\"\\n\")\n    if not lines:\n        return methods\n    \n    # Find class indentation level by looking at first non-empty line after class definition\n    class_indent = 0\n    for line in lines:\n        if line.strip():\n            class_indent = len(line) - len(line.lstrip())\n            break\n    \n    # Find method definitions with proper indentation\n    method_pattern = rf\"^\\s{{{class_indent+4}}}def\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(\"\n    \n    # Search for methods in the code after the class definition\n    for line in lines:\n        if line.strip() and len(line) - len(line.lstrip()) == class_indent + 4:\n            method_match = re.match(method_pattern, line)\n            if method_match:\n                method_name = method_match.group(1)\n                # Skip private methods (starting with _)\n                if not method_name.startswith(\"__\"):\n                    methods.append(method_name)\n    \n    return methods\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s [%(levelname)s] %(message)s',\n    handlers=[\n        logging.StreamHandler(),\n        logging.FileHandler(\"irintai_diagnostic.log\")\n    ]\n)\nlogger = logging\n\ndef print_header(text):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'=' * 80}\")\n    print(f\" {text}\")\n    print(f\"{'=' * 80}\")\n    logger.info(f\"SECTION: {text}\")\n\ndef check_environment():\n    \"\"\"Check the system environment\"\"\"\n    print_header(\"SYSTEM ENVIRONMENT\")\n    \n    print(f\"Operating System: {platform.system()} {platform.release()}\")\n    print(f\"Python Version: {platform.python_version()}\")\n    print(f\"Current Directory: {os.getcwd()}\")\n    \n    # Check for critical environment variables\n    env_vars = [\"OLLAMA_HOME\", \"OLLAMA_MODELS\"]\n    for var in env_vars:\n        value = os.environ.get(var)\n        status = \"\u2713 SET\" if value else \"\u2717 MISSING\"\n        print(f\"{var}: {status} {f'({value})' if value else ''}\")\n    \n    return True\n\ndef check_file_structure():\n    \"\"\"Verify the integrity of the file structure\"\"\"\n    print_header(\"FILE STRUCTURE\")\n    \n    critical_files = [\n        \"irintai.py\", \n        \"core/__init__.py\",\n        \"core/plugin_manager.py\",\n        \"core/model_manager.py\",\n        \"core/chat_engine.py\",\n        \"ui/main_window.py\",\n        \"data/config.json\"\n    ]\n    \n    critical_dirs = [\n        \"plugins\",\n        \"data/logs\",\n        \"data/models\",\n        \"data/plugins\"\n    ]\n    \n    issues_found = False\n    \n    print(\"Checking critical files:\")\n    for file_path in critical_files:\n        if os.path.exists(file_path):\n            print(f\"  \u2713 {file_path}\")\n        else:\n            print(f\"  \u2717 {file_path} (MISSING)\")\n            issues_found = True\n    \n    print(\"\\nChecking critical directories:\")\n    for dir_path in critical_dirs:\n        if os.path.exists(dir_path):\n            print(f\"  \u2713 {dir_path}\")\n        else:\n            print(f\"  \u2717 {dir_path} (MISSING)\")\n            issues_found = True\n    \n    if issues_found:\n        print(\"\\n\u26a0 Some critical files or directories are missing!\")\n    else:\n        print(\"\\n\u2713 All critical files and directories are present\")\n    \n    # Check plugin directory\n    if os.path.exists(\"plugins\"):\n        plugins = [d for d in os.listdir(\"plugins\") if os.path.isdir(os.path.join(\"plugins\", d))]\n        print(f\"\\nFound {len(plugins)} plugin directories: {', '.join(plugins)}\")\n        \n        for plugin in plugins:\n            plugin_dir = os.path.join(\"plugins\", plugin)\n            init_file = os.path.join(plugin_dir, \"__init__.py\")\n            manifest_file = os.path.join(plugin_dir, \"manifest.json\")\n            \n            if not os.path.exists(init_file):\n                print(f\"  \u26a0 {plugin}: Missing __init__.py file\")\n                issues_found = True\n                \n            if not os.path.exists(manifest_file):\n                print(f\"  \u26a0 {plugin}: Missing manifest.json file\")\n                issues_found = True\n            else:\n                # Check manifest.json structure\n                try:\n                    with open(manifest_file, 'r') as f:\n                        manifest = json.load(f)\n                        \n                    required_keys = [\"name\", \"version\", \"description\"]\n                    missing_keys = [key for key in required_keys if key not in manifest]\n                    \n                    if missing_keys:\n                        print(f\"  \u26a0 {plugin}: Manifest missing required fields: {', '.join(missing_keys)}\")\n                        issues_found = True\n                except json.JSONDecodeError:\n                    print(f\"  \u26a0 {plugin}: Invalid JSON in manifest.json\")\n                    issues_found = True\n                except Exception as e:\n                    print(f\"  \u26a0 {plugin}: Error reading manifest.json: {str(e)}\")\n                    issues_found = True\n    \n    return not issues_found\n\ndef check_dependencies():\n    \"\"\"Check Python dependencies\"\"\"\n    print_header(\"DEPENDENCY CHECK\")\n    \n    # Try to locate requirements.txt files\n    requirements_files = [\n        \"requirements.txt\",\n        \"docs/requirements.txt\"\n    ]\n    \n    found_file = None\n    for file in requirements_files:\n        if os.path.exists(file):\n            found_file = file\n            break\n    \n    if not found_file:\n        print(\"\u26a0 No requirements.txt file found!\")\n        return False\n    \n    print(f\"Using requirements from: {found_file}\")\n    \n    # Parse requirements\n    try:\n        with open(found_file, 'r') as file:\n            requirements = [line.strip() for line in file if line.strip() and not line.startswith('#')]\n        \n        print(f\"Found {len(requirements)} dependencies in requirements file\")\n        \n        # Check each dependency\n        missing = []\n        for req in requirements:\n            # Extract package name from requirement line\n            package = req.split('==')[0].split('>=')[0].strip()\n            \n            # Handle special cases for package names vs import names\n            import_name = package\n            if package == \"python-docx\":\n                import_name = \"docx\"\n            elif package == \"sentence-transformers\":\n                import_name = \"sentence_transformers\"\n            elif package == \"pillow\":\n                import_name = \"PIL\"\n            \n            try:\n                # Try to import the module\n                importlib.import_module(import_name)\n                print(f\"  \u2713 {package}\")\n            except ImportError:\n                # Try pip show as a fallback\n                try:\n                    result = subprocess.run(\n                        [sys.executable, \"-m\", \"pip\", \"show\", package],\n                        capture_output=True,\n                        text=True\n                    )\n                    if result.returncode == 0:\n                        print(f\"  \u26a0 {package} (INSTALLED BUT IMPORT FAILED)\")\n                    else:\n                        missing.append(package)\n                        print(f\"  \u2717 {package} (MISSING)\")\n                except Exception:\n                    missing.append(package)\n                    print(f\"  \u2717 {package} (MISSING)\")\n        \n        if missing:\n            print(f\"\\n\u26a0 {len(missing)} dependencies are missing!\")\n            print(\"\\nTo install missing dependencies, run:\")\n            print(f\"pip install -r {found_file}\")\n        else:\n            print(\"\\n\u2713 All dependencies are installed\")\n            \n    except Exception as e:\n        print(f\"\u26a0 Error checking dependencies: {e}\")\n        return False\n    \n    return len(missing) == 0\n\ndef check_config():\n    \"\"\"Check configuration files\"\"\"\n    print_header(\"CONFIGURATION CHECK\")\n    \n    if not os.path.exists(\"data/config.json\"):\n        print(\"\u26a0 Main config file (data/config.json) is missing!\")\n        return False\n    \n    try:\n        with open(\"data/config.json\", 'r') as file:\n            config = json.load(file)\n        \n        print(\"\u2713 Successfully loaded main configuration\")\n        \n        # Check critical configuration keys\n        critical_keys = [\"model\", \"system_prompt\", \"autoload_plugins\"]\n        missing_keys = [key for key in critical_keys if key not in config]\n        \n        if missing_keys:\n            print(f\"\u26a0 Missing critical config keys: {', '.join(missing_keys)}\")\n        else:\n            print(\"\u2713 All critical configuration keys are present\")\n            \n        # Print some config info\n        print(\"\\nCurrent configuration:\")\n        if \"model\" in config:\n            print(f\"  - Model: {config['model']}\")\n        else:\n            # Check for equivalent keys\n            model_alternatives = [\"model_path\", \"default_model\", \"current_model\"]\n            for alt in model_alternatives:\n                if alt in config:\n                    print(f\"  - {alt}: {config[alt]} (alternative to 'model')\")\n                    break\n            \n        if \"system_prompt\" in config:\n            prompt = config[\"system_prompt\"]\n            # Truncate long prompts\n            if len(prompt) > 100:\n                prompt = prompt[:97] + \"...\"\n            print(f\"  - System prompt: {prompt}\")\n        elif \"system_message\" in config:\n            prompt = config[\"system_message\"]\n            if len(prompt) > 100:\n                prompt = prompt[:97] + \"...\"\n            print(f\"  - System message: {prompt} (alternative to 'system_prompt')\")\n            \n        if \"autoload_plugins\" in config:\n            print(f\"  - Auto-load plugins: {', '.join(config.get('autoload_plugins', []))}\")\n            \n    except json.JSONDecodeError:\n        print(\"\u26a0 The config.json file contains invalid JSON!\")\n        return False\n    except Exception as e:\n        print(f\"\u26a0 Error checking configuration: {e}\")\n        return False\n    \n    return True\n\ndef check_class_attributes(class_obj, required_attributes, class_name=None):\n    \"\"\"Check if a class has all the required attributes\"\"\"\n    class_name = class_name or class_obj.__name__\n    missing_attrs = []\n    \n    for attr in required_attributes:\n        if not hasattr(class_obj, attr):\n            missing_attrs.append(attr)\n    \n    return missing_attrs\n\ndef check_plugin_manager():\n    \"\"\"Check the plugin manager implementation\"\"\"\n    print_header(\"PLUGIN MANAGER CHECK\")\n    \n    if not os.path.exists(\"core/plugin_manager.py\"):\n        print(\"\u26a0 Plugin manager file is missing!\")\n        return False\n    \n    try:\n        # Add the current directory to path\n        sys.path.insert(0, os.getcwd())\n        \n        # Try to import the plugin manager\n        from core.plugin_manager import PluginManager\n        \n        # Read the plugin_manager.py file to analyze its content directly\n        with open(\"core/plugin_manager.py\", \"r\") as file:\n            plugin_manager_code = file.read()\n            \n        # Parse the file to detect methods defined in the PluginManager class\n        defined_methods = extract_class_methods_from_code(plugin_manager_code, \"PluginManager\")\n        print(f\"Found {len(defined_methods)} methods defined in PluginManager class\")\n        \n        # Instantiate the plugin manager\n        plugin_manager = PluginManager()\n        \n        # Define required methods and their descriptions\n        required_methods = [\n            (\"set_error_handler\", \"Handles UI error callbacks from plugins\"),\n            (\"discover_plugins\", \"Discovers available plugins in the plugin directory\"),\n            (\"load_plugin\", \"Loads a specific plugin by name\"), \n            (\"activate_plugin\", \"Activates a loaded plugin\"), \n            (\"deactivate_plugin\", \"Deactivates a running plugin\"),\n            (\"unload_plugin\", \"Unloads a specific plugin from memory\"),\n            (\"unload_all_plugins\", \"Unloads all plugins when application exits\"),\n            (\"auto_load_plugins\", \"Automatically loads plugins marked for auto-loading\"),\n            (\"get_plugin_metadata\", \"Retrieves metadata for a specific plugin\"),\n            (\"get_all_plugins\", \"Retrieves information about all plugins\"),\n            (\"reload_plugin\", \"Reloads a plugin by unloading and loading it again\")\n        ]\n        \n        # Check each required method\n        missing_methods = []\n        for method, description in required_methods:\n            if hasattr(plugin_manager, method):\n                print(f\"\u2713 PluginManager has '{method}' method\")\n            else:\n                missing_methods.append((method, description))\n                print(f\"\u26a0 PluginManager is missing '{method}' method! - {description}\")\n        \n        if \"set_error_handler\" in missing_methods:\n            print(\"\\n\u26a0 CRITICAL: PluginManager is missing 'set_error_handler' method!\")\n            print(\"This will cause UI initialization to fail with AttributeError.\")\n            print(\"\\nSuggested fix in core/plugin_manager.py:\")\n            print(\"\\n    def set_error_handler(self, handler_func):\")\n            print('        \"\"\"Set a callback function to handle plugin errors\"\"\"')\n            print(\"        self.error_handler = handler_func\")\n        \n        # Check for common attributes\n        required_attributes = [\"plugins\", \"plugin_statuses\", \"plugin_dir\", \"config_dir\"]\n        missing_attributes = []\n        for attr in required_attributes:\n            if hasattr(plugin_manager, attr):\n                print(f\"\u2713 PluginManager has '{attr}' attribute\")\n            else:\n                missing_attributes.append(attr)\n                print(f\"\u26a0 PluginManager is missing '{attr}' attribute!\")\n        \n        # Check implementation of critical methods\n        if hasattr(plugin_manager, \"discover_plugins\"):\n            try:\n                plugin_count = plugin_manager.discover_plugins()\n                print(f\"\u2713 discover_plugins method works (found {plugin_count} plugins)\")\n            except Exception as e:\n                print(f\"\u26a0 Error calling discover_plugins: {str(e)}\")\n        \n        return len(missing_methods) == 0 and len(missing_attributes) == 0\n        \n    except ImportError:\n        print(\"\u26a0 Could not import PluginManager!\")\n        return False\n    except Exception as e:\n        print(f\"\u26a0 Error checking plugin manager: {e}\")\n        traceback.print_exc()\n        return False\n\ndef check_interface_consistency():\n    \"\"\"Check for interface consistency across core components\"\"\"\n    print_header(\"INTERFACE CONSISTENCY CHECK\")\n    \n    try:\n        # Add the current directory to path\n        sys.path.insert(0, os.getcwd())\n        \n        # Import core components for inspection\n        classes_to_check = [\n            (\"core.plugin_manager\", \"PluginManager\"),\n            (\"core.model_manager\", \"ModelManager\"),\n            (\"core.chat_engine\", \"ChatEngine\"),\n            (\"core.memory_system\", \"MemorySystem\"),\n            (\"ui.main_window\", \"MainWindow\")\n        ]\n        \n        interface_issues = False\n        \n        for module_name, class_name in classes_to_check:\n            try:\n                module = importlib.import_module(module_name)\n                class_obj = getattr(module, class_name)\n                \n                print(f\"Checking {class_name} interface...\")\n                \n                # Extract expected method calls from other files\n                expected_methods = find_expected_methods(class_name)\n                if expected_methods:\n                    print(f\"Found {len(expected_methods)} expected methods for {class_name}\")\n                    \n                    # Check if all expected methods exist\n                    missing = []\n                    for method in expected_methods:\n                        if not hasattr(class_obj, method):\n                            missing.append(method)\n                            \n                    if missing:\n                        print(f\"\u26a0 {class_name} is missing expected methods: {', '.join(missing)}\")\n                        print(\"This could lead to AttributeError exceptions at runtime.\")\n                        interface_issues = True\n                    else:\n                        print(f\"\u2713 {class_name} implements all expected methods\")\n                \n            except ImportError:\n                print(f\"\u26a0 Could not import {module_name}.{class_name}\")\n                interface_issues = True\n            except Exception as e:\n                print(f\"\u26a0 Error checking {class_name}: {str(e)}\")\n                interface_issues = True\n        \n        if not interface_issues:\n            print(\"\\n\u2713 All core components have consistent interfaces\")\n            return True\n        else:\n            print(\"\\n\u26a0 Interface inconsistencies detected\")\n            return False\n            \n    except Exception as e:\n        print(f\"\u26a0 Error in interface consistency check: {str(e)}\")\n        return False\n\ndef find_expected_methods(class_name):\n    \"\"\"Find method calls on instances of a specific class throughout the codebase\"\"\"\n    methods = set()\n    base_dir = os.getcwd()\n    \n    # Look for patterns like self.class_name.method_name or obj.method_name\n    pattern = f\"{class_name.lower()}\\\\.\"\n    pattern_alt = r\"self\\.[a-zA-Z_]+\\.\"\n    \n    # Directories to search\n    dirs_to_search = [\"core\", \"ui\", \"utils\"]\n    \n    for directory in dirs_to_search:\n        dir_path = os.path.join(base_dir, directory)\n        if not os.path.exists(dir_path):\n            continue\n            \n        for root, _, files in os.walk(dir_path):\n            for file in files:\n                if not file.endswith('.py'):\n                    continue\n                    \n                file_path = os.path.join(root, file)\n                try:\n                    with open(file_path, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                        \n                    # Simple regex would be more robust but for this demo\n                    # we'll just do basic string checks\n                    lines = content.split('\\n')\n                    for line in lines:\n                        line = line.strip()\n                        \n                        # Skip comments\n                        if line.startswith('#'):\n                            continue\n                            \n                        # Look for method calls\n                        if f\".{class_name.lower()}.\" in line.lower() or pattern_alt in line.lower():\n                            # Extract method name - this is a simple approach\n                            parts = line.split('.')\n                            if len(parts) >= 3:\n                                # The method name would be after the object reference\n                                method_part = parts[2].split('(')[0].strip()\n                                methods.add(method_part)\n                                \n                except Exception as e:\n                    print(f\"Error processing {file_path}: {str(e)}\")\n    \n    return list(methods)\n\ndef check_logs():\n    \"\"\"Check recent log files\"\"\"\n    print_header(\"LOG ANALYSIS\")\n    \n    log_file = \"irintai_debug.log\"\n    if not os.path.exists(log_file):\n        log_dir = \"data/logs\"\n        if os.path.exists(log_dir):\n            log_files = sorted([f for f in os.listdir(log_dir) if f.startswith(\"irintai_debug_\")], reverse=True)\n            if log_files:\n                log_file = os.path.join(log_dir, log_files[0])\n                print(f\"Using most recent log: {log_file}\")\n            else:\n                print(\"\u26a0 No log files found!\")\n                return False\n        else:\n            print(\"\u26a0 Log directory not found!\")\n            return False\n    \n    try:\n        with open(log_file, 'r') as file:\n            # Read the last 50 lines of the log\n            lines = file.readlines()\n            last_lines = lines[-50:] if len(lines) > 50 else lines\n            \n            print(f\"Analyzing {len(last_lines)} log entries from {log_file}\")\n            \n            errors = [line for line in last_lines if \"[ERROR]\" in line]\n            warnings = [line for line in last_lines if \"[WARNING]\" in line or \"[WARN]\" in line]\n            \n            # Look specifically for attribute errors\n            attribute_errors = [line for line in errors if \"AttributeError\" in line]\n            \n            if attribute_errors:\n                print(f\"\\n\u26a0 Found {len(attribute_errors)} AttributeError entries in the log:\")\n                for error in attribute_errors:\n                    print(f\"  {error.strip()}\")\n            \n            if errors:\n                print(f\"\\n\u26a0 Found {len(errors)} ERROR entries in the log:\")\n                for error in errors[:5]:  # Limit to first 5 errors\n                    print(f\"  {error.strip()}\")\n                if len(errors) > 5:\n                    print(f\"  ... (and {len(errors) - 5} more)\")\n                    \n            if warnings:\n                print(f\"\\n\u26a0 Found {len(warnings)} WARNING entries in the log:\")\n                for warning in warnings[:5]:  # Limit to first 5 warnings\n                    print(f\"  {warning.strip()}\")\n                if len(warnings) > 5:\n                    print(f\"  ... (and {len(warnings) - 5} more)\")\n                    \n            if not errors and not warnings:\n                print(\"\u2713 No errors or warnings found in recent logs\")\n                \n            # Pattern recognition in errors\n            patterns = {\n                \"attribute_error\": (r\"AttributeError: '.*' object has no attribute '.*'\", \n                                   \"Missing attributes or methods - consider using the runtime_patching.py utility\"),\n                \"module_error\": (r\"ModuleNotFoundError: No module named '.*'\",\n                                \"Missing Python module - check your dependencies\"),\n                \"key_error\": (r\"KeyError: '.*'\",\n                             \"Dictionary key error - check your configuration and data structures\"),\n                \"value_error\": (r\"ValueError\",\n                               \"Value error - check parameter types and values\"),\n                \"index_error\": (r\"IndexError\",\n                               \"Index error - list index out of range\"),\n                \"file_error\": (r\"FileNotFoundError\",\n                              \"File not found - check file paths\")\n            }\n            \n            pattern_counts = {name: 0 for name in patterns}\n            \n            for line in errors:\n                for pattern_name, (pattern, _) in patterns.items():\n                    if re.search(pattern, line, re.IGNORECASE):\n                        pattern_counts[pattern_name] += 1\n            \n            recurring_issues = [(name, count) for name, count in pattern_counts.items() if count > 0]\n            if recurring_issues:\n                print(\"\\n\u26a0 Recurring error patterns detected:\")\n                for name, count in recurring_issues:\n                    pattern, suggestion = patterns[name]\n                    print(f\"  - {name}: {count} occurrences - {suggestion}\")\n                \n    except Exception as e:\n        print(f\"\u26a0 Error analyzing log files: {e}\")\n        return False\n    \n    return True\n\ndef check_runtime_patching():\n    \"\"\"Check if runtime patching utilities are available and properly configured\"\"\"\n    print_header(\"RUNTIME PATCHING CHECK\")\n    \n    # Check for the runtime_patching.py utility\n    if not os.path.exists(\"utils/runtime_patching.py\"):\n        print(\"\u26a0 runtime_patching.py utility not found!\")\n        print(\"This utility can help prevent AttributeError crashes.\")\n        print(\"Consider adding this file to provide automatic attribute error handling.\")\n        return False\n    \n    try:\n        # Check if it's properly integrated in the main application\n        with open(\"irintai.py\", 'r') as f:\n            content = f.read()\n            \n        if \"runtime_patching\" in content and \"patch_plugin_manager\" in content:\n            print(\"\u2713 Runtime patching is integrated in the main application\")\n            \n            # Check if utils/__init__.py imports and exposes these functions\n            with open(\"utils/__init__.py\", 'r') as f:\n                init_content = f.read()\n                \n            if \"runtime_patching\" in init_content:\n                print(\"\u2713 Runtime patching is properly exposed in utils/__init__.py\")\n            else:\n                print(\"\u26a0 Runtime patching is not properly exposed in utils/__init__.py\")\n                print(\"Add the following to utils/__init__.py:\")\n                print(\"from .runtime_patching import ensure_attribute_exists, ensure_method_exists, patch_plugin_manager\")\n                print('__all__ += [\"ensure_attribute_exists\", \"ensure_method_exists\", \"patch_plugin_manager\"]')\n        else:\n            print(\"\u26a0 Runtime patching is not integrated in the main application\")\n            print(\"Consider adding the following to irintai.py after creating the plugin manager:\")\n            print(\"from utils.runtime_patching import patch_plugin_manager\")\n            print(\"plugin_manager = patch_plugin_manager(plugin_manager)\")\n        \n        # Try to import and use the patching utility\n        sys.path.insert(0, os.getcwd())\n        from diagnostics.runtime_patching import patch_plugin_manager, ensure_method_exists\n        \n        # Create a test object to verify the patching works\n        class TestObject:\n            pass\n            \n        test_obj = TestObject()\n        ensure_method_exists(test_obj, \"test_method\")\n        \n        if hasattr(test_obj, \"test_method\"):\n            print(\"\u2713 Runtime patching utility is working correctly\")\n            return True\n        else:\n            print(\"\u26a0 Runtime patching utility is not working correctly\")\n            return False\n            \n    except ImportError:\n        print(\"\u26a0 Could not import runtime_patching module!\")\n        return False\n    except Exception as e:\n        print(f\"\u26a0 Error checking runtime patching: {e}\")\n        return False\n\ndef check_model_environment():\n    \"\"\"Check model environment variables and directories\"\"\"\n    print_header(\"MODEL ENVIRONMENT CHECK\")\n    \n    issues_found = False\n    \n    # Check environment variables\n    ollama_home = os.environ.get(\"OLLAMA_HOME\")\n    ollama_models = os.environ.get(\"OLLAMA_MODELS\")\n    \n    # Check OLLAMA_HOME\n    if ollama_home:\n        print(f\"\u2713 OLLAMA_HOME is set: {ollama_home}\")\n        if not os.path.exists(ollama_home):\n            print(f\"\u26a0 OLLAMA_HOME directory does not exist: {ollama_home}\")\n            issues_found = True\n        elif not os.path.isdir(ollama_home):\n            print(f\"\u26a0 OLLAMA_HOME is not a directory: {ollama_home}\")\n            issues_found = True\n        elif not os.access(ollama_home, os.R_OK | os.W_OK):\n            print(f\"\u26a0 OLLAMA_HOME has insufficient permissions: {ollama_home}\")\n            issues_found = True\n    else:\n        print(\"\u26a0 OLLAMA_HOME is not set\")\n        issues_found = True\n    \n    # Check OLLAMA_MODELS\n    if ollama_models:\n        print(f\"\u2713 OLLAMA_MODELS is set: {ollama_models}\")\n        if not os.path.exists(ollama_models):\n            print(f\"\u26a0 OLLAMA_MODELS directory does not exist: {ollama_models}\")\n            issues_found = True\n        elif not os.path.isdir(ollama_models):\n            print(f\"\u26a0 OLLAMA_MODELS is not a directory: {ollama_models}\")\n            issues_found = True\n        elif not os.access(ollama_models, os.R_OK | os.W_OK):\n            print(f\"\u26a0 OLLAMA_MODELS has insufficient permissions: {ollama_models}\")\n            issues_found = True\n    else:\n        print(\"\u26a0 OLLAMA_MODELS is not set\")\n        issues_found = True\n    \n    # Check for models in config.json\n    if os.path.exists(\"data/config.json\"):\n        try:\n            with open(\"data/config.json\", 'r') as file:\n                config = json.load(file)\n            \n            model_path = config.get(\"model_path\")\n            if model_path:\n                print(f\"\u2713 model_path in config: {model_path}\")\n                \n                # Check if model_path exists and has proper permissions\n                if not os.path.exists(model_path):\n                    print(f\"\u26a0 model_path directory does not exist: {model_path}\")\n                    issues_found = True\n                elif not os.path.isdir(model_path):\n                    print(f\"\u26a0 model_path is not a directory: {model_path}\")\n                    issues_found = True\n                elif not os.access(model_path, os.R_OK | os.W_OK):\n                    print(f\"\u26a0 model_path has insufficient permissions: {model_path}\")\n                    issues_found = True\n                    \n                # Check if model_path matches OLLAMA_MODELS\n                if ollama_models and ollama_models != model_path:\n                    print(f\"\u26a0 model_path ({model_path}) doesn't match OLLAMA_MODELS ({ollama_models})\")\n                    issues_found = True\n            else:\n                print(\"\u26a0 model_path not defined in config.json\")\n                issues_found = True\n                \n            # Check current model setting\n            current_model = config.get(\"model\")\n            if current_model:\n                print(f\"\u2713 Current model in config: {current_model}\")\n                \n                # Try to verify if the model exists with ollama list\n                try:\n                    result = subprocess.run(\n                        [\"ollama\", \"list\"],\n                        capture_output=True,\n                        text=True,\n                        timeout=5\n                    )\n                    \n                    if result.returncode == 0:\n                        models = []\n                        for line in result.stdout.strip().splitlines():\n                            if line and not line.startswith(\"NAME\"):  # Skip header\n                                parts = line.split()\n                                if parts:\n                                    models.append(parts[0])\n                        \n                        if current_model in models:\n                            print(f\"\u2713 Model '{current_model}' is installed\")\n                        else:\n                            print(f\"\u26a0 Model '{current_model}' is not installed! This will cause model loading to fail.\")\n                            issues_found = True\n                    else:\n                        print(\"\u26a0 Couldn't verify model installation status (ollama list failed)\")\n                        issues_found = True\n                        \n                except Exception as e:\n                    print(f\"\u26a0 Error checking model installation: {e}\")\n                    issues_found = True\n            else:\n                print(\"\u26a0 No default model specified in config.json\")\n                issues_found = True\n                \n        except json.JSONDecodeError:\n            print(\"\u26a0 config.json contains invalid JSON\")\n            issues_found = True\n        except Exception as e:\n            print(f\"\u26a0 Error checking configuration: {e}\")\n            issues_found = True\n    else:\n        print(\"\u26a0 config.json file not found\")\n        issues_found = True\n    \n    # Check disk space in model directory\n    try:\n        model_dir = ollama_models or \"data/models\"\n        if os.path.exists(model_dir):\n            import shutil\n            usage = shutil.disk_usage(model_dir)\n            free_gb = round(usage.free / (1024**3), 2)\n            total_gb = round(usage.total / (1024**3), 2)\n            percent_free = round((usage.free / usage.total) * 100, 1)\n            \n            print(f\"\\nDisk space in model directory ({model_dir}):\")\n            print(f\"  Total: {total_gb} GB\")\n            print(f\"  Free: {free_gb} GB ({percent_free}%)\")\n            \n            if free_gb < 10:\n                print(f\"\u26a0 Low disk space! Less than 10GB available. This may prevent model downloads.\")\n                issues_found = True\n        else:\n            print(f\"\u26a0 Model directory doesn't exist: {model_dir}\")\n            issues_found = True\n    except Exception as e:\n        print(f\"\u26a0 Error checking disk space: {e}\")\n        issues_found = True\n    \n    if not issues_found:\n        print(\"\\n\u2713 No model environment issues detected\")\n        \n    return not issues_found\n\ndef check_ollama_service():\n    \"\"\"Check if Ollama is installed and running properly\"\"\"\n    print_header(\"OLLAMA SERVICE CHECK\")\n    \n    try:\n        # First check if ollama executable is available\n        result = subprocess.run(\n            [\"ollama\", \"--version\"],\n            capture_output=True,\n            text=True,\n            timeout=5\n        )\n        \n        if result.returncode != 0:\n            print(\"\u2717 Ollama is not installed or not in PATH\")\n            print(\"\\nInstall Ollama from: https://ollama.ai/download\")\n            print(\"Make sure it's added to your system PATH\")\n            return False\n            \n        # Get version information\n        version = result.stdout.strip() or \"Unknown\"\n        print(f\"\u2713 Ollama is installed (version: {version})\")\n        \n        # Check if ollama service is running\n        print(\"\\nChecking if Ollama service is running...\")\n        \n        # Try to list models as a service check\n        result = subprocess.run(\n            [\"ollama\", \"list\"],\n            capture_output=True,\n            text=True,\n            timeout=10\n        )\n        \n        if result.returncode == 0:\n            print(\"\u2713 Ollama service is running properly\")\n            \n            # Show available models\n            models = []\n            lines = result.stdout.strip().splitlines()\n            if len(lines) > 1:  # Skip header\n                for line in lines[1:]:\n                    if line.strip():\n                        models.append(line.split()[0])\n                        \n                print(f\"\\nFound {len(models)} installed models: {', '.join(models)}\")\n            else:\n                print(\"\\n\u26a0 No models are currently installed\")\n                print(\"Install models using: ollama pull <model_name>\")\n        else:\n            print(\"\u2717 Ollama service is not running properly\")\n            print(f\"Error: {result.stderr.strip()}\")\n            \n            # Check for common error messages\n            error = result.stderr.lower()\n            if \"connection refused\" in error:\n                print(\"\\nThe Ollama service is not running. To start it:\")\n                print(\"- Windows: Start the Ollama application\")\n                print(\"- Mac: Open Ollama application\")\n                print(\"- Linux: Run 'systemctl start ollama' or 'ollama serve' in a terminal\")\n            elif \"not found\" in error:\n                print(\"\\nOllama might not be properly installed. Please reinstall.\")\n            \n            return False\n            \n        return True\n        \n    except FileNotFoundError:\n        print(\"\u2717 Ollama is not installed or not in PATH\")\n        print(\"\\nInstall Ollama from: https://ollama.ai/download\")\n        return False\n    except subprocess.TimeoutExpired:\n        print(\"\u2717 Ollama command timed out - service may be hanging\")\n        return False\n    except Exception as e:\n        print(f\"\u2717 Error checking Ollama service: {e}\")\n        return False\n\ndef print_header(text):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'=' * 80}\")\n    print(f\" {text}\")\n    print(f\"{'=' * 80}\")\n\ndef check_ollama_installation():\n    \"\"\"Check if Ollama is installed and working properly\"\"\"\n    print_header(\"OLLAMA INSTALLATION CHECK\")\n    \n    try:\n        # Check if ollama executable is available\n        result = subprocess.run(\n            [\"ollama\", \"--version\"],\n            capture_output=True,\n            text=True,\n            timeout=5\n        )\n        \n        if result.returncode != 0:\n            print(\"\u2717 Ollama is not installed or not in PATH\")\n            print(\"\\nInstall Ollama from: https://ollama.ai/download\")\n            print(\"Make sure it's added to your system PATH\")\n            return False\n            \n        # Get version information\n        version = result.stdout.strip() or \"Unknown\"\n        print(f\"\u2713 Ollama is installed (version: {version})\")\n        return True\n        \n    except FileNotFoundError:\n        print(\"\u2717 Ollama is not installed or not in PATH\")\n        print(\"\\nInstall Ollama from: https://ollama.ai/download\")\n        return False\n    except subprocess.TimeoutExpired:\n        print(\"\u2717 Ollama command timed out - service may be hanging\")\n        return False\n    except Exception as e:\n        print(f\"\u2717 Error checking Ollama installation: {e}\")\n        return False\n\ndef check_ollama_service():\n    \"\"\"Check if Ollama service is running properly\"\"\"\n    print_header(\"OLLAMA SERVICE CHECK\")\n    \n    try:\n        # Try to list models as a service health check\n        result = subprocess.run(\n            [\"ollama\", \"list\"],\n            capture_output=True,\n            text=True,\n            timeout=10\n        )\n        \n        if result.returncode == 0:\n            print(\"\u2713 Ollama service is running properly\")\n            \n            # Show available models\n            models = []\n            lines = result.stdout.strip().splitlines()\n            if len(lines) > 1:  # Skip header\n                for line in lines[1:]:\n                    if line.strip():\n                        parts = line.split()\n                        if parts:\n                            models.append(parts[0])\n                        \n                print(f\"\\nFound {len(models)} installed models: {', '.join(models)}\")\n            else:\n                print(\"\\n\u26a0 No models are currently installed\")\n                print(\"Install models using: ollama pull <model_name>\")\n                \n            return True\n        else:\n            print(\"\u2717 Ollama service is not running properly\")\n            print(f\"Error: {result.stderr.strip()}\")\n            \n            # Check for common error messages\n            error = result.stderr.lower()\n            if \"connection refused\" in error:\n                print(\"\\nThe Ollama service is not running. To start it:\")\n                print(\"- Windows: Start the Ollama application\")\n                print(\"- Mac: Open Ollama application\")\n                print(\"- Linux: Run 'systemctl start ollama' or 'ollama serve' in a terminal\")\n            elif \"not found\" in error:\n                print(\"\\nOllama might not be properly installed. Please reinstall.\")\n            \n            return False\n            \n    except FileNotFoundError:\n        print(\"\u2717 Ollama executable not found in PATH\")\n        return False\n    except subprocess.TimeoutExpired:\n        print(\"\u2717 Ollama command timed out - service may be hanging\")\n        return False\n    except Exception as e:\n        print(f\"\u2717 Error checking Ollama service: {e}\")\n        return False\n\ndef check_environment_variables():\n    \"\"\"Check environment variables related to Ollama models\"\"\"\n    print_header(\"MODEL ENVIRONMENT VARIABLES\")\n    \n    issues_found = False\n    \n    # Check environment variables\n    ollama_home = os.environ.get(\"OLLAMA_HOME\")\n    ollama_models = os.environ.get(\"OLLAMA_MODELS\")\n    \n    # Check OLLAMA_HOME\n    if ollama_home:\n        print(f\"\u2713 OLLAMA_HOME is set to: {ollama_home}\")\n        if not os.path.exists(ollama_home):\n            print(f\"\u26a0 OLLAMA_HOME directory does not exist: {ollama_home}\")\n            issues_found = True\n        elif not os.path.isdir(ollama_home):\n            print(f\"\u26a0 OLLAMA_HOME is not a directory: {ollama_home}\")\n            issues_found = True\n        elif not os.access(ollama_home, os.R_OK | os.W_OK):\n            print(f\"\u26a0 OLLAMA_HOME has insufficient permissions: {ollama_home}\")\n            issues_found = True\n    else:\n        print(\"\u26a0 OLLAMA_HOME is not set - this may cause model location issues\")\n        issues_found = True\n    \n    # Check OLLAMA_MODELS\n    if ollama_models:\n        print(f\"\u2713 OLLAMA_MODELS is set to: {ollama_models}\")\n        if not os.path.exists(ollama_models):\n            print(f\"\u26a0 OLLAMA_MODELS directory does not exist: {ollama_models}\")\n            issues_found = True\n        elif not os.path.isdir(ollama_models):\n            print(f\"\u26a0 OLLAMA_MODELS is not a directory: {ollama_models}\")\n            issues_found = True\n        elif not os.access(ollama_models, os.R_OK | os.W_OK):\n            print(f\"\u26a0 OLLAMA_MODELS has insufficient permissions: {ollama_models}\")\n            issues_found = True\n    else:\n        print(\"\u26a0 OLLAMA_MODELS is not set - this may cause model download issues\")\n        issues_found = True\n    \n    return not issues_found\n\ndef check_model_configuration():\n    \"\"\"Check model configuration in config.json\"\"\"\n    print_header(\"MODEL CONFIGURATION CHECK\")\n    \n    issues_found = False\n    config_file = \"data/config.json\"\n    \n    if not os.path.exists(config_file):\n        print(f\"\u2717 Configuration file not found: {config_file}\")\n        return False\n    \n    try:\n        with open(config_file, 'r') as file:\n            config = json.load(file)\n        \n        print(\"\u2713 Successfully loaded configuration file\")\n        \n        # Check model path\n        model_path = config.get(\"model_path\")\n        if model_path:\n            print(f\"\u2713 model_path in config: {model_path}\")\n            \n            # Check if model_path exists and has proper permissions\n            if not os.path.exists(model_path):\n                print(f\"\u26a0 model_path directory does not exist: {model_path}\")\n                print(\"  Creating directory...\")\n                try:\n                    os.makedirs(model_path, exist_ok=True)\n                    print(f\"\u2713 Created directory: {model_path}\")\n                except Exception as e:\n                    print(f\"\u2717 Failed to create directory: {e}\")\n                issues_found = True\n            elif not os.path.isdir(model_path):\n                print(f\"\u26a0 model_path is not a directory: {model_path}\")\n                issues_found = True\n            elif not os.access(model_path, os.R_OK | os.W_OK):\n                print(f\"\u26a0 model_path has insufficient permissions: {model_path}\")\n                issues_found = True\n                \n            # Check if model_path matches environment variables\n            ollama_models = os.environ.get(\"OLLAMA_MODELS\")\n            if ollama_models and ollama_models != model_path:\n                print(f\"\u26a0 model_path ({model_path}) doesn't match OLLAMA_MODELS ({ollama_models})\")\n                print(\"  This discrepancy can cause models to be saved in one location but searched in another\")\n                issues_found = True\n        else:\n            print(\"\u26a0 model_path not defined in config.json\")\n            issues_found = True\n            \n        # Check current model\n        current_model = config.get(\"model\")\n        if current_model:\n            print(f\"\u2713 Current model in config: {current_model}\")\n            \n            # Check if model exists\n            try:\n                result = subprocess.run(\n                    [\"ollama\", \"list\"],\n                    capture_output=True,\n                    text=True,\n                    timeout=5\n                )\n                \n                if result.returncode == 0:\n                    models = []\n                    for line in result.stdout.strip().splitlines():\n                        if line and not line.startswith(\"NAME\"):  # Skip header\n                            parts = line.split()\n                            if parts:\n                                models.append(parts[0])\n                    \n                    if current_model in models:\n                        print(f\"\u2713 Model '{current_model}' is installed\")\n                    else:\n                        print(f\"\u26a0 Model '{current_model}' is not installed! This will cause model loading to fail.\")\n                        issues_found = True\n                        \n                        # Show available models\n                        if models:\n                            print(f\"\\nAvailable models: {', '.join(models)}\")\n                            print(\"\\nTo install the configured model, run:\")\n                            print(f\"ollama pull {current_model}\")\n                else:\n                    print(\"\u26a0 Couldn't verify model installation (ollama list command failed)\")\n                    issues_found = True\n                    \n            except Exception as e:\n                print(f\"\u26a0 Error checking model installation: {e}\")\n                issues_found = True\n        else:\n            print(\"\u26a0 No model specified in config.json\")\n            issues_found = True\n        \n        # Check other model settings\n        use_8bit = config.get(\"use_8bit\")\n        if use_8bit is not None:\n            print(f\"\u2713 use_8bit is set to: {use_8bit}\")\n        else:\n            print(\"\u2139 use_8bit is not set (defaults to false)\")\n            \n    except json.JSONDecodeError:\n        print(\"\u2717 config.json contains invalid JSON\")\n        issues_found = True\n    except Exception as e:\n        print(f\"\u2717 Error checking configuration: {e}\")\n        issues_found = True\n    \n    return not issues_found\n\ndef check_system_resources():\n    \"\"\"Check system resources for model execution\"\"\"\n    print_header(\"SYSTEM RESOURCES CHECK\")\n    \n    issues_found = False\n    \n    # Check disk space\n    try:\n        model_dir = os.environ.get(\"OLLAMA_MODELS\") or \"data/models\"\n        if os.path.exists(model_dir):\n            usage = shutil.disk_usage(model_dir)\n            free_gb = round(usage.free / (1024**3), 2)\n            total_gb = round(usage.total / (1024**3), 2)\n            percent_free = round((usage.free / usage.total) * 100, 1)\n            \n            print(f\"Disk space in model directory ({model_dir}):\")\n            print(f\"  Total: {total_gb} GB\")\n            print(f\"  Free: {free_gb} GB ({percent_free}%)\")\n            \n            if free_gb < 10:\n                print(f\"\u26a0 Low disk space! Less than 10GB available. This may prevent model downloads.\")\n                issues_found = True\n        else:\n            print(f\"\u26a0 Model directory doesn't exist: {model_dir}\")\n            issues_found = True\n    except Exception as e:\n        print(f\"\u26a0 Error checking disk space: {e}\")\n        issues_found = True\n    \n    # Check memory\n    try:\n        import psutil\n        total_ram_gb = round(psutil.virtual_memory().total / (1024**3), 2)\n        available_ram_gb = round(psutil.virtual_memory().available / (1024**3), 2)\n        \n        print(f\"\\nSystem memory:\")\n        print(f\"  Total RAM: {total_ram_gb} GB\")\n        print(f\"  Available RAM: {available_ram_gb} GB\")\n        \n        if total_ram_gb < 8:\n            print(\"\u26a0 System has less than 8GB of total RAM. This may be insufficient for running larger models.\")\n            issues_found = True\n        elif available_ram_gb < 4:\n            print(\"\u26a0 Less than 4GB of RAM is currently available. Close other applications before running models.\")\n            issues_found = True\n        else:\n            print(\"\u2713 System has sufficient RAM for model execution\")\n    except ImportError:\n        print(\"Could not check memory - psutil module not installed\")\n        print(\"Install with: pip install psutil\")\n    except Exception as e:\n        print(f\"Error checking system memory: {e}\")\n        \n    return not issues_found\n\ndef test_model_initialization():\n    \"\"\"Test model initialization\"\"\"\n    print_header(\"MODEL INITIALIZATION TEST\")\n    \n    issues_found = False\n    \n    try:\n        # Add the current directory to path\n        sys.path.insert(0, os.getcwd())\n        \n        # Try to import the model manager\n        print(\"Importing ModelManager...\")\n        try:\n            from core.model_manager import ModelManager\n            print(\"\u2713 Successfully imported ModelManager\")\n        except ImportError as e:\n            print(f\"\u2717 Failed to import ModelManager: {e}\")\n            print(\"Check that the core directory is in your Python path\")\n            return False\n        except Exception as e:\n            print(f\"\u2717 Error importing ModelManager: {e}\")\n            return False\n        \n        # Create a test logger\n        test_logs = []\n        def test_logger(message):\n            test_logs.append(message)\n            print(f\"[LOG] {message}\")\n        \n        # Get model path\n        model_path = \"data/models\"\n        config_file = \"data/config.json\"\n        if os.path.exists(config_file):\n            try:\n                with open(config_file, 'r') as file:\n                    config = json.load(file)\n                model_path = config.get(\"model_path\", model_path)\n            except:\n                pass\n        \n        if not os.path.exists(model_path):\n            try:\n                print(f\"Creating model directory: {model_path}\")\n                os.makedirs(model_path, exist_ok=True)\n            except Exception as e:\n                print(f\"\u2717 Failed to create model directory: {e}\")\n                issues_found = True\n        \n        # Initialize model manager\n        print(f\"\\nInitializing ModelManager with path: {model_path}\")\n        try:\n            model_manager = ModelManager(\n                model_path=model_path,\n                logger=test_logger\n            )\n            print(\"\u2713 Successfully initialized ModelManager\")\n            \n            # Check environment variables were set properly\n            print(\"\\nChecking environment variables set by ModelManager:\")\n            if \"OLLAMA_HOME\" in os.environ:\n                print(f\"\u2713 OLLAMA_HOME set to: {os.environ['OLLAMA_HOME']}\")\n            else:\n                print(\"\u2717 OLLAMA_HOME was not set by ModelManager\")\n                issues_found = True\n                \n            if \"OLLAMA_MODELS\" in os.environ:\n                print(f\"\u2713 OLLAMA_MODELS set to: {os.environ['OLLAMA_MODELS']}\")\n            else:\n                print(\"\u2717 OLLAMA_MODELS was not set by ModelManager\")\n                issues_found = True\n            \n            # Test model detection\n            print(\"\\nTesting model detection...\")\n            try:\n                available_models = model_manager.detect_models()\n                if available_models:\n                    print(f\"\u2713 Found {len(available_models)} installed models: {', '.join(available_models)}\")\n                else:\n                    print(\"\u26a0 No models detected\")\n                    print(\"  This could be normal if no models have been installed yet.\")\n            except Exception as e:\n                print(f\"\u2717 Error detecting models: {e}\")\n                traceback.print_exc()\n                issues_found = True\n                \n            # Check for model statuses\n            print(\"\\nChecking model statuses:\")\n            try:\n                if hasattr(model_manager, 'model_statuses') and model_manager.model_statuses:\n                    print(\"\u2713 Model statuses initialized\")\n                    for model_name, status in model_manager.model_statuses.items():\n                        print(f\"  - {model_name}: {status}\")\n                else:\n                    print(\"\u26a0 No model statuses available\")\n            except Exception as e:\n                print(f\"\u2717 Error checking model statuses: {e}\")\n                issues_found = True\n                \n            # Check for current model\n            print(\"\\nChecking current model:\")\n            try:\n                current_model = model_manager.current_model\n                if current_model:\n                    print(f\"\u2713 Current model is set to: {current_model}\")\n                else:\n                    print(\"\u26a0 No current model is set\")\n            except Exception as e:\n                print(f\"\u2717 Error checking current model: {e}\")\n                issues_found = True\n                \n        except Exception as e:\n            print(f\"\u2717 Failed to initialize ModelManager: {e}\")\n            traceback.print_exc()\n            issues_found = True\n            \n        # Check for any errors in the test logs\n        errors = [log for log in test_logs if \"[Error]\" in log or \"failed\" in log.lower()]\n        if errors:\n            print(\"\\n\u26a0 Errors detected during model initialization:\")\n            for error in errors:\n                print(f\"  {error}\")\n            issues_found = True\n            \n    except Exception as e:\n        print(f\"\u2717 Error in model initialization test: {e}\")\n        traceback.print_exc()\n        issues_found = True\n        \n    return not issues_found\n\ndef check_model_panel():\n    \"\"\"Check model panel UI integration\"\"\"\n    print_header(\"MODEL PANEL UI CHECK\")\n    \n    issues_found = False\n    \n    try:\n        # Add the current directory to path\n        sys.path.insert(0, os.getcwd())\n        \n        # Try to import the model panel\n        print(\"Importing ModelPanel...\")\n        try:\n            from ui.panels.model_panel import ModelPanel\n            print(\"\u2713 Successfully imported ModelPanel\")\n        except ImportError as e:\n            print(f\"\u2717 Failed to import ModelPanel: {e}\")\n            print(\"Check that the ui directory is in your Python path\")\n            return False\n        except Exception as e:\n            print(f\"\u2717 Error importing ModelPanel: {e}\")\n            return False\n        \n        # Check ModelPanel implementation\n        print(\"\\nChecking ModelPanel implementation...\")\n        \n        # Read the model_panel.py file\n        model_panel_path = \"ui/model_panel.py\"\n        if os.path.exists(model_panel_path):\n            try:\n                with open(model_panel_path, 'r') as file:\n                    content = file.read()\n                \n                # Check for key methods\n                key_methods = [\n                    \"refresh_model_list\", \n                    \"install_selected_model\",\n                    \"start_selected_model\", \n                    \"stop_running_model\",\n                    \"_update_model_status\",\n                ]\n                \n                missing_methods = []\n                for method in key_methods:\n                    if f\"def {method}\" not in content:\n                        missing_methods.append(method)\n                \n                if missing_methods:\n                    print(f\"\u26a0 ModelPanel is missing key methods: {', '.join(missing_methods)}\")\n                    issues_found = True\n                else:\n                    print(\"\u2713 ModelPanel has all key methods implemented\")\n                    \n                # Check model initialization\n                if \"self.model_manager = model_manager\" in content:\n                    print(\"\u2713 ModelPanel correctly stores the model_manager reference\")\n                else:\n                    print(\"\u26a0 ModelPanel might not correctly store the model_manager reference\")\n                    issues_found = True\n                    \n            except Exception as e:\n                print(f\"\u2717 Error analyzing ModelPanel code: {e}\")\n                issues_found = True\n        else:\n            print(f\"\u2717 ModelPanel file not found: {model_panel_path}\")\n            issues_found = True\n            \n    except Exception as e:\n        print(f\"\u2717 Error checking model panel: {e}\")\n        issues_found = True\n        \n    return not issues_found\n\ndef check_model_logs():\n    \"\"\"Analyze logs for model-related issues\"\"\"\n    print_header(\"MODEL LOG ANALYSIS\")\n    \n    issues_found = False\n    log_file = \"irintai_debug.log\"\n    log_dir = \"data/logs\"\n    \n    # Find the most recent log file\n    if not os.path.exists(log_file):\n        if os.path.exists(log_dir):\n            log_files = sorted([f for f in os.listdir(log_dir) if f.startswith(\"irintai_debug_\")], reverse=True)\n            if log_files:\n                log_file = os.path.join(log_dir, log_files[0])\n                print(f\"Using most recent log: {log_file}\")\n            else:\n                print(\"\u26a0 No log files found!\")\n                return False\n        else:\n            print(\"\u26a0 Log directory not found!\")\n            return False\n    \n    try:\n        with open(log_file, 'r', encoding='utf-8', errors='replace') as file:\n            log_content = file.read()\n            \n        # Split into lines for analysis\n        log_lines = log_content.split('\\n')\n        \n        # Look for model-related errors\n        model_errors = []\n        for line in log_lines:\n            if \"[Error]\" in line and any(term in line for term in [\"model\", \"Model\", \"ollama\", \"Ollama\"]):\n                model_errors.append(line)\n                \n        if model_errors:\n            print(f\"\u26a0 Found {len(model_errors)} model-related errors in logs:\")\n            for error in model_errors[:5]:  # Show at most 5 errors\n                print(f\"  {error}\")\n            if len(model_errors) > 5:\n                print(f\"  ... and {len(model_errors) - 5} more\")\n            issues_found = True\n            \n        # Look for specific error patterns\n        error_patterns = {\n            \"no_ollama\": [\"command not found\", \"ollama\", \"executable\"],\n            \"connection_refused\": [\"connection refused\", \"could not connect\"],\n            \"model_not_found\": [\"model not found\", \"no such model\"],\n            \"model_download_failed\": [\"download failed\", \"failed to pull\"],\n            \"model_run_failed\": [\"failed to start model\", \"error running model\"],\n            \"model_stop_failed\": [\"failed to stop model\", \"error stopping model\"],\n            \"attribute_error\": [\"AttributeError\", \"has no attribute\"]\n        }\n        \n        pattern_matches = {pattern: [] for pattern in error_patterns}\n        \n        for line in log_lines:\n            if \"[Error]\" in line or \"[WARNING]\" in line:\n                for pattern, keywords in error_patterns.items():\n                    if all(keyword.lower() in line.lower() for keyword in keywords):\n                        pattern_matches[pattern].append(line)\n        \n        # Report on patterns found\n        found_patterns = False\n        for pattern, matches in pattern_matches.items():\n            if matches:\n                if not found_patterns:\n                    print(\"\\nDetected error patterns:\")\n                    found_patterns = True\n                    \n                print(f\"  - {pattern}: {len(matches)} occurrences\")\n                # Show an example\n                if matches:\n                    print(f\"    Example: {matches[0]}\")\n                issues_found = True\n                \n                # Provide specific advice based on the pattern\n                if pattern == \"no_ollama\":\n                    print(\"    Fix: Install Ollama from https://ollama.ai/download\")\n                elif pattern == \"connection_refused\":\n                    print(\"    Fix: Start the Ollama service before running IrintAI\")\n                elif pattern == \"model_not_found\":\n                    print(\"    Fix: Install the model with 'ollama pull <model_name>'\")\n                elif pattern == \"model_download_failed\":\n                    print(\"    Fix: Check your internet connection and disk space\")\n                elif pattern == \"attribute_error\":\n                    print(\"    Fix: Update your code to use the correct attribute names or implement missing methods\")\n        \n        if not model_errors and not found_patterns:\n            print(\"\u2713 No model-related errors found in logs\")\n            \n    except Exception as e:\n        print(f\"\u2717 Error analyzing logs: {e}\")\n        issues_found = True\n        \n    return not issues_found\n\ndef run_full_model_diagnostics():\n    \"\"\"Run all model diagnostic checks\"\"\"\n    print_header(\"FULL MODEL DIAGNOSTICS\")\n    results = {}\n    \n    # Define all the diagnostic checks\n    checks = [\n        (\"Ollama Installation\", check_ollama_installation),\n        (\"Ollama Service\", check_ollama_service),\n        (\"Environment Variables\", check_environment_variables),\n        (\"Model Configuration\", check_model_configuration),\n        (\"System Resources\", check_system_resources),\n        (\"Model Initialization\", test_model_initialization),\n        (\"Model Panel UI\", check_model_panel),\n        (\"Model Logs\", check_model_logs)\n    ]\n    \n    # Run all checks\n    all_passed = True\n    for name, check_func in checks:\n        print(f\"\\nRunning {name} check...\")\n        \n        try:\n            result = check_func()\n            results[name] = \"\u2713 PASS\" if result else \"\u2717 FAIL\"\n            if not result:\n                all_passed = False\n        except Exception as e:\n            print(f\"\\n\u2717 Error during {name} check: {e}\")\n            traceback.print_exc()\n            results[name] = \"\u2717 ERROR\"\n            all_passed = False\n            \n        # Add some visual separation between checks\n        print(\"\\n\" + \"-\" * 80)\n    \n    # Print summary\n    print_header(\"MODEL DIAGNOSTIC SUMMARY\")\n    \n    for name, result in results.items():\n        print(f\"{name.ljust(25)}: {result}\")\n    \n    if all_passed:\n        print(\"\\n\u2713 All model diagnostic checks passed!\")\n    else:\n        print(\"\\n\u26a0 Some model diagnostic checks failed. See details above.\")\n        \n        # Provide recommendations based on failures\n        print(\"\\nRECOMMENDED ACTIONS:\")\n        \n        if results.get(\"Ollama Installation\") == \"\u2717 FAIL\":\n            print(\"  1. Install Ollama from https://ollama.ai/download\")\n            \n        if results.get(\"Ollama Service\") == \"\u2717 FAIL\":\n            print(\"  2. Start the Ollama service\")\n            print(\"     - Windows: Run Ollama application\")\n            print(\"     - Mac: Open Ollama application\")\n            print(\"     - Linux: Run 'systemctl start ollama' or 'ollama serve'\")\n            \n        if results.get(\"Environment Variables\") == \"\u2717 FAIL\" or results.get(\"Model Configuration\") == \"\u2717 FAIL\":\n            print(\"  3. Update your config.json with the correct model_path\")\n            print(\"     - Ensure it matches the OLLAMA_MODELS environment variable\")\n            \n        if results.get(\"Model Initialization\") == \"\u2717 FAIL\":\n            print(\"  4. Check ModelManager implementation\")\n            print(\"     - Ensure all required methods are properly implemented\")\n            print(\"     - Fix any AttributeErrors in the code\")\n            \n        if results.get(\"Model Panel UI\") == \"\u2717 FAIL\":\n            print(\"  5. Fix ModelPanel UI implementation\")\n            print(\"     - Ensure model_manager reference is correctly stored\")\n            print(\"     - Implement all required UI update methods\")\n    \n    # Save report to file\n    try:\n        with open(\"model_diagnostic_report.txt\", \"w\") as f:\n            f.write(\"IRINTAI MODEL DIAGNOSTIC REPORT\\n\")\n            f.write(\"=\" * 50 + \"\\n\\n\")\n            f.write(f\"Date: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n            f.write(\"SUMMARY:\\n\")\n            for name, result in results.items():\n                ascii_result = result.replace(\"\u2713\", \"PASS\").replace(\"\u2717\", \"FAIL\")\n                f.write(f\"{name.ljust(25)}: {ascii_result}\\n\")\n        \n        print(f\"\\nFull report saved to: model_diagnostic_report.txt\")\n        \n    except Exception as e:\n        print(f\"Error saving report: {e}\")\n    \n    return all_passed\n\nif __name__ == \"__main__\":\n    try:\n        print(\"\\nIrintAI Assistant - Model Diagnostics Tool\")\n        print(\"This tool will diagnose issues with model functionality\\n\")\n        \n        run_full_model_diagnostics()\n        \n    except Exception as e:\n        print(f\"Unhandled error during diagnostics: {e}\")\n        traceback.print_exc()\n\ndef run_diagnostics():\n    \"\"\"Run all diagnostic checks\"\"\"\n    success = True\n    \n    print(\"\\n\" + \"=\" * 80)\n    print(\" IRINTAI ASSISTANT ENHANCED DIAGNOSTIC TOOL \")\n    print(\"=\" * 80)\n    \n    print(\"\\nRunning comprehensive system diagnostics...\")\n    \n    checks = [\n        (\"Environment\", check_environment),\n        (\"File Structure\", check_file_structure),\n        (\"Dependencies\", check_dependencies),\n        (\"Configuration\", check_config),\n        (\"Plugin Manager\", check_plugin_manager),\n        (\"Interface Consistency\", check_interface_consistency),\n        (\"Runtime Patching\", check_runtime_patching),\n        (\"Ollama Service\", check_ollama_service),\n        (\"Log Analysis\", check_logs),\n        (\"Model Environment\", check_model_environment)\n    ]\n    \n    results = {}\n    \n    for name, check_func in checks:\n        try:\n            result = check_func()\n            results[name] = \"\u2713 PASS\" if result else \"\u2717 FAIL\"\n            if not result:\n                success = False\n        except Exception as e:\n            logger.error(f\"Error in {name} check: {e}\")\n            results[name] = \"\u2717 ERROR\"\n            success = False\n    \n    # Print summary\n    print(\"\\n\" + \"=\" * 80)\n    print(\" DIAGNOSTIC SUMMARY \")\n    print(\"=\" * 80)\n    \n    for name, result in results.items():\n        print(f\"{name.ljust(20)}: {result}\")\n    \n    if success:\n        print(\"\\n\u2705 All diagnostic checks passed!\")\n    else:\n        print(\"\\n\u26a0 Some diagnostic checks failed. See details above.\")\n        \n        # Suggest specific fixes based on results\n        print(\"\\nRecommended actions:\")\n        \n        if results.get(\"Plugin Manager\") == \"\u2717 FAIL\":\n            print(\"  1. Fix plugin manager by adding missing methods (especially set_error_handler)\")\n            print(\"     - Use fix_plugin_manager.py or manually add required methods\")\n            \n        if results.get(\"Interface Consistency\") == \"\u2717 FAIL\":\n            print(\"  2. Fix interface inconsistencies between components\")\n            print(\"     - Implement missing methods or use runtime_patching.py to add them dynamically\")\n            \n        if results.get(\"Runtime Patching\") == \"\u2717 FAIL\":\n            print(\"  3. Implement the runtime_patching utility to prevent attribute errors\")\n            print(\"     - See utils/runtime_patching.py and integrate it into irintai.py\")\n    \n    # Save summary to file - using UTF-8 encoding to handle special characters\n    with open(\"irintai_diagnostic_report.txt\", \"w\", encoding=\"utf-8\") as f:\n        f.write(\"IRINTAI ASSISTANT ENHANCED DIAGNOSTIC REPORT\\n\")\n        f.write(\"=\" * 50 + \"\\n\\n\")\n        f.write(f\"Date: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n        f.write(\"SUMMARY:\\n\")\n        # Convert special characters to ASCII for better compatibility\n        for name, result in results.items():\n            ascii_result = result.replace(\"\u2713\", \"PASS\").replace(\"\u2717\", \"FAIL\")\n            f.write(f\"{name.ljust(20)}: {ascii_result}\\n\")\n            \n        if not success:\n            f.write(\"\\nRECOMMENDED ACTIONS:\\n\")\n            if results.get(\"Plugin Manager\") == \"\u2717 FAIL\":\n                f.write(\"  1. Fix plugin manager by adding missing methods\\n\")\n            if results.get(\"Interface Consistency\") == \"\u2717 FAIL\":\n                f.write(\"  2. Fix interface inconsistencies between components\\n\")\n            if results.get(\"Runtime Patching\") == \"\u2717 FAIL\":\n                f.write(\"  3. Implement runtime patching utilities\\n\")\n    \n    print(f\"\\nFull report saved to: irintai_diagnostic_report.txt\")\n    print(f\"Detailed log saved to: irintai_diagnostic.log\")\n    \n    return success\n\nif __name__ == \"__main__\":\n    try:\n        run_diagnostics()\n    except Exception as e:\n        logger.error(f\"Unhandled exception in diagnostics: {e}\")\n        traceback.print_exc()\n        print(\"\\n\u26a0 An error occurred while running diagnostics.\")\n        sys.exit(1)\n",
  "D:\\AI\\IrintAI Assistant\\ui\\panels\\resource_monitor_panel.py": "\"\"\"\nResource monitor panel for the Irintai assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport time\nimport threading\nimport matplotlib\nmatplotlib.use(\"TkAgg\")\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\nimport matplotlib.animation as animation\nfrom typing import Dict, List, Any, Callable, Optional\nimport math\nimport psutil\nimport random\nimport datetime\n\nclass ResourceMonitorPanel:\n    \"\"\"Panel for monitoring system resources\"\"\"\n    \n    def __init__(self, master, logger=None, system_monitor=None):\n        \"\"\"\n        Initialize the resource monitor panel\n        \n        Args:\n            master: Parent widget\n            logger: Optional logging function\n            system_monitor: Optional SystemMonitor instance\n        \"\"\"\n        self.master = master\n        self.logger = logger\n        self.system_monitor = system_monitor\n        \n        # Create the main frame\n        self.frame = ttk.Frame(master)\n        self.frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Data for plots\n        self.data_points = 60  # 1 minute of data at 1 second intervals\n        self.time_data = list(range(self.data_points))\n        self.cpu_data = [0] * self.data_points\n        self.ram_data = [0] * self.data_points\n        self.gpu_data = [0] * self.data_points\n        \n        # Custom metrics data\n        self.custom_metrics = {}\n        \n        # Animation running flag\n        self.running = False\n        \n        # Create UI components\n        self.create_ui()\n        \n        # Start the update timer\n        self.start_monitoring()\n        \n    def log(self, message, level=\"INFO\"):\n        \"\"\"Log a message if logger is available\"\"\"\n        if self.logger:\n            self.logger(f\"[ResourceMonitor] {message}\", level)\n        \n    def create_ui(self):\n        \"\"\"Create the UI components\"\"\"\n        # Create top frame for current values\n        self.top_frame = ttk.Frame(self.frame)\n        self.top_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Current usage labels\n        ttk.Label(self.top_frame, text=\"Current Usage:\").grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)\n        \n        self.cpu_label = ttk.Label(self.top_frame, text=\"CPU: 0%\")\n        self.cpu_label.grid(row=0, column=1, padx=10, pady=5)\n        \n        self.ram_label = ttk.Label(self.top_frame, text=\"RAM: 0%\")\n        self.ram_label.grid(row=0, column=2, padx=10, pady=5)\n        \n        self.gpu_label = ttk.Label(self.top_frame, text=\"GPU: N/A\")\n        self.gpu_label.grid(row=0, column=3, padx=10, pady=5)\n        \n        self.disk_label = ttk.Label(self.top_frame, text=\"Disk: 0%\")\n        self.disk_label.grid(row=0, column=4, padx=10, pady=5)\n        \n        # Create notebook for tabs\n        self.notebook = ttk.Notebook(self.frame)\n        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n        \n        # Create system tab\n        self.system_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.system_tab, text=\"System\")\n        \n        # Create processes tab\n        self.processes_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.processes_tab, text=\"Processes\")\n        \n        # Create plugins tab\n        self.plugins_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.plugins_tab, text=\"Plugin Metrics\")\n        \n        # Create graph tab\n        self.graph_tab = ttk.Frame(self.notebook)\n        self.notebook.add(self.graph_tab, text=\"Graphs\")\n        \n        # Initialize tabs\n        self.init_system_tab()\n        self.init_processes_tab()\n        self.init_plugins_tab()\n        self.init_graph_tab()\n        \n        # Create bottom frame for controls\n        self.bottom_frame = ttk.Frame(self.frame)\n        self.bottom_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        # Refresh button\n        self.refresh_button = ttk.Button(self.bottom_frame, text=\"Refresh\", command=self.refresh)\n        self.refresh_button.pack(side=tk.LEFT, padx=5)\n        \n        # Export button\n        self.export_button = ttk.Button(self.bottom_frame, text=\"Export\", command=self.export_metrics)\n        self.export_button.pack(side=tk.LEFT, padx=5)\n        \n        # Update interval\n        ttk.Label(self.bottom_frame, text=\"Update interval:\").pack(side=tk.LEFT, padx=(20, 5))\n        \n        self.interval_var = tk.StringVar(value=\"1\")\n        interval_combobox = ttk.Combobox(self.bottom_frame, textvariable=self.interval_var, \n                                        values=[\"1\", \"2\", \"5\", \"10\"], width=5, state=\"readonly\")\n        interval_combobox.pack(side=tk.LEFT)\n        ttk.Label(self.bottom_frame, text=\"seconds\").pack(side=tk.LEFT, padx=5)\n        \n        # Bind interval change\n        interval_combobox.bind(\"<<ComboboxSelected>>\", self.on_interval_changed)\n        \n    def init_system_tab(self):\n        \"\"\"Initialize the system tab\"\"\"\n        # Create frame for system metrics\n        self.system_frame = ttk.Frame(self.system_tab)\n        self.system_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create detailed system info display\n        self.system_tree = ttk.Treeview(self.system_frame, columns=(\"1\", \"2\"), show=\"tree\")\n        self.system_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        # Add scrollbar\n        scrollbar = ttk.Scrollbar(self.system_frame, orient=tk.VERTICAL, command=self.system_tree.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.system_tree.configure(yscrollcommand=scrollbar.set)\n        \n        # Configure columns\n        self.system_tree.column(\"#0\", width=200, minwidth=150)\n        self.system_tree.column(\"1\", width=150, minwidth=100)\n        self.system_tree.column(\"2\", width=250, minwidth=150)\n        \n        # Add root items\n        self.cpu_item = self.system_tree.insert(\"\", \"end\", text=\"CPU\", open=True)\n        self.ram_item = self.system_tree.insert(\"\", \"end\", text=\"Memory\", open=True)\n        self.gpu_item = self.system_tree.insert(\"\", \"end\", text=\"GPU\", open=True)\n        self.disk_item = self.system_tree.insert(\"\", \"end\", text=\"Disk\", open=True)\n        \n    def init_processes_tab(self):\n        \"\"\"Initialize the processes tab\"\"\"\n        # Create frame for processes\n        self.processes_frame = ttk.Frame(self.processes_tab)\n        self.processes_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create processes treeview\n        columns = (\"PID\", \"Name\", \"CPU\", \"Memory\", \"Status\", \"Plugin\")\n        self.processes_tree = ttk.Treeview(self.processes_frame, columns=columns, show=\"headings\")\n        self.processes_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        # Add scrollbar\n        scrollbar = ttk.Scrollbar(self.processes_frame, orient=tk.VERTICAL, command=self.processes_tree.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.processes_tree.configure(yscrollcommand=scrollbar.set)\n        \n        # Configure columns\n        widths = [70, 150, 70, 100, 100, 120]\n        for i, col in enumerate(columns):\n            self.processes_tree.heading(col, text=col, command=lambda c=col: self.sort_processes_tree(c))\n            self.processes_tree.column(col, width=widths[i])\n            \n    def init_plugins_tab(self):\n        \"\"\"Initialize the plugins tab\"\"\"\n        # Create frame for plugin metrics\n        self.plugins_frame = ttk.Frame(self.plugins_tab)\n        self.plugins_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create plugin selection frame\n        self.plugin_select_frame = ttk.Frame(self.plugins_frame)\n        self.plugin_select_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        ttk.Label(self.plugin_select_frame, text=\"Plugin Filter:\").pack(side=tk.LEFT, padx=(0, 5))\n        \n        # Plugin filter dropdown\n        self.plugin_filter_var = tk.StringVar(value=\"All Plugins\")\n        self.plugin_filter_combo = ttk.Combobox(self.plugin_select_frame, textvariable=self.plugin_filter_var, \n                                               state=\"readonly\", width=30)\n        self.plugin_filter_combo.pack(side=tk.LEFT, padx=5)\n        \n        # Bind selection event\n        self.plugin_filter_combo.bind(\"<<ComboboxSelected>>\", self.on_plugin_filter_changed)\n        \n        # Refresh plugin list button\n        ttk.Button(self.plugin_select_frame, text=\"Refresh\", \n                  command=self.refresh_plugin_list).pack(side=tk.LEFT, padx=5)\n        \n        # Add to Graph button\n        ttk.Button(self.plugin_select_frame, text=\"Add to Graph\", \n                  command=self.add_selected_metric_to_graph).pack(side=tk.RIGHT, padx=5)\n        \n        # Create plugin metrics treeview with grouping\n        self.plugins_tree = ttk.Treeview(self.plugins_frame, columns=(\"Value\", \"Format\", \"Description\"), \n                                       show=\"tree headings\")\n        self.plugins_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        # Add scrollbar\n        scrollbar = ttk.Scrollbar(self.plugins_frame, orient=tk.VERTICAL, command=self.plugins_tree.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.plugins_tree.configure(yscrollcommand=scrollbar.set)\n        \n        # Configure columns\n        self.plugins_tree.heading(\"#0\", text=\"Metric\")\n        self.plugins_tree.heading(\"Value\", text=\"Value\")\n        self.plugins_tree.heading(\"Format\", text=\"Format\")\n        self.plugins_tree.heading(\"Description\", text=\"Description\")\n        \n        self.plugins_tree.column(\"#0\", width=200, minwidth=150)\n        self.plugins_tree.column(\"Value\", width=120, minwidth=80)\n        self.plugins_tree.column(\"Format\", width=80, minwidth=60)\n        self.plugins_tree.column(\"Description\", width=300, minwidth=150)\n        \n        # Create right-click menu\n        self.plugin_metrics_menu = tk.Menu(self.plugins_tree, tearoff=0)\n        self.plugin_metrics_menu.add_command(label=\"Add to Graph\", command=self.add_selected_metric_to_graph)\n        self.plugin_metrics_menu.add_command(label=\"Remove from Graph\", command=self.remove_selected_metric_from_graph)\n        self.plugin_metrics_menu.add_separator()\n        self.plugin_metrics_menu.add_command(label=\"Show Details\", command=self.show_metric_details)\n        \n        # Bind right-click\n        self.plugins_tree.bind(\"<Button-3>\", self.show_plugins_tree_menu)\n        \n        # Initialize plugin list and colors\n        self.plugin_colors = {}\n        self.refresh_plugin_list()\n        \n    def init_graph_tab(self):\n        \"\"\"Initialize the graph tab\"\"\"\n        # Create frame for graphs\n        self.graph_frame = ttk.Frame(self.graph_tab)\n        self.graph_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create matplotlib figure\n        self.figure = Figure(figsize=(8, 6), dpi=100)\n        \n        # Create subplot for CPU and RAM\n        self.subplot = self.figure.add_subplot(111)\n        self.subplot.set_title(\"Resource Usage Over Time\")\n        self.subplot.set_xlabel(\"Time (seconds)\")\n        self.subplot.set_ylabel(\"Usage (%)\")\n        self.subplot.set_ylim(0, 100)\n        \n        # Create lines for CPU, RAM, and GPU\n        self.cpu_line, = self.subplot.plot(self.time_data, self.cpu_data, 'b-', label=\"CPU\")\n        self.ram_line, = self.subplot.plot(self.time_data, self.ram_data, 'g-', label=\"RAM\")\n        self.gpu_line, = self.subplot.plot(self.time_data, self.gpu_data, 'r-', label=\"GPU\")\n        \n        # Add legend\n        self.subplot.legend()\n        \n        # Create canvas\n        self.canvas = FigureCanvasTkAgg(self.figure, self.graph_frame)\n        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)\n        \n        # Add custom metrics selection frame\n        self.metrics_frame = ttk.LabelFrame(self.graph_frame, text=\"Metrics Visibility\")\n        self.metrics_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=5)\n        \n        # Create left frame for system metrics\n        system_frame = ttk.Frame(self.metrics_frame)\n        system_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)\n        \n        ttk.Label(system_frame, text=\"System Metrics:\").pack(anchor=tk.W)\n        \n        # Create checkbox variables\n        self.show_cpu_var = tk.BooleanVar(value=True)\n        self.show_ram_var = tk.BooleanVar(value=True)\n        self.show_gpu_var = tk.BooleanVar(value=True)\n        \n        # Add checkboxes\n        ttk.Checkbutton(system_frame, text=\"CPU\", variable=self.show_cpu_var, \n                       command=self.update_graph_visibility).pack(anchor=tk.W)\n        ttk.Checkbutton(system_frame, text=\"RAM\", variable=self.show_ram_var, \n                       command=self.update_graph_visibility).pack(anchor=tk.W)\n        ttk.Checkbutton(system_frame, text=\"GPU\", variable=self.show_gpu_var, \n                       command=self.update_graph_visibility).pack(anchor=tk.W)\n        \n        # Create right frame for plugin metrics\n        self.plugin_metrics_frame = ttk.Frame(self.metrics_frame)\n        self.plugin_metrics_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)\n        \n        ttk.Label(self.plugin_metrics_frame, text=\"Plugin Metrics:\").pack(anchor=tk.W)\n        \n        # Scrollable frame for plugin metric checkboxes\n        self.plugin_checkboxes_canvas = tk.Canvas(self.plugin_metrics_frame, height=100)\n        self.plugin_checkboxes_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        scrollbar = ttk.Scrollbar(self.plugin_metrics_frame, orient=tk.VERTICAL, command=self.plugin_checkboxes_canvas.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        self.plugin_checkboxes_canvas.configure(yscrollcommand=scrollbar.set)\n        \n        self.plugin_checkboxes_frame = ttk.Frame(self.plugin_checkboxes_canvas)\n        self.plugin_checkboxes_canvas.create_window((0, 0), window=self.plugin_checkboxes_frame, anchor=tk.NW)\n        \n        self.plugin_checkboxes_frame.bind(\"<Configure>\", self._on_frame_configure)\n        \n        # Dictionary to store custom metrics visibility variables\n        self.metric_visibility_vars = {}\n        \n        # Add buttons\n        button_frame = ttk.Frame(self.metrics_frame)\n        button_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)\n        \n        ttk.Button(button_frame, text=\"Show All\", command=self.show_all_metrics).pack(pady=2)\n        ttk.Button(button_frame, text=\"Hide All\", command=self.hide_all_metrics).pack(pady=2)\n        ttk.Button(button_frame, text=\"Remove All\", command=self.remove_all_custom_metrics).pack(pady=2)\n        \n    def _on_frame_configure(self, event):\n        \"\"\"Handle frame configuration event for scrolling\"\"\"\n        self.plugin_checkboxes_canvas.configure(scrollregion=self.plugin_checkboxes_canvas.bbox(\"all\"))\n        \n    def show_all_metrics(self):\n        \"\"\"Show all metrics on the graph\"\"\"\n        # System metrics\n        self.show_cpu_var.set(True)\n        self.show_ram_var.set(True)\n        self.show_gpu_var.set(True)\n        \n        # Plugin metrics\n        for var in self.metric_visibility_vars.values():\n            var.set(True)\n            \n        self.update_graph_visibility()\n        \n    def hide_all_metrics(self):\n        \"\"\"Hide all metrics on the graph\"\"\"\n        # System metrics\n        self.show_cpu_var.set(False)\n        self.show_ram_var.set(False)\n        self.show_gpu_var.set(False)\n        \n        # Plugin metrics\n        for var in self.metric_visibility_vars.values():\n            var.set(False)\n            \n        self.update_graph_visibility()\n        \n    def update_graph_visibility(self):\n        \"\"\"Update the visibility of graph lines based on checkboxes\"\"\"\n        self.cpu_line.set_visible(self.show_cpu_var.get())\n        self.ram_line.set_visible(self.show_ram_var.get())\n        self.gpu_line.set_visible(self.show_gpu_var.get())\n        \n        # Update custom metrics visibility\n        for metric_id, info in self.custom_metrics.items():\n            if metric_id in self.metric_visibility_vars:\n                visible = self.metric_visibility_vars[metric_id].get()\n                info[\"visible\"] = visible\n                if info[\"line\"]:\n                    info[\"line\"].set_visible(visible)\n        \n        self.canvas.draw()\n        \n    def start_monitoring(self):\n        \"\"\"Start the monitoring updates\"\"\"\n        if self.running:\n            return\n            \n        self.running = True\n        \n        # Start update timer\n        self.update_interval = int(self.interval_var.get()) * 1000  # Convert to milliseconds\n        self.update_timer_id = self.frame.after(self.update_interval, self.update_metrics)\n        \n        self.log(\"Started resource monitoring\")\n        \n    def stop_monitoring(self):\n        \"\"\"Stop the monitoring updates\"\"\"\n        if not self.running:\n            return\n            \n        self.running = False\n        \n        # Cancel the timer\n        if hasattr(self, 'update_timer_id'):\n            self.frame.after_cancel(self.update_timer_id)\n            \n        self.log(\"Stopped resource monitoring\")\n        \n    def on_interval_changed(self, event=None):\n        \"\"\"Handle update interval change\"\"\"\n        # Restart monitoring with new interval\n        self.stop_monitoring()\n        self.start_monitoring()\n        \n    def update_metrics(self):\n        \"\"\"Update resource metrics display\"\"\"\n        if not self.running:\n            return\n            \n        try:\n            if self.system_monitor:\n                # Get system info\n                system_info = self.system_monitor.get_system_info()\n                \n                # Update top labels\n                cpu_usage = system_info[\"cpu\"][\"usage_percent\"]\n                self.cpu_label.config(text=f\"CPU: {cpu_usage:.1f}%\")\n                \n                ram_usage = system_info[\"ram\"][\"usage_percent\"]\n                self.ram_label.config(text=f\"RAM: {ram_usage:.1f}%\")\n                \n                gpu_usage = system_info[\"gpu\"][\"usage_percent\"]\n                self.gpu_label.config(text=f\"GPU: {gpu_usage}\")\n                \n                disk_usage = system_info[\"disk\"][\"usage_percent\"]\n                self.disk_label.config(text=f\"Disk: {disk_usage:.1f}%\")\n                \n                # Update graph data\n                self.cpu_data.append(cpu_usage)\n                self.cpu_data.pop(0)\n                \n                self.ram_data.append(ram_usage)\n                self.ram_data.pop(0)\n                \n                try:\n                    if gpu_usage != \"N/A\":\n                        gpu_value = float(gpu_usage.replace(\"%\", \"\"))\n                    else:\n                        gpu_value = 0\n                except:\n                    gpu_value = 0\n                    \n                self.gpu_data.append(gpu_value)\n                self.gpu_data.pop(0)\n                \n                # Update custom metrics\n                self.update_custom_metrics_data()\n                \n                # Update graph lines\n                self.cpu_line.set_ydata(self.cpu_data)\n                self.ram_line.set_ydata(self.ram_data)\n                self.gpu_line.set_ydata(self.gpu_data)\n                \n                for key, info in self.custom_metrics.items():\n                    if info[\"line\"]:\n                        info[\"line\"].set_ydata(info[\"data\"])\n                \n                # Draw the canvas\n                self.canvas.draw_idle()\n                \n                # Update system tab details\n                self.update_system_details(system_info)\n                \n                # Update processes tab\n                self.update_processes()\n                \n                # Update plugin metrics tab\n                self.update_plugin_metrics()\n                \n            else:\n                # No system monitor available\n                self.cpu_label.config(text=\"CPU: N/A\")\n                self.ram_label.config(text=\"RAM: N/A\")\n                self.gpu_label.config(text=\"GPU: N/A\")\n                self.disk_label.config(text=\"Disk: N/A\")\n                \n        except Exception as e:\n            self.log(f\"Error updating metrics: {e}\", \"ERROR\")\n            \n        finally:\n            # Schedule next update\n            self.update_timer_id = self.frame.after(self.update_interval, self.update_metrics)\n    \n    def update_custom_metrics_data(self):\n        \"\"\"Update data for custom metrics\"\"\"\n        if not self.system_monitor or not self.custom_metrics:\n            return\n            \n        try:\n            # Get custom metrics\n            metrics = getattr(self.system_monitor, \"get_all_metrics\", lambda: {\"custom\": {}})()\n            \n            if \"custom\" not in metrics:\n                return\n                \n            # Update each custom metric\n            for key, info in self.custom_metrics.items():\n                if key in metrics[\"custom\"]:\n                    metric = metrics[\"custom\"][key]\n                    value = metric[\"value\"]\n                    \n                    # Convert to percentage for the graph if needed\n                    if metric[\"metadata\"][\"format\"] == \"percentage\":\n                        # Already a percentage, use directly\n                        graph_value = float(value)\n                    elif metric[\"metadata\"][\"format\"] == \"numeric\":\n                        # Scale numeric values to fit in the graph (0-100)\n                        # We need to estimate a reasonable scale\n                        if hasattr(self, \"_metric_max_values\"):\n                            # Update max value if needed\n                            if key not in self._metric_max_values or value > self._metric_max_values[key]:\n                                self._metric_max_values[key] = max(1.0, value * 1.1)  # Add 10% margin\n                        else:\n                            # Initialize max values dictionary\n                            self._metric_max_values = {key: max(1.0, value * 1.1)}\n                            \n                        # Scale to 0-100 based on max value seen so far\n                        max_value = self._metric_max_values[key]\n                        graph_value = (value / max_value) * 100\n                        graph_value = min(100, graph_value)  # Cap at 100%\n                    else:\n                        # For text metrics, just use 50% as a visual indicator\n                        graph_value = 50\n                        \n                    # Update data\n                    info[\"data\"].append(graph_value)\n                    info[\"data\"].pop(0)\n                else:\n                    # Metric not available, add 0\n                    info[\"data\"].append(0)\n                    info[\"data\"].pop(0)\n                    \n        except Exception as e:\n            self.log(f\"Error updating custom metrics data: {e}\", \"ERROR\")\n            \n    def update_system_details(self, system_info: Dict[str, Any]):\n        \"\"\"\n        Update the system details treeview\n        \n        Args:\n            system_info: System information dictionary\n        \"\"\"\n        # Clear existing items\n        for item in self.system_tree.get_children(self.cpu_item):\n            self.system_tree.delete(item)\n        for item in self.system_tree.get_children(self.ram_item):\n            self.system_tree.delete(item)\n        for item in self.system_tree.get_children(self.gpu_item):\n            self.system_tree.delete(item)\n        for item in self.system_tree.get_children(self.disk_item):\n            self.system_tree.delete(item)\n            \n        # Add CPU info\n        cpu_usage = system_info[\"cpu\"][\"usage_percent\"]\n        self.system_tree.insert(self.cpu_item, \"end\", values=(\"Usage\", f\"{cpu_usage:.1f}%\"))\n        \n        # Get additional CPU info from psutil if available\n        try:\n            cpu_count = psutil.cpu_count(logical=False)\n            logical_count = psutil.cpu_count(logical=True)\n            cpu_freq = psutil.cpu_freq()\n            \n            self.system_tree.insert(self.cpu_item, \"end\", values=(\"Physical cores\", str(cpu_count)))\n            self.system_tree.insert(self.cpu_item, \"end\", values=(\"Logical cores\", str(logical_count)))\n            \n            if cpu_freq:\n                self.system_tree.insert(self.cpu_item, \"end\", \n                                     values=(\"Current frequency\", f\"{cpu_freq.current:.0f} MHz\"))\n                if hasattr(cpu_freq, \"min\") and cpu_freq.min:\n                    self.system_tree.insert(self.cpu_item, \"end\", \n                                         values=(\"Min frequency\", f\"{cpu_freq.min:.0f} MHz\"))\n                if hasattr(cpu_freq, \"max\") and cpu_freq.max:\n                    self.system_tree.insert(self.cpu_item, \"end\", \n                                         values=(\"Max frequency\", f\"{cpu_freq.max:.0f} MHz\"))\n        except:\n            pass\n            \n        # Add RAM info\n        ram_percent = system_info[\"ram\"][\"usage_percent\"]\n        ram_used = system_info[\"ram\"][\"used_gb\"]\n        ram_total = system_info[\"ram\"][\"total_gb\"]\n        \n        self.system_tree.insert(self.ram_item, \"end\", values=(\"Usage\", f\"{ram_percent:.1f}%\"))\n        self.system_tree.insert(self.ram_item, \"end\", values=(\"Used\", f\"{ram_used:.2f} GB\"))\n        self.system_tree.insert(self.ram_item, \"end\", values=(\"Total\", f\"{ram_total:.2f} GB\"))\n        self.system_tree.insert(self.ram_item, \"end\", values=(\"Free\", f\"{ram_total - ram_used:.2f} GB\"))\n        \n        # Get additional memory info from psutil if available\n        try:\n            swap = psutil.swap_memory()\n            self.system_tree.insert(self.ram_item, \"end\", values=(\"Swap usage\", f\"{swap.percent:.1f}%\"))\n            self.system_tree.insert(self.ram_item, \"end\", values=(\"Swap used\", f\"{swap.used / (1024**3):.2f} GB\"))\n            self.system_tree.insert(self.ram_item, \"end\", values=(\"Swap total\", f\"{swap.total / (1024**3):.2f} GB\"))\n        except:\n            pass\n            \n        # Add GPU info\n        gpu_usage = system_info[\"gpu\"][\"usage_percent\"]\n        gpu_memory = system_info[\"gpu\"][\"memory\"]\n        \n        self.system_tree.insert(self.gpu_item, \"end\", values=(\"Usage\", str(gpu_usage)))\n        self.system_tree.insert(self.gpu_item, \"end\", values=(\"Memory\", str(gpu_memory)))\n        \n        # Add additional GPU info from nvidia-smi if available\n        try:\n            if hasattr(self.system_monitor, 'get_gpu_info'):\n                gpu_info = self.system_monitor.get_gpu_info()\n                if gpu_info:\n                    for key, value in gpu_info.items():\n                        if key not in [\"usage_percent\", \"memory\"]:\n                            self.system_tree.insert(self.gpu_item, \"end\", values=(key.replace(\"_\", \" \").title(), str(value)))\n        except:\n            pass\n            \n        # Add Disk info\n        disk_percent = system_info[\"disk\"][\"usage_percent\"]\n        disk_free = system_info[\"disk\"][\"free_gb\"]\n        disk_total = system_info[\"disk\"][\"total_gb\"]\n        \n        self.system_tree.insert(self.disk_item, \"end\", values=(\"Usage\", f\"{disk_percent:.1f}%\"))\n        self.system_tree.insert(self.disk_item, \"end\", values=(\"Free\", f\"{disk_free:.2f} GB\"))\n        self.system_tree.insert(self.disk_item, \"end\", values=(\"Total\", f\"{disk_total:.2f} GB\"))\n        self.system_tree.insert(self.disk_item, \"end\", values=(\"Used\", f\"{disk_total - disk_free:.2f} GB\"))\n        \n    def update_processes(self):\n        \"\"\"Update the processes tab with monitored process information\"\"\"\n        if not self.system_monitor:\n            return\n            \n        try:\n            # Clear existing items\n            for item in self.processes_tree.get_children():\n                self.processes_tree.delete(item)\n                \n            # Get process metrics if available\n            metrics = getattr(self.system_monitor, \"get_all_metrics\", lambda: {\"processes\": {}})()\n            \n            if \"processes\" not in metrics:\n                return\n                \n            # Add each monitored process\n            for key, process in metrics[\"processes\"].items():\n                info = process[\"info\"]\n                metrics = process[\"metrics\"]\n                \n                if \"error\" in metrics:\n                    # Process is not running or has an error\n                    self.processes_tree.insert(\"\", \"end\", values=(\n                        info[\"process_id\"],\n                        info[\"name\"],\n                        \"N/A\",\n                        \"N/A\",\n                        \"Error\",\n                        info[\"plugin_id\"]\n                    ))\n                else:\n                    # Process is running\n                    self.processes_tree.insert(\"\", \"end\", values=(\n                        info[\"process_id\"],\n                        info[\"name\"],\n                        f\"{metrics['cpu_percent']:.1f}%\",\n                        f\"{metrics['memory_rss']:.1f} MB\",\n                        metrics['status'],\n                        info[\"plugin_id\"]\n                    ))\n        except Exception as e:\n            self.log(f\"Error updating process list: {e}\", \"ERROR\")\n            \n    def refresh_plugin_list(self):\n        \"\"\"Refresh the list of plugins in the filter dropdown\"\"\"\n        if not self.system_monitor:\n            return\n            \n        try:\n            # Get metrics if available\n            metrics = getattr(self.system_monitor, \"get_all_metrics\", lambda: {\"custom\": {}})()\n            \n            if \"custom\" not in metrics:\n                return\n                \n            # Get unique plugin IDs\n            plugin_ids = set()\n            for key, metric in metrics[\"custom\"].items():\n                plugin_ids.add(metric[\"plugin_id\"])\n                \n            # Update combobox values\n            values = [\"All Plugins\"] + sorted(list(plugin_ids))\n            self.plugin_filter_combo[\"values\"] = values\n            \n            # Assign colors to plugins if not already assigned\n            for plugin_id in plugin_ids:\n                if plugin_id not in self.plugin_colors:\n                    self.plugin_colors[plugin_id] = self.get_random_color()\n                    \n        except Exception as e:\n            self.log(f\"Error refreshing plugin list: {e}\", \"ERROR\")\n            \n    def get_random_color(self):\n        \"\"\"Generate a random color that is distinct from existing colors\"\"\"\n        # List of distinct colors that work well on graphs\n        colors = [\n            \"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\",\n            \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\",\n            \"#aec7e8\", \"#ffbb78\", \"#98df8a\", \"#ff9896\", \"#c5b0d5\"\n        ]\n        \n        # If we've used all colors, generate a random one\n        if len(self.plugin_colors) >= len(colors):\n            while True:\n                # Generate a bright, distinguishable color\n                r = random.randint(0, 200)  # Not too dark\n                g = random.randint(0, 200)\n                b = random.randint(0, 200)\n                \n                # Ensure some brightness\n                if r + g + b < 250:  # Avoid too dark colors\n                    continue\n                    \n                color = f\"#{r:02x}{g:02x}{b:02x}\"\n                \n                # Check if this color is too similar to existing ones\n                if color not in self.plugin_colors.values():\n                    return color\n        else:\n            # Use a pre-defined color\n            used_colors = set(self.plugin_colors.values())\n            for color in colors:\n                if color not in used_colors:\n                    return color\n                    \n            # Fallback\n            return \"#000000\"\n            \n    def on_plugin_filter_changed(self, event=None):\n        \"\"\"Handle plugin filter change\"\"\"\n        self.update_plugin_metrics()\n        \n    def update_plugin_metrics(self):\n        \"\"\"Update the plugin metrics tab with custom metrics\"\"\"\n        if not self.system_monitor:\n            return\n            \n        try:\n            # Clear existing items\n            for item in self.plugins_tree.get_children():\n                self.plugins_tree.delete(item)\n                \n            # Get custom metrics if available\n            metrics = getattr(self.system_monitor, \"get_all_metrics\", lambda: {\"custom\": {}})()\n            \n            if \"custom\" not in metrics:\n                return\n                \n            # Get selected plugin filter\n            plugin_filter = self.plugin_filter_var.get()\n            \n            # Group metrics by plugin\n            plugin_metrics = {}\n            for key, metric in metrics[\"custom\"].items():\n                plugin_id = metric[\"plugin_id\"]\n                \n                # Apply filter\n                if plugin_filter != \"All Plugins\" and plugin_filter != plugin_id:\n                    continue\n                    \n                if plugin_id not in plugin_metrics:\n                    plugin_metrics[plugin_id] = []\n                    \n                plugin_metrics[plugin_id].append((key, metric))\n                \n            # Add each plugin group\n            for plugin_id, metrics_list in sorted(plugin_metrics.items()):\n                # Create plugin node\n                plugin_node = self.plugins_tree.insert(\"\", \"end\", text=plugin_id, open=True, \n                                                   tags=(\"plugin\",))\n                \n                # Add each metric\n                for key, metric in sorted(metrics_list):\n                    metadata = metric[\"metadata\"]\n                    \n                    # Format the value\n                    value = metric[\"value\"]\n                    if metadata[\"format\"] == \"percentage\":\n                        formatted_value = f\"{value:.1f}%\"\n                    elif metadata[\"format\"] == \"numeric\":\n                        formatted_value = f\"{value:.2f} {metadata.get('unit', '')}\"\n                    else:\n                        formatted_value = str(value)\n                        \n                    # Get metric name and ID\n                    metric_name = metadata[\"name\"]\n                    metric_id = key.split(\":\", 1)[1] if \":\" in key else key\n                    \n                    # Add to tree\n                    self.plugins_tree.insert(plugin_node, \"end\", text=metric_name, \n                                          values=(formatted_value, metadata[\"format\"], metadata[\"description\"]),\n                                          tags=(plugin_id, metric_id, key))\n                    \n        except Exception as e:\n            self.log(f\"Error updating plugin metrics: {e}\", \"ERROR\")\n            \n    def show_plugins_tree_menu(self, event):\n        \"\"\"Show context menu for plugin metrics tree\"\"\"\n        # Select row under mouse\n        iid = self.plugins_tree.identify_row(event.y)\n        if iid:\n            # Select this item\n            self.plugins_tree.selection_set(iid)\n            \n            # Get item tags to check if it's a metric or plugin\n            tags = self.plugins_tree.item(iid, \"tags\")\n            \n            if tags and len(tags) > 2:  # It's a metric item\n                self.plugin_metrics_menu.entryconfigure(\"Add to Graph\", state=\"normal\")\n                self.plugin_metrics_menu.entryconfigure(\"Remove from Graph\", state=\"normal\")\n                self.plugin_metrics_menu.entryconfigure(\"Show Details\", state=\"normal\")\n            else:\n                # It's a plugin header\n                self.plugin_metrics_menu.entryconfigure(\"Add to Graph\", state=\"disabled\")\n                self.plugin_metrics_menu.entryconfigure(\"Remove from Graph\", state=\"disabled\")\n                self.plugin_metrics_menu.entryconfigure(\"Show Details\", state=\"disabled\")\n                \n            # Show the menu\n            self.plugin_metrics_menu.post(event.x_root, event.y_root)\n            \n    def add_selected_metric_to_graph(self):\n        \"\"\"Add the selected metric to the graph\"\"\"\n        selection = self.plugins_tree.selection()\n        if not selection:\n            return\n            \n        # Get the selected item\n        item_id = selection[0]\n        tags = self.plugins_tree.item(item_id, \"tags\")\n        \n        if not tags or len(tags) < 3:\n            # Not a metric item\n            return\n            \n        plugin_id, metric_id, key = tags\n        \n        # Get the metric name for the graph label\n        metric_name = self.plugins_tree.item(item_id, \"text\")\n        \n        # Add to graph\n        self.add_custom_metric_to_graph(key, metric_name, color=self.plugin_colors.get(plugin_id))\n        \n        # Show the graph tab\n        self.notebook.select(self.graph_tab)\n        \n        self.log(f\"Added metric {metric_name} from plugin {plugin_id} to graph\")\n        \n    def remove_selected_metric_from_graph(self):\n        \"\"\"Remove the selected metric from the graph\"\"\"\n        selection = self.plugins_tree.selection()\n        if not selection:\n            return\n            \n        # Get the selected item\n        item_id = selection[0]\n        tags = self.plugins_tree.item(item_id, \"tags\")\n        \n        if not tags or len(tags) < 3:\n            # Not a metric item\n            return\n            \n        plugin_id, metric_id, key = tags\n        \n        # Remove from graph\n        self.remove_custom_metric_from_graph(key)\n        \n    def show_metric_details(self):\n        \"\"\"Show details for the selected metric\"\"\"\n        selection = self.plugins_tree.selection()\n        if not selection:\n            return\n            \n        # Get the selected item\n        item_id = selection[0]\n        tags = self.plugins_tree.item(item_id, \"tags\")\n        \n        if not tags or len(tags) < 3:\n            # Not a metric item\n            return\n            \n        plugin_id, metric_id, key = tags\n        \n        # Get custom metrics\n        metrics = getattr(self.system_monitor, \"get_all_metrics\", lambda: {\"custom\": {}})()\n        \n        if \"custom\" not in metrics or key not in metrics[\"custom\"]:\n            return\n            \n        metric = metrics[\"custom\"][key]\n        metadata = metric[\"metadata\"]\n        \n        # Create details dialog\n        dialog = tk.Toplevel()\n        dialog.title(f\"Metric Details: {metadata['name']}\")\n        dialog.geometry(\"400x300\")\n        dialog.transient(self.master)\n        dialog.grab_set()\n        \n        # Add details\n        frame = ttk.Frame(dialog, padding=10)\n        frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Add metric information\n        ttk.Label(frame, text=metadata['name'], font=(\"\", 12, \"bold\")).grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(0, 10))\n        \n        ttk.Label(frame, text=\"Plugin:\").grid(row=1, column=0, sticky=tk.W, pady=2)\n        ttk.Label(frame, text=plugin_id).grid(row=1, column=1, sticky=tk.W, pady=2)\n        \n        ttk.Label(frame, text=\"Metric ID:\").grid(row=2, column=0, sticky=tk.W, pady=2)\n        ttk.Label(frame, text=metric_id).grid(row=2, column=1, sticky=tk.W, pady=2)\n        \n        ttk.Label(frame, text=\"Description:\").grid(row=3, column=0, sticky=tk.W, pady=2)\n        desc_label = ttk.Label(frame, text=metadata['description'], wraplength=250)\n        desc_label.grid(row=3, column=1, sticky=tk.W, pady=2)\n        \n        ttk.Label(frame, text=\"Format:\").grid(row=4, column=0, sticky=tk.W, pady=2)\n        ttk.Label(frame, text=metadata['format']).grid(row=4, column=1, sticky=tk.W, pady=2)\n        \n        if 'unit' in metadata:\n            ttk.Label(frame, text=\"Unit:\").grid(row=5, column=0, sticky=tk.W, pady=2)\n            ttk.Label(frame, text=metadata['unit']).grid(row=5, column=1, sticky=tk.W, pady=2)\n            \n        ttk.Label(frame, text=\"Current Value:\").grid(row=6, column=0, sticky=tk.W, pady=2)\n        \n        # Format the value\n        value = metric[\"value\"]\n        if metadata[\"format\"] == \"percentage\":\n            formatted_value = f\"{value:.1f}%\"\n        elif metadata[\"format\"] == \"numeric\":\n            formatted_value = f\"{value:.2f} {metadata.get('unit', '')}\"\n        else:\n            formatted_value = str(value)\n            \n        ttk.Label(frame, text=formatted_value).grid(row=6, column=1, sticky=tk.W, pady=2)\n        \n        ttk.Label(frame, text=\"Last Updated:\").grid(row=7, column=0, sticky=tk.W, pady=2)\n        update_time = datetime.datetime.fromtimestamp(metric[\"timestamp\"]).strftime(\"%H:%M:%S\")\n        ttk.Label(frame, text=update_time).grid(row=7, column=1, sticky=tk.W, pady=2)\n        \n        # Add buttons\n        button_frame = ttk.Frame(frame)\n        button_frame.grid(row=8, column=0, columnspan=2, pady=(20, 0), sticky=tk.E)\n        \n        ttk.Button(button_frame, text=\"Add to Graph\", \n                  command=lambda: self.add_custom_metric_to_graph(key, metadata['name'], \n                                                              color=self.plugin_colors.get(plugin_id))).pack(side=tk.LEFT, padx=5)\n        ttk.Button(button_frame, text=\"Close\", command=dialog.destroy).pack(side=tk.LEFT, padx=5)\n        \n    def add_custom_metric_to_graph(self, metric_key: str, display_name: str = None, \n                                 color: str = None, visible: bool = True):\n        \"\"\"\n        Add a custom metric to the graph\n        \n        Args:\n            metric_key: Metric key (used for fetching data)\n            display_name: Display name for the metric in the legend\n            color: Optional color for the metric line\n            visible: Initial visibility of the metric line\n        \"\"\"\n        if not display_name:\n            display_name = metric_key.split(\":\", 1)[1] if \":\" in metric_key else metric_key\n            \n        if metric_key in self.custom_metrics:\n            # Metric already exists, just make it visible if needed\n            if visible and metric_key in self.metric_visibility_vars:\n                self.metric_visibility_vars[metric_key].set(True)\n                self.update_graph_visibility()\n            return\n            \n        # Initialize data for the custom metric\n        self.custom_metrics[metric_key] = {\n            \"data\": [0] * self.data_points,\n            \"line\": None,\n            \"color\": color,\n            \"visible\": visible,\n            \"display_name\": display_name,\n            \"metric_key\": metric_key\n        }\n        \n        # Add the metric line to the graph\n        if hasattr(self, 'subplot') and self.subplot:\n            if color:\n                self.custom_metrics[metric_key][\"line\"], = self.subplot.plot(\n                    self.time_data, \n                    self.custom_metrics[metric_key][\"data\"], \n                    color=color, \n                    label=display_name,\n                    visible=visible\n                )\n            else:\n                self.custom_metrics[metric_key][\"line\"], = self.subplot.plot(\n                    self.time_data, \n                    self.custom_metrics[metric_key][\"data\"], \n                    label=display_name,\n                    visible=visible\n                )\n            \n            # Update legend\n            self.subplot.legend()\n            self.canvas.draw()\n            \n        # Add checkbox for visibility control\n        if hasattr(self, 'plugin_checkboxes_frame') and self.plugin_checkboxes_frame:\n            var = tk.BooleanVar(value=visible)\n            self.metric_visibility_vars[metric_key] = var\n            \n            # Create frame for checkbox and remove button\n            metric_frame = ttk.Frame(self.plugin_checkboxes_frame)\n            metric_frame.pack(fill=tk.X, padx=2, pady=1)\n            \n            # Add color indicator\n            if color:\n                color_indicator = tk.Label(metric_frame, text=\"   \", bg=color, relief=tk.RIDGE)\n                color_indicator.pack(side=tk.LEFT, padx=(0, 5))\n            \n            # Add checkbox\n            cb = ttk.Checkbutton(\n                metric_frame, \n                text=display_name, \n                variable=var,\n                command=self.update_graph_visibility\n            )\n            cb.pack(side=tk.LEFT, fill=tk.X, expand=True)\n            \n            # Add remove button\n            remove_btn = ttk.Button(\n                metric_frame, \n                text=\"X\", \n                width=2,\n                command=lambda key=metric_key: self.remove_custom_metric_from_graph(key)\n            )\n            remove_btn.pack(side=tk.RIGHT)\n            \n    def remove_custom_metric_from_graph(self, metric_key: str):\n        \"\"\"\n        Remove a custom metric from the graph\n        \n        Args:\n            metric_key: Metric key\n        \"\"\"\n        if metric_key not in self.custom_metrics:\n            return  # Metric not found\n            \n        # Remove the metric line from the graph\n        info = self.custom_metrics[metric_key]\n        line = info[\"line\"]\n        if line:\n            line.remove()\n            \n        # Remove from custom metrics\n        del self.custom_metrics[metric_key]\n        \n        # Remove checkbox\n        if metric_key in self.metric_visibility_vars:\n            # Find and destroy the frame containing this metric's checkbox\n            for widget in self.plugin_checkboxes_frame.winfo_children():\n                for child in widget.winfo_children():\n                    if isinstance(child, ttk.Checkbutton) and child.cget(\"text\") == info[\"display_name\"]:\n                        widget.destroy()\n                        break\n            \n            # Remove from variables\n            del self.metric_visibility_vars[metric_key]\n        \n        # Redraw the graph\n        self.subplot.legend()\n        self.canvas.draw()\n        \n    def remove_all_custom_metrics(self):\n        \"\"\"Remove all custom metrics from the graph\"\"\"\n        # Ask for confirmation\n        if messagebox.askyesno(\"Remove Custom Metrics\", \"Are you sure you want to remove all custom metrics?\"):\n            # Get keys first to avoid modifying dict during iteration\n            keys = list(self.custom_metrics.keys())\n            for key in keys:\n                self.remove_custom_metric_from_graph(key)\n                \n    def export_metrics(self):\n        \"\"\"Export metrics to a file\"\"\"\n        import tkinter.filedialog as filedialog\n        import datetime\n        \n        if not self.system_monitor:\n            return\n            \n        # Get file path\n        timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        default_filename = f\"resource_metrics_{timestamp}.txt\"\n        \n        file_path = filedialog.asksaveasfilename(\n            initialfile=default_filename,\n            defaultextension=\".txt\",\n            filetypes=[(\"Text files\", \"*.txt\"), (\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")]\n        )\n        \n        if not file_path:\n            return\n            \n        try:\n            # Determine format based on extension\n            if file_path.lower().endswith(\".json\"):\n                export_format = \"json\"\n            else:\n                export_format = \"text\"\n                \n            # Export metrics\n            if hasattr(self.system_monitor, \"export_metrics\"):\n                metrics_str = self.system_monitor.export_metrics(export_format)\n            else:\n                # Fallback if export_metrics is not available\n                metrics = self.system_monitor.get_all_metrics()\n                if export_format == \"json\":\n                    import json\n                    metrics_str = json.dumps(metrics, default=str, indent=2)\n                else:\n                    metrics_str = str(metrics)\n            \n            # Write to file\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(metrics_str)\n                \n            # Show success message\n            import tkinter.messagebox as messagebox\n            messagebox.showinfo(\"Export Complete\", f\"Metrics exported to {file_path}\")\n            \n        except Exception as e:\n            self.log(f\"Error exporting metrics: {e}\", \"ERROR\")\n            import tkinter.messagebox as messagebox\n            messagebox.showerror(\"Export Error\", f\"Failed to export metrics: {e}\")\n            \n    def add_custom_metric_to_graph(self, metric_key: str, display_name: str = None, \n                                 color: str = None, visible: bool = True):\n        \"\"\"\n        Add a custom metric to the graph\n        \n        Args:\n            metric_key: Metric key (used for fetching data)\n            display_name: Display name for the metric in the legend\n            color: Optional color for the metric line\n            visible: Initial visibility of the metric line\n        \"\"\"\n        if not display_name:\n            display_name = metric_key.split(\":\", 1)[1] if \":\" in metric_key else metric_key\n            \n        if metric_key in self.custom_metrics:\n            # Metric already exists, just make it visible if needed\n            if visible and metric_key in self.metric_visibility_vars:\n                self.metric_visibility_vars[metric_key].set(True)\n                self.update_graph_visibility()\n            return\n            \n        # Initialize data for the custom metric\n        self.custom_metrics[metric_key] = {\n            \"data\": [0] * self.data_points,\n            \"line\": None,\n            \"color\": color,\n            \"visible\": visible,\n            \"display_name\": display_name,\n            \"metric_key\": metric_key\n        }\n        \n        # Add the metric line to the graph\n        if hasattr(self, 'subplot') and self.subplot:\n            if color:\n                self.custom_metrics[metric_key][\"line\"], = self.subplot.plot(\n                    self.time_data, \n                    self.custom_metrics[metric_key][\"data\"], \n                    color=color, \n                    label=display_name,\n                    visible=visible\n                )\n            else:\n                self.custom_metrics[metric_key][\"line\"], = self.subplot.plot(\n                    self.time_data, \n                    self.custom_metrics[metric_key][\"data\"], \n                    label=display_name,\n                    visible=visible\n                )\n            \n            # Update legend\n            self.subplot.legend()\n            self.canvas.draw()\n            \n        # Add checkbox for visibility control\n        if hasattr(self, 'plugin_checkboxes_frame') and self.plugin_checkboxes_frame:\n            var = tk.BooleanVar(value=visible)\n            self.metric_visibility_vars[metric_key] = var\n            \n            # Create frame for checkbox and remove button\n            metric_frame = ttk.Frame(self.plugin_checkboxes_frame)\n            metric_frame.pack(fill=tk.X, padx=2, pady=1)\n            \n            # Add color indicator\n            if color:\n                color_indicator = tk.Label(metric_frame, text=\"   \", bg=color, relief=tk.RIDGE)\n                color_indicator.pack(side=tk.LEFT, padx=(0, 5))\n            \n            # Add checkbox\n            cb = ttk.Checkbutton(\n                metric_frame, \n                text=display_name, \n                variable=var,\n                command=self.update_graph_visibility\n            )\n            cb.pack(side=tk.LEFT, fill=tk.X, expand=True)\n            \n            # Add remove button\n            remove_btn = ttk.Button(\n                metric_frame, \n                text=\"X\", \n                width=2,\n                command=lambda key=metric_key: self.remove_custom_metric_from_graph(key)\n            )\n            remove_btn.pack(side=tk.RIGHT)\n            \n    def remove_custom_metric_from_graph(self, metric_key: str):\n        \"\"\"\n        Remove a custom metric from the graph\n        \n        Args:\n            metric_key: Metric key\n        \"\"\"\n        if metric_key not in self.custom_metrics:\n            return  # Metric not found\n            \n        # Remove the metric line from the graph\n        info = self.custom_metrics[metric_key]\n        line = info[\"line\"]\n        if line:\n            line.remove()\n            \n        # Remove from custom metrics\n        del self.custom_metrics[metric_key]\n        \n        # Remove checkbox\n        if metric_key in self.metric_visibility_vars:\n            # Find and destroy the frame containing this metric's checkbox\n            for widget in self.plugin_checkboxes_frame.winfo_children():\n                for child in widget.winfo_children():\n                    if isinstance(child, ttk.Checkbutton) and child.cget(\"text\") == info[\"display_name\"]:\n                        widget.destroy()\n                        break\n            \n            # Remove from variables\n            del self.metric_visibility_vars[metric_key]\n        \n        # Redraw the graph\n        self.subplot.legend()\n        self.canvas.draw()\n        \n    def remove_all_custom_metrics(self):\n        \"\"\"Remove all custom metrics from the graph\"\"\"\n        # Ask for confirmation\n        if messagebox.askyesno(\"Remove Custom Metrics\", \"Are you sure you want to remove all custom metrics?\"):\n            # Get keys first to avoid modifying dict during iteration\n            keys = list(self.custom_metrics.keys())\n            for key in keys:\n                self.remove_custom_metric_from_graph(key)\n                \n    def export_metrics(self):\n        \"\"\"Export metrics to a file\"\"\"\n        import tkinter.filedialog as filedialog\n        import datetime\n        \n        if not self.system_monitor:\n            return\n            \n        # Get file path\n        timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        default_filename = f\"resource_metrics_{timestamp}.txt\"\n        \n        file_path = filedialog.asksaveasfilename(\n            initialfile=default_filename,\n            defaultextension=\".txt\",\n            filetypes=[(\"Text files\", \"*.txt\"), (\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")]\n        )\n        \n        if not file_path:\n            return\n            \n        try:\n            # Determine format based on extension\n            if file_path.lower().endswith(\".json\"):\n                export_format = \"json\"\n            else:\n                export_format = \"text\"\n                \n            # Export metrics\n            if hasattr(self.system_monitor, \"export_metrics\"):\n                metrics_str = self.system_monitor.export_metrics(export_format)\n            else:\n                # Fallback if export_metrics is not available\n                metrics = self.system_monitor.get_all_metrics()\n                if export_format == \"json\":\n                    import json\n                    metrics_str = json.dumps(metrics, default=str, indent=2)\n                else:\n                    metrics_str = str(metrics)\n            \n            # Write to file\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(metrics_str)\n                \n            # Show success message\n            import tkinter.messagebox as messagebox\n            messagebox.showinfo(\"Export Complete\", f\"Metrics exported to {file_path}\")\n            \n        except Exception as e:\n            self.log(f\"Error exporting metrics: {e}\", \"ERROR\")\n            import tkinter.messagebox as messagebox\n            messagebox.showerror(\"Export Error\", f\"Failed to export metrics: {e}\")\n            \n    def add_custom_metric_to_graph(self, metric_key: str, display_name: str = None, \n                                 color: str = None, visible: bool = True):\n        \"\"\"\n        Add a custom metric to the graph\n        \n        Args:\n            metric_key: Metric key (used for fetching data)\n            display_name: Display name for the metric in the legend\n            color: Optional color for the metric line\n            visible: Initial visibility of the metric line\n        \"\"\"\n        if not display_name:\n            display_name = metric_key.split(\":\", 1)[1] if \":\" in metric_key else metric_key\n            \n        if metric_key in self.custom_metrics:\n            # Metric already exists, just make it visible if needed\n            if visible and metric_key in self.metric_visibility_vars:\n                self.metric_visibility_vars[metric_key].set(True)\n                self.update_graph_visibility()\n            return\n            \n        # Initialize data for the custom metric\n        self.custom_metrics[metric_key] = {\n            \"data\": [0] * self.data_points,\n            \"line\": None,\n            \"color\": color,\n            \"visible\": visible,\n            \"display_name\": display_name,\n            \"metric_key\": metric_key\n        }\n        \n        # Add the metric line to the graph\n        if hasattr(self, 'subplot') and self.subplot:\n            if color:\n                self.custom_metrics[metric_key][\"line\"], = self.subplot.plot(\n                    self.time_data, \n                    self.custom_metrics[metric_key][\"data\"], \n                    color=color, \n                    label=display_name,\n                    visible=visible\n                )\n            else:\n                self.custom_metrics[metric_key][\"line\"], = self.subplot.plot(\n                    self.time_data, \n                    self.custom_metrics[metric_key][\"data\"], \n                    label=display_name,\n                    visible=visible\n                )\n            \n            # Update legend\n            self.subplot.legend()\n            self.canvas.draw()\n            \n        # Add checkbox for visibility control\n        if hasattr(self, 'plugin_checkboxes_frame') and self.plugin_checkboxes_frame:\n            var = tk.BooleanVar(value=visible)\n            self.metric_visibility_vars[metric_key] = var\n            \n            # Create frame for checkbox and remove button\n            metric_frame = ttk.Frame(self.plugin_checkboxes_frame)\n            metric_frame.pack(fill=tk.X, padx=2, pady=1)\n            \n            # Add color indicator\n            if color:\n                color_indicator = tk.Label(metric_frame, text=\"   \", bg=color, relief=tk.RIDGE)\n                color_indicator.pack(side=tk.LEFT, padx=(0, 5))\n            \n            # Add checkbox\n            cb = ttk.Checkbutton(\n                metric_frame, \n                text=display_name, \n                variable=var,\n                command=self.update_graph_visibility\n            )\n            cb.pack(side=tk.LEFT, fill=tk.X, expand=True)\n            \n            # Add remove button\n            remove_btn = ttk.Button(\n                metric_frame, \n                text=\"X\", \n                width=2,\n                command=lambda key=metric_key: self.remove_custom_metric_from_graph(key)\n            )\n            remove_btn.pack(side=tk.RIGHT)\n            \n    def remove_custom_metric_from_graph(self, metric_key: str):\n        \"\"\"\n        Remove a custom metric from the graph\n        \n        Args:\n            metric_key: Metric key\n        \"\"\"\n        if metric_key not in self.custom_metrics:\n            return  # Metric not found\n            \n        # Remove the metric line from the graph\n        info = self.custom_metrics[metric_key]\n        line = info[\"line\"]\n        if line:\n            line.remove()\n            \n        # Remove from custom metrics\n        del self.custom_metrics[metric_key]\n        \n        # Remove checkbox\n        if metric_key in self.metric_visibility_vars:\n            # Find and destroy the frame containing this metric's checkbox\n            for widget in self.plugin_checkboxes_frame.winfo_children():\n                for child in widget.winfo_children():\n                    if isinstance(child, ttk.Checkbutton) and child.cget(\"text\") == info[\"display_name\"]:\n                        widget.destroy()\n                        break\n            \n            # Remove from variables\n            del self.metric_visibility_vars[metric_key]\n        \n        # Redraw the graph\n        self.subplot.legend()\n        self.canvas.draw()\n        \n    def remove_all_custom_metrics(self):\n        \"\"\"Remove all custom metrics from the graph\"\"\"\n        # Ask for confirmation\n        if messagebox.askyesno(\"Remove Custom Metrics\", \"Are you sure you want to remove all custom metrics?\"):\n            # Get keys first to avoid modifying dict during iteration\n            keys = list(self.custom_metrics.keys())\n            for key in keys:\n                self.remove_custom_metric_from_graph(key)\n                \n    def update_custom_metrics_data(self):\n        \"\"\"Update data for custom metrics\"\"\"\n        if not self.system_monitor or not self.custom_metrics:\n            return\n            \n        try:\n            # Get custom metrics\n            metrics = getattr(self.system_monitor, \"get_all_metrics\", lambda: {\"custom\": {}})()\n            \n            if \"custom\" not in metrics:\n                return\n                \n            # Update each custom metric\n            for key, info in self.custom_metrics.items():\n                if key in metrics[\"custom\"]:\n                    metric = metrics[\"custom\"][key]\n                    value = metric[\"value\"]\n                    \n                    # Convert to percentage for the graph if needed\n                    if metric[\"metadata\"][\"format\"] == \"percentage\":\n                        # Already a percentage, use directly\n                        graph_value = float(value)\n                    elif metric[\"metadata\"][\"format\"] == \"numeric\":\n                        # Scale numeric values to fit in the graph (0-100)\n                        # We need to estimate a reasonable scale\n                        if hasattr(self, \"_metric_max_values\"):\n                            # Update max value if needed\n                            if key not in self._metric_max_values or value > self._metric_max_values[key]:\n                                self._metric_max_values[key] = max(1.0, value * 1.1)  # Add 10% margin\n                        else:\n                            # Initialize max values dictionary\n                            self._metric_max_values = {key: max(1.0, value * 1.1)}\n                            \n                        # Scale to 0-100 based on max value seen so far\n                        max_value = self._metric_max_values[key]\n                        graph_value = (value / max_value) * 100\n                        graph_value = min(100, graph_value)  # Cap at 100%\n                    else:\n                        # For text metrics, just use 50% as a visual indicator\n                        graph_value = 50\n                        \n                    # Update data\n                    info[\"data\"].append(graph_value)\n                    info[\"data\"].pop(0)\n                else:\n                    # Metric not available, add 0\n                    info[\"data\"].append(0)\n                    info[\"data\"].pop(0)\n                    \n        except Exception as e:\n            self.log(f\"Error updating custom metrics data: {e}\", \"ERROR\")\n\n    def refresh(self): # <<< ADD THIS METHOD\n        \"\"\"Manually refresh the displayed metrics.\"\"\"\n        self.log(\"Manual refresh triggered\")\n        # Stop the automatic timer temporarily to avoid race conditions\n        is_running = self.running\n        if is_running:\n            self.stop_monitoring()\n\n        # Force an immediate update of metrics\n        # We can call the logic from update_metrics directly here\n        # Or, if update_metrics is complex, extract the core update logic\n        # into a helper method called by both refresh() and update_metrics().\n        # For simplicity, let's reuse the update_metrics core logic:\n        try:\n            if self.system_monitor:\n                # Get system info\n                system_info = self.system_monitor.get_system_info()\n\n                # Update top labels\n                cpu_usage = system_info[\"cpu\"][\"usage_percent\"]\n                self.cpu_label.config(text=f\"CPU: {cpu_usage:.1f}%\")\n\n                ram_usage = system_info[\"ram\"][\"usage_percent\"]\n                self.ram_label.config(text=f\"RAM: {ram_usage:.1f}%\")\n\n                gpu_usage = system_info[\"gpu\"][\"usage_percent\"]\n                self.gpu_label.config(text=f\"GPU: {gpu_usage}\")\n\n                disk_usage = system_info[\"disk\"][\"usage_percent\"]\n                self.disk_label.config(text=f\"Disk: {disk_usage:.1f}%\")\n\n                # Update system tab details\n                self.update_system_details(system_info)\n\n                # Update processes tab\n                self.update_processes()\n\n                # Update plugin metrics tab\n                self.update_plugin_metrics()\n\n                # Note: We don't update the graph data here, as refresh\n                #       is usually for the static displays, not the time-series graph.\n                #       If graph update is desired, uncomment graph update lines from\n                #       update_metrics here.\n\n            else:\n                # Handle case where system_monitor is not available\n                 self.log(\"System monitor not available for refresh.\", \"WARNING\")\n\n\n        except Exception as e:\n            self.log(f\"Error during manual refresh: {e}\", \"ERROR\")\n\n        # Restart the automatic timer if it was running\n        if is_running:\n            self.start_monitoring()\n\n\n    def update_metrics(self):\n        \"\"\"Update resource metrics display\"\"\"\n        if not self.running:\n            return\n\n        try:\n            if self.system_monitor:\n                # Get system info\n                system_info = self.system_monitor.get_system_info()\n\n                # Update top labels\n                cpu_usage = system_info[\"cpu\"][\"usage_percent\"]\n                self.cpu_label.config(text=f\"CPU: {cpu_usage:.1f}%\")\n\n                ram_usage = system_info[\"ram\"][\"usage_percent\"]\n                self.ram_label.config(text=f\"RAM: {ram_usage:.1f}%\")\n\n                gpu_usage = system_info[\"gpu\"][\"usage_percent\"]\n                self.gpu_label.config(text=f\"GPU: {gpu_usage}\")\n\n                disk_usage = system_info[\"disk\"][\"usage_percent\"]\n                self.disk_label.config(text=f\"Disk: {disk_usage:.1f}%\")\n\n                # Update graph data\n                self.cpu_data.append(cpu_usage)\n                self.cpu_data.pop(0)\n\n                self.ram_data.append(ram_usage)\n                self.ram_data.pop(0)\n\n                try:\n                    if gpu_usage != \"N/A\":\n                        gpu_value = float(gpu_usage.replace(\"%\", \"\"))\n                    else:\n                        gpu_value = 0\n                except:\n                    gpu_value = 0\n\n                self.gpu_data.append(gpu_value)\n                self.gpu_data.pop(0)\n\n                # Update custom metrics\n                self.update_custom_metrics_data()\n\n                # Update graph lines\n                self.cpu_line.set_ydata(self.cpu_data)\n                self.ram_line.set_ydata(self.ram_data)\n                self.gpu_line.set_ydata(self.gpu_data)\n\n                for key, info in self.custom_metrics.items():\n                    if info[\"line\"]:\n                        info[\"line\"].set_ydata(info[\"data\"])\n\n                # Draw the canvas\n                self.canvas.draw_idle()\n\n                # Update system tab details\n                self.update_system_details(system_info)\n\n                # Update processes tab\n                self.update_processes()\n\n                # Update plugin metrics tab\n                self.update_plugin_metrics()\n\n            else:\n                # No system monitor available\n                self.cpu_label.config(text=\"CPU: N/A\")\n                self.ram_label.config(text=\"RAM: N/A\")\n                self.gpu_label.config(text=\"GPU: N/A\")\n                self.disk_label.config(text=\"Disk: N/A\")\n\n        except Exception as e:\n            self.log(f\"Error updating metrics: {e}\", \"ERROR\")\n\n        finally:\n            # Schedule next update only if still running\n            if self.running:\n                self.update_timer_id = self.frame.after(self.update_interval, self.update_metrics)\n\n    def update_system_details(self, system_info: Dict[str, Any]):\n        \"\"\"\n        Update the system details treeview\n        \n        Args:\n            system_info: System information dictionary\n        \"\"\"\n        # Clear existing items\n        for item in self.system_tree.get_children(self.cpu_item):\n            self.system_tree.delete(item)\n        for item in self.system_tree.get_children(self.ram_item):\n            self.system_tree.delete(item)\n        for item in self.system_tree.get_children(self.gpu_item):\n            self.system_tree.delete(item)\n        for item in self.system_tree.get_children(self.disk_item):\n            self.system_tree.delete(item)\n            \n        # Add CPU info\n        cpu_usage = system_info[\"cpu\"][\"usage_percent\"]\n        self.system_tree.insert(self.cpu_item, \"end\", values=(\"Usage\", f\"{cpu_usage:.1f}%\"))\n        \n        # Get additional CPU info from psutil if available\n        try:\n            cpu_count = psutil.cpu_count(logical=False)\n            logical_count = psutil.cpu_count(logical=True)\n            cpu_freq = psutil.cpu_freq()\n            \n            self.system_tree.insert(self.cpu_item, \"end\", values=(\"Physical cores\", str(cpu_count)))\n            self.system_tree.insert(self.cpu_item, \"end\", values=(\"Logical cores\", str(logical_count)))\n            \n            if cpu_freq:\n                self.system_tree.insert(self.cpu_item, \"end\", \n                                     values=(\"Current frequency\", f\"{cpu_freq.current:.0f} MHz\"))\n                if hasattr(cpu_freq, \"min\") and cpu_freq.min:\n                    self.system_tree.insert(self.cpu_item, \"end\", \n                                         values=(\"Min frequency\", f\"{cpu_freq.min:.0f} MHz\"))\n                if hasattr(cpu_freq, \"max\") and cpu_freq.max:\n                    self.system_tree.insert(self.cpu_item, \"end\", \n                                         values=(\"Max frequency\", f\"{cpu_freq.max:.0f} MHz\"))\n        except:\n            pass\n            \n        # Add RAM info\n        ram_percent = system_info[\"ram\"][\"usage_percent\"]\n        ram_used = system_info[\"ram\"][\"used_gb\"]\n        ram_total = system_info[\"ram\"][\"total_gb\"]\n        \n        self.system_tree.insert(self.ram_item, \"end\", values=(\"Usage\", f\"{ram_percent:.1f}%\"))\n        self.system_tree.insert(self.ram_item, \"end\", values=(\"Used\", f\"{ram_used:.2f} GB\"))\n        self.system_tree.insert(self.ram_item, \"end\", values=(\"Total\", f\"{ram_total:.2f} GB\"))\n        self.system_tree.insert(self.ram_item, \"end\", values=(\"Free\", f\"{ram_total - ram_used:.2f} GB\"))\n        \n        # Get additional memory info from psutil if available\n        try:\n            swap = psutil.swap_memory()\n            self.system_tree.insert(self.ram_item, \"end\", values=(\"Swap usage\", f\"{swap.percent:.1f}%\"))\n            self.system_tree.insert(self.ram_item, \"end\", values=(\"Swap used\", f\"{swap.used / (1024**3):.2f} GB\"))\n            self.system_tree.insert(self.ram_item, \"end\", values=(\"Swap total\", f\"{swap.total / (1024**3):.2f} GB\"))\n        except:\n            pass\n            \n        # Add GPU info\n        gpu_usage = system_info[\"gpu\"][\"usage_percent\"]\n        gpu_memory = system_info[\"gpu\"][\"memory\"]\n        \n        self.system_tree.insert(self.gpu_item, \"end\", values=(\"Usage\", str(gpu_usage)))\n        self.system_tree.insert(self.gpu_item, \"end\", values=(\"Memory\", str(gpu_memory)))\n        \n        # Add additional GPU info from nvidia-smi if available\n        try:\n            if hasattr(self.system_monitor, 'get_gpu_info'):\n                gpu_info = self.system_monitor.get_gpu_info()\n                if gpu_info:\n                    for key, value in gpu_info.items():\n                        if key not in [\"usage_percent\", \"memory\"]:\n                            self.system_tree.insert(self.gpu_item, \"end\", values=(key.replace(\"_\", \" \").title(), str(value)))\n        except:\n            pass\n            \n        # Add Disk info\n        disk_percent = system_info[\"disk\"][\"usage_percent\"]\n        disk_free = system_info[\"disk\"][\"free_gb\"]\n        disk_total = system_info[\"disk\"][\"total_gb\"]\n        \n        self.system_tree.insert(self.disk_item, \"end\", values=(\"Usage\", f\"{disk_percent:.1f}%\"))\n        self.system_tree.insert(self.disk_item, \"end\", values=(\"Free\", f\"{disk_free:.2f} GB\"))\n        self.system_tree.insert(self.disk_item, \"end\", values=(\"Total\", f\"{disk_total:.2f} GB\"))\n        self.system_tree.insert(self.disk_item, \"end\", values=(\"Used\", f\"{disk_total - disk_free:.2f} GB\"))",
  "D:\\AI\\IrintAI Assistant\\utils\\logger.py": "\"\"\"\nEnhanced logging utility for the Irintai assistant\n\"\"\"\nimport os\nimport logging\nimport datetime\nimport time\nimport threading\nimport shutil\nfrom logging.handlers import RotatingFileHandler\nfrom typing import Optional, List, Dict, Any, Callable, Set, Union\n\nclass IrintaiLogger:\n    \"\"\"Enhanced logging with file rotation, formatting, and UI integration\"\"\"\n    \n    def __init__(self, \n                 log_dir: str = \"data/logs\",\n                 latest_log_file: str = \"irintai_debug.log\",\n                 console_callback: Optional[Callable] = None,\n                 max_size_mb: int = 10,\n                 backup_count: int = 5):\n        \"\"\"\n        Initialize the logger\n        \n        Args:\n            log_dir: Directory to store log files\n            latest_log_file: Path to the latest log symlink/copy\n            console_callback: Function to call for console UI updates\n            max_size_mb: Maximum log file size in MB\n            backup_count: Number of backup log files to keep\n        \"\"\"\n        self.log_dir = log_dir\n        self.latest_log_file = latest_log_file\n        self.console_callback = console_callback\n        self.console_lines = []\n        self.max_console_lines = 1000\n        self.max_size_mb = max_size_mb\n        self.backup_count = backup_count\n        self.plugin_loggers = {}  # Store plugin-specific loggers\n        \n        # Create logs directory if it doesn't exist\n        os.makedirs(log_dir, exist_ok=True)\n        \n        # Set up the main debug log file with timestamp\n        timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        self.debug_log_file = f\"{log_dir}/irintai_debug_{timestamp}.log\"\n        \n        # Create rotating file handler\n        handler = RotatingFileHandler(\n            self.debug_log_file, \n            maxBytes=max_size_mb*1024*1024,\n            backupCount=backup_count,\n            encoding='utf-8'\n        )\n        \n        # Configure formatter\n        formatter = logging.Formatter(\n            '%(asctime)s [%(levelname)s] %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n        \n        # Set up logger\n        self.logger = logging.getLogger('irintai')\n        self.logger.setLevel(logging.DEBUG)\n        \n        # Remove any existing handlers to avoid duplicates\n        for hdlr in self.logger.handlers:\n            self.logger.removeHandler(hdlr)\n            \n        self.logger.addHandler(handler)\n        \n        # Create symlink or copy for latest log\n        self._setup_latest_log_link()\n        \n        # Set up plugins directory\n        self.plugins_log_dir = os.path.join(log_dir, \"plugins\")\n        os.makedirs(self.plugins_log_dir, exist_ok=True)\n        \n        # Set up event listeners for log events\n        self.log_listeners = {}\n        \n        # Log startup message\n        self.logger.info(f\"=== Irintai Assistant Started ===\")\n        self.logger.info(f\"Log file: {self.debug_log_file}\")\n        \n    def _setup_latest_log_link(self):\n        \"\"\"Set up symlink or copy for the latest log file\"\"\"\n        try:\n            # For Windows, copy the file instead of symlink\n            if os.name == 'nt':\n                with open(self.debug_log_file, 'a', encoding='utf-8') as src:\n                    src.write(f\"Log started at {datetime.datetime.now()}\\n\")\n                    \n                # Use a file watcher in a separate thread to update the copy\n                self._start_log_file_watcher()\n            else:\n                # For Unix-like systems, use a symlink\n                if os.path.exists(self.latest_log_file):\n                    os.remove(self.latest_log_file)\n                os.symlink(self.debug_log_file, self.latest_log_file)\n        except Exception as e:\n            print(f\"Warning: Could not create log symlink/copy: {e}\")\n    \n    def _start_log_file_watcher(self):\n        \"\"\"Start a thread to watch the log file and update the copy periodically\"\"\"\n        def watcher_thread():\n            last_size = 0\n            while True:\n                try:\n                    # Check if the source file has changed\n                    current_size = os.path.getsize(self.debug_log_file)\n                    if current_size > last_size:\n                        # Copy the file to the latest.log location\n                        shutil.copy2(self.debug_log_file, self.latest_log_file)\n                        last_size = current_size\n                except Exception:\n                    pass  # Ignore errors in the watcher\n                    \n                # Sleep before checking again\n                time.sleep(2)\n        \n        threading.Thread(target=watcher_thread, daemon=True).start()\n    \n    def log(self, msg: str, level: str = \"INFO\", plugin_id: str = None, \n            emit_event: bool = True, tags: List[str] = None) -> None:\n        \"\"\"\n        Log a message\n        \n        Args:\n            msg: Message to log\n            level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n            plugin_id: Optional plugin identifier for plugin-specific logs\n            emit_event: Whether to emit a log event for listeners\n            tags: Optional list of tags for log categorization\n        \"\"\"\n        try:\n            log_entry = {\n                \"timestamp\": datetime.datetime.now().isoformat(),\n                \"level\": level,\n                \"message\": msg,\n                \"plugin_id\": plugin_id,\n                \"tags\": tags or []\n            }\n            \n            # Format message with plugin identifier if provided\n            formatted_msg = msg\n            if plugin_id:\n                formatted_msg = f\"[Plugin: {plugin_id}] {msg}\"\n                \n                # Log to plugin-specific logger if available\n                plugin_logger = self.get_plugin_logger(plugin_id)\n                if plugin_logger:\n                    self._log_with_level(plugin_logger, level, msg)\n\n            # Log to main logger\n            self._log_with_level(self.logger, level, formatted_msg)\n                \n            # Add to console lines\n            self.console_lines.append(formatted_msg)\n            \n            # Trim console lines if too many\n            if len(self.console_lines) > self.max_console_lines:\n                self.console_lines = self.console_lines[-self.max_console_lines:]\n                \n            # Update console if callback provided\n            if self.console_callback:\n                self.console_callback(formatted_msg)\n                \n            # Emit log event for listeners\n            if emit_event:\n                self._emit_log_event(log_entry)\n                \n        except Exception as e:\n            # Fallback to basic print if logging fails\n            print(f\"Logging error: {e}\")\n            print(msg)\n    \n    def _log_with_level(self, logger, level: str, msg: str) -> None:\n        \"\"\"Log a message with the specified level to the given logger\"\"\"\n        if level == \"DEBUG\" or \"[DEBUG]\" in msg:\n            logger.debug(msg)\n        elif level == \"INFO\" or \"[INFO]\" in msg:\n            logger.info(msg)\n        elif level == \"WARNING\" or \"[Warning]\" in msg or \"[WARNING]\" in msg:\n            logger.warning(msg)\n        elif level == \"ERROR\" or \"[Error]\" in msg or \"[ERROR]\" in msg:\n            logger.error(msg)\n        elif level == \"CRITICAL\" or \"[CRITICAL]\" in msg:\n            logger.critical(msg)\n        else:\n            logger.info(msg)\n            \n    def _emit_log_event(self, log_entry: Dict[str, Any]) -> None:\n        \"\"\"Emit a log event to registered listeners\"\"\"\n        level = log_entry['level']\n        plugin_id = log_entry.get('plugin_id')\n        \n        # Event keys to check\n        event_keys = [\n            \"log\",                       # All logs\n            f\"log.{level.lower()}\",      # Logs of specific level\n        ]\n        \n        # Add plugin-specific event keys if plugin_id is provided\n        if plugin_id:\n            event_keys.append(f\"log.plugin.{plugin_id}\")\n            event_keys.append(f\"log.plugin.{plugin_id}.{level.lower()}\")\n        \n        # Notify listeners\n        for key in event_keys:\n            if key in self.log_listeners:\n                for listener in self.log_listeners[key]:\n                    try:\n                        listener(log_entry)\n                    except Exception as e:\n                        # Don't use self.log here to avoid infinite recursion\n                        print(f\"Error in log listener: {e}\")\n    \n    def register_log_listener(self, event_key: str, callback: Callable) -> None:\n        \"\"\"\n        Register a listener for log events\n        \n        Args:\n            event_key: Event key to listen for \n                       (\"log\", \"log.info\", \"log.error\", \"log.plugin.{plugin_id}\", etc.)\n            callback: Function to call when event occurs\n        \"\"\"\n        if event_key not in self.log_listeners:\n            self.log_listeners[event_key] = set()\n        \n        self.log_listeners[event_key].add(callback)\n        \n    def unregister_log_listener(self, event_key: str, callback: Callable) -> None:\n        \"\"\"\n        Unregister a listener for log events\n        \n        Args:\n            event_key: Event key the listener was registered for\n            callback: Function to unregister\n        \"\"\"\n        if event_key in self.log_listeners and callback in self.log_listeners[event_key]:\n            self.log_listeners[event_key].remove(callback)\n            \n    def get_plugin_logger(self, plugin_id: str) -> Optional[logging.Logger]:\n        \"\"\"\n        Get or create a logger for a specific plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            Logger instance for the plugin\n        \"\"\"\n        if plugin_id in self.plugin_loggers:\n            return self.plugin_loggers[plugin_id]\n            \n        try:\n            # Create plugin-specific log directory\n            plugin_log_dir = os.path.join(self.plugins_log_dir, plugin_id)\n            os.makedirs(plugin_log_dir, exist_ok=True)\n            \n            # Create log file for the plugin\n            timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            log_file = os.path.join(plugin_log_dir, f\"{plugin_id}_{timestamp}.log\")\n            \n            # Create rotating file handler\n            handler = RotatingFileHandler(\n                log_file, \n                maxBytes=self.max_size_mb*1024*1024,\n                backupCount=self.backup_count,\n                encoding='utf-8'\n            )\n            \n            # Configure formatter\n            formatter = logging.Formatter(\n                '%(asctime)s [%(levelname)s] %(message)s',\n                datefmt='%Y-%m-%d %H:%M:%S'\n            )\n            handler.setFormatter(formatter)\n            \n            # Create logger\n            logger = logging.getLogger(f'irintai.plugin.{plugin_id}')\n            logger.setLevel(logging.DEBUG)\n            \n            # Remove any existing handlers\n            for hdlr in logger.handlers:\n                logger.removeHandler(hdlr)\n                \n            logger.addHandler(handler)\n            \n            # Store logger in plugin_loggers\n            self.plugin_loggers[plugin_id] = logger\n            \n            # Create latest log symlink/copy for the plugin\n            latest_log = os.path.join(plugin_log_dir, f\"{plugin_id}_latest.log\")\n            \n            if os.name == 'nt':\n                # For Windows, copy the file\n                shutil.copy2(log_file, latest_log)\n            else:\n                # For Unix-like systems, create symlink\n                if os.path.exists(latest_log):\n                    os.remove(latest_log)\n                os.symlink(log_file, latest_log)\n            \n            return logger\n        except Exception as e:\n            self.error(f\"Failed to create plugin logger for {plugin_id}: {e}\")\n            return None\n            \n    def debug(self, msg: str, plugin_id: str = None, tags: List[str] = None) -> None:\n        \"\"\"Log a debug message\"\"\"\n        self.log(msg, \"DEBUG\", plugin_id, tags=tags)\n        \n    def info(self, msg: str, plugin_id: str = None, tags: List[str] = None) -> None:\n        \"\"\"Log an info message\"\"\"\n        self.log(msg, \"INFO\", plugin_id, tags=tags)\n        \n    def warning(self, msg: str, plugin_id: str = None, tags: List[str] = None) -> None:\n        \"\"\"Log a warning message\"\"\"\n        self.log(msg, \"WARNING\", plugin_id, tags=tags)\n        \n    def error(self, msg: str, plugin_id: str = None, tags: List[str] = None) -> None:\n        \"\"\"Log an error message\"\"\"\n        self.log(msg, \"ERROR\", plugin_id, tags=tags)\n        \n    def critical(self, msg: str, plugin_id: str = None, tags: List[str] = None) -> None:\n        \"\"\"Log a critical message\"\"\"\n        self.log(msg, \"CRITICAL\", plugin_id, tags=tags)\n    \n    def plugin_log(self, plugin_id: str, msg: str, level: str = \"INFO\", tags: List[str] = None) -> None:\n        \"\"\"\n        Log a message for a specific plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            msg: Message to log\n            level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n            tags: Optional list of tags for log categorization\n        \"\"\"\n        self.log(msg, level, plugin_id, tags=tags)\n    \n    def get_console_lines(self, filter_type: str = None, plugin_id: str = None, \n                          limit: int = None, tags: List[str] = None) -> List[str]:\n        \"\"\"\n        Get console lines with optional filtering\n        \n        Args:\n            filter_type: Optional filter (User, Model, Error, Warning, etc.)\n            plugin_id: Optional plugin ID to filter by\n            limit: Optional limit on number of lines\n            tags: Optional list of tags to filter by\n            \n        Returns:\n            List of filtered console lines\n        \"\"\"\n        filtered_lines = []\n        \n        # Apply basic filter\n        if not filter_type or filter_type == \"All\":\n            filtered_lines = self.console_lines.copy()\n        else:\n            for line in self.console_lines:\n                if filter_type == \"User\" and (line.startswith(\"> \") or \"[User]\" in line):\n                    filtered_lines.append(line)\n                elif filter_type == \"Model\" and \"[Assistant]\" in line:\n                    filtered_lines.append(line)\n                elif filter_type == \"Error\" and (\"[Error]\" in line or \"[ERROR]\" in line):\n                    filtered_lines.append(line)\n                elif filter_type == \"Warning\" and (\"[Warning]\" in line or \"[WARNING]\" in line):\n                    filtered_lines.append(line)\n                    \n        # Apply plugin filter\n        if plugin_id:\n            plugin_marker = f\"[Plugin: {plugin_id}]\"\n            filtered_lines = [line for line in filtered_lines if plugin_marker in line]\n            \n        # Apply tag filter (not actually implemented in console_lines storage yet)\n        # This would require changing how we store console lines to include metadata\n                \n        # Apply limit\n        if limit and len(filtered_lines) > limit:\n            filtered_lines = filtered_lines[-limit:]\n                \n        return filtered_lines\n    \n    def save_console_log(self, filename: Optional[str] = None, \n                         filter_type: str = None, plugin_id: str = None) -> str:\n        \"\"\"\n        Save current console log to a file\n        \n        Args:\n            filename: Optional filename to save to\n            filter_type: Optional filter (User, Model, Error, Warning, etc.)\n            plugin_id: Optional plugin ID to filter by\n            \n        Returns:\n            Path to the saved file\n        \"\"\"\n        if not filename:\n            timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            prefix = \"irintai_console\"\n            if plugin_id:\n                prefix = f\"irintai_plugin_{plugin_id}\"\n            filename = f\"{prefix}_{timestamp}.log\"\n            \n        try:\n            # Get filtered lines\n            lines = self.get_console_lines(filter_type, plugin_id)\n            \n            with open(filename, \"w\", encoding=\"utf-8\") as f:\n                f.write(f\"=== Irintai Console Log - {datetime.datetime.now()} ===\\n\\n\")\n                if plugin_id:\n                    f.write(f\"Plugin: {plugin_id}\\n\\n\")\n                if filter_type and filter_type != \"All\":\n                    f.write(f\"Filter: {filter_type}\\n\\n\")\n                    \n                for line in lines:\n                    f.write(f\"{line}\\n\")\n                    \n            self.info(f\"Console log saved to {filename}\")\n            return filename\n        except Exception as e:\n            self.error(f\"Failed to save console log: {e}\")\n            return \"\"\n    \n    def clear_console(self) -> None:\n        \"\"\"Clear the console log\"\"\"\n        self.console_lines = []\n        self.info(\"Console log cleared\")\n        \n    def set_console_callback(self, callback: Callable) -> None:\n        \"\"\"\n        Set the console callback function\n        \n        Args:\n            callback: Function to call for console updates\n        \"\"\"\n        self.console_callback = callback\n        \n    def get_plugin_logs(self, plugin_id: str, limit: int = None) -> List[str]:\n        \"\"\"\n        Get logs for a specific plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            limit: Optional limit on number of lines\n            \n        Returns:\n            List of log lines for the plugin\n        \"\"\"\n        return self.get_console_lines(plugin_id=plugin_id, limit=limit)\n        \n    def export_plugin_logs(self, plugin_id: str) -> str:\n        \"\"\"\n        Export logs for a specific plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            Path to the exported log file\n        \"\"\"\n        # Create export directory if it doesn't exist\n        export_dir = os.path.join(self.log_dir, \"exports\")\n        os.makedirs(export_dir, exist_ok=True)\n        \n        # Create export filename\n        timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        export_file = os.path.join(export_dir, f\"{plugin_id}_logs_{timestamp}.log\")\n        \n        # Get plugin-specific log file if it exists\n        plugin_log_dir = os.path.join(self.plugins_log_dir, plugin_id)\n        latest_log = os.path.join(plugin_log_dir, f\"{plugin_id}_latest.log\")\n        \n        if os.path.exists(latest_log):\n            # Copy the plugin log file\n            shutil.copy2(latest_log, export_file)\n        else:\n            # Extract plugin logs from main log\n            self.save_console_log(export_file, plugin_id=plugin_id)\n            \n        return export_file\n        \n    def create_plugin_logger(self, plugin_id: str) -> 'PluginLogger':\n        \"\"\"\n        Create a logger interface for a plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            PluginLogger instance\n        \"\"\"\n        return PluginLogger(self, plugin_id)\n        \n\nclass PluginLogger:\n    def __init__(self, main_logger, plugin_id):\n        self.main_logger = main_logger\n        self.plugin_id = plugin_id\n        \n    def log(self, message, level=\"INFO\"):\n        self.main_logger.log(f\"[Plugin: {self.plugin_id}] {message}\", level)",
  "D:\\AI\\IrintAI Assistant\\utils\\system_monitor.py": "\"\"\"\nSystem monitoring utilities for tracking CPU, RAM, GPU, and disk usage\n\"\"\"\nimport os\nimport shutil\nimport subprocess\nimport psutil\nimport time\nimport threading\nimport json\nfrom typing import Dict, Tuple, Any, Optional, List, Callable, Set, Union\n\nclass SystemMonitor:\n    \"\"\"Monitor system resources like CPU, RAM, GPU, and disk space\"\"\"\n    \n    def __init__(self, logger=None, event_bus=None, config=None):\n        \"\"\"\n        Initialize the system monitor\n        \n        Args:\n            logger: Optional logging function\n            event_bus: Optional event bus for notifications\n            config: Optional configuration manager\n        \"\"\"\n        self.logger = logger\n        self.event_bus = event_bus\n        self.config = config\n        \n        # Store custom metrics registered by plugins\n        self.custom_metrics = {}\n        \n        # Process monitoring\n        self.monitored_processes = {}\n        self.process_metrics = {}\n        \n        # Store previous values for change detection\n        self.previous_values = {}\n        \n        # Notification thresholds\n        self.thresholds = {\n            \"cpu\": {\"warning\": 70, \"critical\": 90},\n            \"ram\": {\"warning\": 70, \"critical\": 90},\n            \"gpu\": {\"warning\": 70, \"critical\": 90},\n            \"disk\": {\"warning\": 80, \"critical\": 90},\n            \"vram\": {\"warning\": 80, \"critical\": 90}\n        }\n        \n        # Start monitoring thread\n        self.running = False\n        self.monitor_thread = None\n        \n    def start_monitoring(self, interval: float = 5.0):\n        \"\"\"\n        Start the monitoring thread\n        \n        Args:\n            interval: Monitoring interval in seconds\n        \"\"\"\n        if self.running:\n            return\n            \n        self.running = True\n        self.monitor_thread = threading.Thread(\n            target=self._monitor_loop, \n            args=(interval,), \n            daemon=True\n        )\n        self.monitor_thread.start()\n        self.log(\"[SystemMonitor] Started monitoring thread\")\n        \n    def stop_monitoring(self):\n        \"\"\"Stop the monitoring thread\"\"\"\n        self.running = False\n        if self.monitor_thread:\n            self.monitor_thread.join(timeout=2.0)\n            self.monitor_thread = None\n            self.log(\"[SystemMonitor] Stopped monitoring thread\")\n        \n    def _monitor_loop(self, interval: float):\n        \"\"\"\n        Main monitoring loop\n        \n        Args:\n            interval: Monitoring interval in seconds\n        \"\"\"\n        while self.running:\n            try:\n                # Get system stats\n                system_stats = self.get_system_info()\n                \n                # Check for significant changes\n                self._check_for_changes(system_stats)\n                \n                # Update process metrics\n                self._update_process_metrics()\n                \n                # Update custom metrics\n                self._update_custom_metrics()\n                \n                # Emit system stats event\n                if self.event_bus is not None:\n                    self.event_bus.publish(\"system.stats_updated\", system_stats)\n                    \n            except Exception as e:\n                self.log(f\"[SystemMonitor] Error in monitoring loop: {e}\", \"ERROR\")\n                \n            # Sleep until next check\n            time.sleep(interval)\n        \n    def log(self, msg: str, level: str = \"INFO\") -> None:\n        \"\"\"\n        Log a message if logger is available\n        \n        Args:\n            msg: Message to log\n            level: Log level\n        \"\"\"\n        if self.logger:\n            if hasattr(self.logger, 'log'):\n                self.logger.log(msg, level)\n            else:\n                print(f\"[{level}] {msg}\")\n    \n    def get_gpu_stats(self) -> Tuple[str, str]:\n        \"\"\"\n        Get NVIDIA GPU utilization and memory usage\n        \n        Returns:\n            Tuple containing GPU utilization percentage and memory usage string\n        \"\"\"\n        try:\n            result = subprocess.run(\n                [\"nvidia-smi\", \"--query-gpu=utilization.gpu,memory.used,memory.total\", \n                 \"--format=csv,noheader,nounits\"],\n                capture_output=True, text=True, timeout=2, env=os.environ.copy()\n            )\n            \n            if result.returncode == 0:\n                usage, used, total = result.stdout.strip().split(',')\n                return usage.strip() + \"%\", f\"{used.strip()} MB / {total.strip()} MB\"\n            \n            return \"N/A\", \"N/A\"\n        except Exception as e:\n            self.log(f\"[System Monitor] GPU stats error: {e}\")\n            return \"N/A\", \"N/A\"\n    \n    def get_cpu_usage(self) -> float:\n        \"\"\"\n        Get CPU usage percentage\n        \n        Returns:\n            CPU usage percentage\n        \"\"\"\n        try:\n            return psutil.cpu_percent()\n        except Exception as e:\n            self.log(f\"[System Monitor] CPU usage error: {e}\")\n            return 0.0\n    \n    def get_ram_usage(self) -> Tuple[float, float, float]:\n        \"\"\"\n        Get RAM usage information\n        \n        Returns:\n            Tuple containing RAM usage percentage, used GB, and total GB\n        \"\"\"\n        try:\n            memory = psutil.virtual_memory()\n            used_gb = memory.used / (1024**3)\n            total_gb = memory.total / (1024**3)\n            return memory.percent, used_gb, total_gb\n        except Exception as e:\n            self.log(f\"[System Monitor] RAM usage error: {e}\")\n            return 0.0, 0.0, 0.0\n    \n    def get_disk_space(self, path: str) -> Tuple[float, float, float]:\n        \"\"\"\n        Get disk space for a given path\n        \n        Args:\n            path: Path to check\n            \n        Returns:\n            Tuple containing disk usage percentage, free GB, and total GB\n        \"\"\"\n        try:\n            # Extract the drive letter from the path\n            if os.name == 'nt':  # Windows\n                drive = os.path.splitdrive(path)[0]\n                if drive:\n                    drive = drive + \"\\\\\"\n                else:\n                    drive = \"C:\\\\\"  # Default to C: if no drive letter found\n            else:  # Unix-like\n                drive = path\n                \n            usage = shutil.disk_usage(drive)\n            used_percent = (usage.used / usage.total) * 100\n            free_gb = usage.free / (1024**3)\n            total_gb = usage.total / (1024**3)\n            \n            return used_percent, free_gb, total_gb\n        except Exception as e:\n            self.log(f\"[System Monitor] Disk space error for {path}: {e}\")\n            return 0.0, 0.0, 0.0\n    \n    def get_system_info(self) -> Dict[str, Any]:\n        \"\"\"\n        Get comprehensive system information\n        \n        Returns:\n            Dictionary containing system information\n        \"\"\"\n        info = {\n            \"cpu\": {\n                \"usage_percent\": self.get_cpu_usage()\n            },\n            \"ram\": {},\n            \"gpu\": {},\n            \"disk\": {}\n        }\n        \n        # RAM info\n        ram_percent, ram_used, ram_total = self.get_ram_usage()\n        info[\"ram\"] = {\n            \"usage_percent\": ram_percent,\n            \"used_gb\": round(ram_used, 2),\n            \"total_gb\": round(ram_total, 2)\n        }\n        \n        # GPU info\n        gpu_percent, gpu_memory = self.get_gpu_stats()\n        info[\"gpu\"] = {\n            \"usage_percent\": gpu_percent,\n            \"memory\": gpu_memory\n        }\n        \n        # Disk info for current directory\n        disk_percent, disk_free, disk_total = self.get_disk_space(os.getcwd())\n        info[\"disk\"] = {\n            \"usage_percent\": disk_percent,\n            \"free_gb\": round(disk_free, 2),\n            \"total_gb\": round(disk_total, 2)\n        }\n        \n        return info\n    \n    def get_performance_stats(self) -> Dict[str, str]:\n        \"\"\"\n        Get formatted performance statistics\n        \n        Returns:\n            Dictionary with formatted performance stats\n        \"\"\"\n        # Get CPU usage\n        cpu = self.get_cpu_usage()\n        \n        # Get RAM usage\n        ram_percent, _, _ = self.get_ram_usage()\n        \n        # Get GPU stats\n        gpu, vram = self.get_gpu_stats()\n        \n        return {\n            \"cpu\": f\"{cpu}%\",\n            \"ram\": f\"{ram_percent}%\",\n            \"gpu\": gpu,\n            \"vram\": vram\n        }\n    \n    def is_resource_critical(self) -> Tuple[bool, str]:\n        \"\"\"\n        Check if any resource usage is at a critical level\n        \n        Returns:\n            Tuple containing flag indicating critical status and message\n        \"\"\"\n        system_info = self.get_system_info()\n        \n        # Check CPU usage\n        if system_info[\"cpu\"][\"usage_percent\"] > self.thresholds[\"cpu\"][\"critical\"]:\n            return True, f\"CPU usage is critical (>{self.thresholds['cpu']['critical']}%)\"\n            \n        # Check RAM usage\n        if system_info[\"ram\"][\"usage_percent\"] > self.thresholds[\"ram\"][\"critical\"]:\n            return True, f\"RAM usage is critical (>{self.thresholds['ram']['critical']}%)\"\n            \n        # Check disk space\n        if system_info[\"disk\"][\"free_gb\"] < 5:\n            return True, f\"Low disk space: only {system_info['disk']['free_gb']} GB free\"\n            \n        # Check GPU if available\n        if system_info[\"gpu\"][\"usage_percent\"] != \"N/A\":\n            try:\n                gpu_percent = int(system_info[\"gpu\"][\"usage_percent\"].replace(\"%\", \"\"))\n                if gpu_percent > self.thresholds[\"gpu\"][\"critical\"]:\n                    return True, f\"GPU usage is critical (>{self.thresholds['gpu']['critical']}%)\"\n            except:\n                pass\n                \n        return False, \"\"\n    \n    def get_formatted_stats(self) -> str:\n        \"\"\"\n        Get formatted performance statistics string\n        \n        Returns:\n            Formatted string with performance stats\n        \"\"\"\n        stats = self.get_performance_stats()\n        return f\"CPU: {stats['cpu']} | RAM: {stats['ram']} | GPU: {stats['gpu']} | VRAM: {stats['vram']}\"\n    \n    def get_bgr_color(self) -> str:\n        \"\"\"\n        Get background color based on resource usage\n        \n        Returns:\n            Hex color code for background\n        \"\"\"\n        is_critical, _ = self.is_resource_critical()\n        if is_critical:\n            return \"#ffcccc\"  # Light red\n            \n        system_info = self.get_system_info()\n        \n        # Check for warning level\n        warning_threshold = self.thresholds[\"cpu\"][\"warning\"]\n        if (system_info[\"cpu\"][\"usage_percent\"] > warning_threshold or\n            system_info[\"ram\"][\"usage_percent\"] > warning_threshold):\n            return \"#fff0b3\"  # Light yellow\n        \n        # Check GPU if available\n        if system_info[\"gpu\"][\"usage_percent\"] != \"N/A\":\n            try:\n                gpu_percent = int(system_info[\"gpu\"][\"usage_percent\"].replace(\"%\", \"\"))\n                if gpu_percent > warning_threshold:\n                    return \"#fff0b3\"  # Light yellow\n            except:\n                pass\n                \n        return \"#d1f5d3\"  # Light green for normal usage\n        \n    def register_custom_metric(self, plugin_id: str, metric_id: str, \n                              provider_func: Callable, metadata: Dict = None) -> bool:\n        \"\"\"\n        Register a custom metric from a plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            metric_id: Metric identifier\n            provider_func: Function that returns the metric value\n            metadata: Optional metadata about the metric\n            \n        Returns:\n            True if registration was successful\n        \"\"\"\n        if not callable(provider_func):\n            self.log(f\"[SystemMonitor] Cannot register metric {metric_id}: provider is not callable\", \"ERROR\")\n            return False\n            \n        metric_key = f\"{plugin_id}.{metric_id}\"\n        \n        # Default metadata\n        default_metadata = {\n            \"name\": metric_id,\n            \"description\": f\"Custom metric: {metric_id}\",\n            \"unit\": \"\",\n            \"min\": 0,\n            \"max\": 100,\n            \"warning_threshold\": 70,\n            \"critical_threshold\": 90,\n            \"display\": True,\n            \"category\": \"plugin\",\n            \"format\": \"numeric\"  # numeric, percentage, text\n        }\n        \n        # Merge with provided metadata\n        if metadata:\n            for key, value in metadata.items():\n                default_metadata[key] = value\n                \n        # Store the metric\n        self.custom_metrics[metric_key] = {\n            \"provider\": provider_func,\n            \"metadata\": default_metadata,\n            \"plugin_id\": plugin_id,\n            \"metric_id\": metric_id,\n            \"last_value\": None,\n            \"last_update\": 0\n        }\n        \n        self.log(f\"[SystemMonitor] Registered custom metric: {metric_key}\")\n        return True\n        \n    def unregister_custom_metric(self, plugin_id: str, metric_id: str) -> bool:\n        \"\"\"\n        Unregister a custom metric\n        \n        Args:\n            plugin_id: Plugin identifier\n            metric_id: Metric identifier\n            \n        Returns:\n            True if unregistration was successful\n        \"\"\"\n        metric_key = f\"{plugin_id}.{metric_id}\"\n        \n        if metric_key in self.custom_metrics:\n            del self.custom_metrics[metric_key]\n            self.log(f\"[SystemMonitor] Unregistered custom metric: {metric_key}\")\n            return True\n            \n        return False\n        \n    def unregister_plugin_metrics(self, plugin_id: str) -> int:\n        \"\"\"\n        Unregister all metrics for a plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            Number of metrics unregistered\n        \"\"\"\n        count = 0\n        to_remove = []\n        \n        for metric_key, metric_info in self.custom_metrics.items():\n            if metric_info[\"plugin_id\"] == plugin_id:\n                to_remove.append(metric_key)\n                count += 1\n                \n        for metric_key in to_remove:\n            del self.custom_metrics[metric_key]\n            \n        if count:\n            self.log(f\"[SystemMonitor] Unregistered {count} metrics for plugin: {plugin_id}\")\n            \n        return count\n        \n    def get_custom_metric(self, plugin_id: str, metric_id: str) -> Any:\n        \"\"\"\n        Get the current value of a custom metric\n        \n        Args:\n            plugin_id: Plugin identifier\n            metric_id: Metric identifier\n            \n        Returns:\n            Current metric value or None if not found\n        \"\"\"\n        metric_key = f\"{plugin_id}.{metric_id}\"\n        \n        if metric_key not in self.custom_metrics:\n            return None\n            \n        metric = self.custom_metrics[metric_key]\n        \n        try:\n            # Update the value\n            value = metric[\"provider\"]()\n            metric[\"last_value\"] = value\n            metric[\"last_update\"] = time.time()\n            return value\n        except Exception as e:\n            self.log(f\"[SystemMonitor] Error getting metric {metric_key}: {e}\", \"ERROR\")\n            return metric.get(\"last_value\")\n            \n    def _update_custom_metrics(self):\n        \"\"\"Update all custom metrics\"\"\"\n        for metric_key, metric in list(self.custom_metrics.items()):\n            try:\n                # Get new value\n                value = metric[\"provider\"]()\n                \n                # Check for significant change\n                last_value = metric.get(\"last_value\")\n                if last_value is not None:\n                    metadata = metric[\"metadata\"]\n                    \n                    # Calculate the range for percentage change\n                    value_range = metadata.get(\"max\", 100) - metadata.get(\"min\", 0)\n                    \n                    # If the range is very small, use absolute change\n                    if value_range < 1:\n                        significant_change = abs(value - last_value) >= 0.1\n                    else:\n                        # Check for percentage change\n                        change_percent = abs((value - last_value) / value_range * 100)\n                        significant_change = change_percent >= 5  # 5% change is significant\n                        \n                    # Check for threshold crossing\n                    warning_threshold = metadata.get(\"warning_threshold\")\n                    critical_threshold = metadata.get(\"critical_threshold\")\n                    \n                    crossed_warning = (warning_threshold is not None and \n                                     (last_value < warning_threshold <= value or \n                                      last_value > warning_threshold >= value))\n                    \n                    crossed_critical = (critical_threshold is not None and \n                                      (last_value < critical_threshold <= value or \n                                       last_value > critical_threshold >= value))\n                    \n                    # Emit event if significant change\n                    if (significant_change or crossed_warning or crossed_critical) and self.event_bus is not None:\n                        event_data = {\n                            \"plugin_id\": metric[\"plugin_id\"],\n                            \"metric_id\": metric[\"metric_id\"],\n                            \"value\": value,\n                            \"previous_value\": last_value,\n                            \"metadata\": metadata,\n                            \"crossed_warning\": crossed_warning,\n                            \"crossed_critical\": crossed_critical\n                        }\n                        \n                        self.event_bus.publish(\"system.metric_changed\", event_data)\n                        \n                        # Also emit specific events for threshold crossings\n                        if crossed_warning and self.event_bus is not None:\n                            if value > warning_threshold:\n                                self.event_bus.publish(\"system.metric_warning\", event_data)\n                            else:\n                                self.event_bus.publish(\"system.metric_warning_resolved\", event_data)\n                                \n                        if crossed_critical and self.event_bus is not None:\n                            if value > critical_threshold:\n                                self.event_bus.publish(\"system.metric_critical\", event_data)\n                            else:\n                                self.event_bus.publish(\"system.metric_critical_resolved\", event_data)\n                \n                # Update stored value\n                metric[\"last_value\"] = value\n                metric[\"last_update\"] = time.time()\n                \n            except Exception as e:\n                self.log(f\"[SystemMonitor] Error updating metric {metric_key}: {e}\", \"ERROR\")\n        \n    def _check_for_changes(self, current_stats: Dict[str, Any]):\n        \"\"\"\n        Check for significant changes in system stats\n        \n        Args:\n            current_stats: Current system stats\n        \"\"\"\n        if not self.previous_values:\n            # First time, just store the values\n            self.previous_values = self._extract_key_values(current_stats)\n            return\n            \n        # Extract current values\n        current_values = self._extract_key_values(current_stats)\n        \n        # Check for significant changes\n        for key, value in current_values.items():\n            if key not in self.previous_values:\n                continue\n                \n            prev_value = self.previous_values[key]\n            \n            # Skip non-numeric values\n            if not isinstance(value, (int, float)) or not isinstance(prev_value, (int, float)):\n                continue\n                \n            # Check for significant change (5% or more)\n            if abs(value - prev_value) >= 5:\n                # Emit event if event bus is available\n                if self.event_bus is not None:\n                    event_data = {\n                        \"metric\": key,\n                        \"value\": value,\n                        \"previous_value\": prev_value,\n                        \"change\": value - prev_value\n                    }\n                    self.event_bus.publish(\"system.significant_change\", event_data)\n                    \n                # Check for threshold crossings\n                if key in self.thresholds:\n                    warning = self.thresholds[key][\"warning\"]\n                    critical = self.thresholds[key][\"critical\"]\n                    \n                    # Check warning threshold crossing\n                    if (prev_value < warning <= value or \n                        prev_value > warning >= value):\n                        \n                        event_data = {\n                            \"metric\": key,\n                            \"value\": value,\n                            \"threshold\": warning,\n                            \"severity\": \"warning\",\n                            \"exceeded\": value >= warning\n                        }\n                        \n                        if value >= warning:\n                            self.event_bus.publish(\"system.threshold_exceeded\", event_data)\n                        else:\n                            self.event_bus.publish(\"system.threshold_resolved\", event_data)\n                            \n                    # Check critical threshold crossing\n                    if (prev_value < critical <= value or \n                        prev_value > critical >= value):\n                        \n                        event_data = {\n                            \"metric\": key,\n                            \"value\": value,\n                            \"threshold\": critical,\n                            \"severity\": \"critical\",\n                            \"exceeded\": value >= critical\n                        }\n                        \n                        if value >= critical:\n                            self.event_bus.publish(\"system.threshold_exceeded\", event_data)\n                        else:\n                            self.event_bus.publish(\"system.threshold_resolved\", event_data)\n        \n        # Update previous values\n        self.previous_values = current_values\n    \n    def _extract_key_values(self, stats: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Extract key values from system stats for change detection\n        \n        Args:\n            stats: System stats dictionary\n            \n        Returns:\n            Dictionary of key values\n        \"\"\"\n        result = {}\n        \n        # Extract CPU usage\n        if \"cpu\" in stats and \"usage_percent\" in stats[\"cpu\"]:\n            result[\"cpu\"] = stats[\"cpu\"][\"usage_percent\"]\n            \n        # Extract RAM usage\n        if \"ram\" in stats and \"usage_percent\" in stats[\"ram\"]:\n            result[\"ram\"] = stats[\"ram\"][\"usage_percent\"]\n            \n        # Extract GPU usage\n        if \"gpu\" in stats and \"usage_percent\" in stats[\"gpu\"]:\n            try:\n                if stats[\"gpu\"][\"usage_percent\"] != \"N/A\":\n                    result[\"gpu\"] = int(stats[\"gpu\"][\"usage_percent\"].replace(\"%\", \"\"))\n            except:\n                pass\n                \n        # Extract disk usage\n        if \"disk\" in stats and \"usage_percent\" in stats[\"disk\"]:\n            result[\"disk\"] = stats[\"disk\"][\"usage_percent\"]\n            \n        return result\n        \n    def register_process_monitor(self, plugin_id: str, process_id: int, \n                               name: str = None, unregister_on_exit: bool = True):\n        \"\"\"\n        Register a process for monitoring\n        \n        Args:\n            plugin_id: Plugin identifier\n            process_id: Process ID to monitor\n            name: Optional name for the process\n            unregister_on_exit: Whether to unregister when process exits\n            \n        Returns:\n            True if registration was successful\n        \"\"\"\n        try:\n            # Check if process exists\n            process = psutil.Process(process_id)\n            \n            # Store process info\n            if not name:\n                name = process.name()\n                \n            key = f\"{plugin_id}:{process_id}\"\n            self.monitored_processes[key] = {\n                \"plugin_id\": plugin_id,\n                \"process_id\": process_id,\n                \"name\": name,\n                \"unregister_on_exit\": unregister_on_exit,\n                \"start_time\": time.time()\n            }\n            \n            self.log(f\"[SystemMonitor] Registered process monitor for {name} (PID: {process_id}) from plugin {plugin_id}\")\n            return True\n        except Exception as e:\n            self.log(f\"[SystemMonitor] Error registering process monitor: {e}\", \"ERROR\")\n            return False\n            \n    def unregister_process_monitor(self, plugin_id: str, process_id: int) -> bool:\n        \"\"\"\n        Unregister a process monitor\n        \n        Args:\n            plugin_id: Plugin identifier\n            process_id: Process ID\n            \n        Returns:\n            True if unregistration was successful\n        \"\"\"\n        key = f\"{plugin_id}:{process_id}\"\n        \n        if key in self.monitored_processes:\n            del self.monitored_processes[key]\n            \n            # Clean up process metrics\n            if key in self.process_metrics:\n                del self.process_metrics[key]\n                \n            self.log(f\"[SystemMonitor] Unregistered process monitor for PID {process_id} from plugin {plugin_id}\")\n            return True\n            \n        return False\n        \n    def unregister_plugin_processes(self, plugin_id: str) -> int:\n        \"\"\"\n        Unregister all process monitors for a plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            Number of processes unregistered\n        \"\"\"\n        count = 0\n        to_remove = []\n        \n        for key, info in self.monitored_processes.items():\n            if info[\"plugin_id\"] == plugin_id:\n                to_remove.append(key)\n                count += 1\n                \n        for key in to_remove:\n            del self.monitored_processes[key]\n            \n            # Clean up process metrics\n            if key in self.process_metrics:\n                del self.process_metrics[key]\n                \n        if count:\n            self.log(f\"[SystemMonitor] Unregistered {count} process monitors for plugin {plugin_id}\")\n            \n        return count\n        \n    def get_process_metrics(self, plugin_id: str, process_id: int) -> Dict[str, Any]:\n        \"\"\"\n        Get metrics for a monitored process\n        \n        Args:\n            plugin_id: Plugin identifier\n            process_id: Process ID\n            \n        Returns:\n            Dictionary of process metrics or empty dict if not found\n        \"\"\"\n        key = f\"{plugin_id}:{process_id}\"\n        \n        if key not in self.monitored_processes:\n            return {}\n            \n        # Return cached metrics if available\n        if key in self.process_metrics:\n            return self.process_metrics[key]\n            \n        # Get process metrics\n        try:\n            process = psutil.Process(process_id)\n            \n            with process.oneshot():\n                metrics = {\n                    \"cpu_percent\": process.cpu_percent(),\n                    \"memory_percent\": process.memory_percent(),\n                    \"memory_rss\": process.memory_info().rss / (1024*1024),  # MB\n                    \"threads\": len(process.threads()),\n                    \"status\": process.status(),\n                    \"running\": process.is_running(),\n                    \"name\": process.name(),\n                    \"command\": \" \".join(process.cmdline()),\n                    \"io\": process.io_counters() if hasattr(process, 'io_counters') else None\n                }\n                \n                # Add additional metrics for non-Windows platforms\n                if os.name != 'nt':\n                    metrics[\"open_files\"] = len(process.open_files())\n                    metrics[\"connections\"] = len(process.connections())\n                    \n                # Cache metrics\n                self.process_metrics[key] = metrics\n                \n                return metrics\n        except Exception as e:\n            # Process may have exited\n            if key in self.monitored_processes and self.monitored_processes[key][\"unregister_on_exit\"]:\n                self.unregister_process_monitor(plugin_id, process_id)\n                \n            return {\n                \"error\": str(e),\n                \"running\": False\n            }\n    \n    def _update_process_metrics(self):\n        \"\"\"Update metrics for all monitored processes\"\"\"\n        for key, info in list(self.monitored_processes.items()):\n            plugin_id = info[\"plugin_id\"]\n            process_id = info[\"process_id\"]\n            \n            # Get updated metrics\n            metrics = self.get_process_metrics(plugin_id, process_id)\n            \n            # Check for process exit\n            if not metrics.get(\"running\", True):\n                if info[\"unregister_on_exit\"]:\n                    self.unregister_process_monitor(plugin_id, process_id)\n                    \n                    # Emit event if event bus is available\n                    if self.event_bus is not None:\n                        event_data = {\n                            \"plugin_id\": plugin_id,\n                            \"process_id\": process_id,\n                            \"name\": info[\"name\"]\n                        }\n                        self.event_bus.publish(\"system.process_exited\", event_data)\n                        \n    def get_thresholds(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"\n        Get current threshold values\n        \n        Returns:\n            Dictionary of threshold values\n        \"\"\"\n        return self.thresholds.copy()\n        \n    def set_threshold(self, metric: str, level: str, value: float) -> bool:\n        \"\"\"\n        Set a threshold value\n        \n        Args:\n            metric: Metric name (cpu, ram, gpu, disk, vram)\n            level: Threshold level (warning, critical)\n            value: Threshold value\n            \n        Returns:\n            True if threshold was set successfully\n        \"\"\"\n        if metric not in self.thresholds:\n            return False\n            \n        if level not in [\"warning\", \"critical\"]:\n            return False\n            \n        if not isinstance(value, (int, float)) or value < 0 or value > 100:\n            return False\n            \n        # Ensure warning is less than critical\n        if level == \"warning\" and value >= self.thresholds[metric][\"critical\"]:\n            return False\n            \n        if level == \"critical\" and value <= self.thresholds[metric][\"warning\"]:\n            return False\n            \n        self.thresholds[metric][level] = value\n        return True\n        \n    def get_all_metrics(self, include_processes: bool = True, \n                       include_custom: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Get all metrics (system, processes, and custom)\n        \n        Args:\n            include_processes: Whether to include process metrics\n            include_custom: Whether to include custom metrics\n            \n        Returns:\n            Dictionary of all metrics\n        \"\"\"\n        # Get system metrics\n        metrics = {\n            \"system\": self.get_system_info()\n        }\n        \n        # Add process metrics\n        if include_processes and self.monitored_processes:\n            process_metrics = {}\n            \n            for key, info in self.monitored_processes.items():\n                plugin_id = info[\"plugin_id\"]\n                process_id = info[\"process_id\"]\n                \n                process_metrics[key] = {\n                    \"info\": info,\n                    \"metrics\": self.get_process_metrics(plugin_id, process_id)\n                }\n                \n            metrics[\"processes\"] = process_metrics\n            \n        # Add custom metrics\n        if include_custom and self.custom_metrics:\n            custom_metrics = {}\n            \n            for key, metric in self.custom_metrics.items():\n                try:\n                    value = metric[\"provider\"]()\n                    last_update = time.time()\n                except Exception as e:\n                    value = metric.get(\"last_value\")\n                    last_update = metric.get(\"last_update\", 0)\n                    \n                custom_metrics[key] = {\n                    \"value\": value,\n                    \"metadata\": metric[\"metadata\"],\n                    \"plugin_id\": metric[\"plugin_id\"],\n                    \"last_update\": last_update\n                }\n                \n            metrics[\"custom\"] = custom_metrics\n            \n        return metrics\n        \n    def export_metrics(self, format: str = \"json\") -> str:\n        \"\"\"\n        Export all metrics to a string\n        \n        Args:\n            format: Export format (json or text)\n            \n        Returns:\n            String representation of metrics\n        \"\"\"\n        metrics = self.get_all_metrics()\n        \n        if format.lower() == \"json\":\n            # Filter out non-serializable values\n            return json.dumps(metrics, default=str, indent=2)\n        else:\n            # Text format\n            lines = [\"=== System Metrics ===\"]\n            \n            # Add system metrics\n            system = metrics[\"system\"]\n            lines.append(f\"CPU: {system['cpu']['usage_percent']}%\")\n            lines.append(f\"RAM: {system['ram']['usage_percent']}% ({system['ram']['used_gb']} GB / {system['ram']['total_gb']} GB)\")\n            lines.append(f\"GPU: {system['gpu']['usage_percent']}\")\n            lines.append(f\"GPU Memory: {system['gpu']['memory']}\")\n            lines.append(f\"Disk: {system['disk']['usage_percent']}% used, {system['disk']['free_gb']} GB free / {system['disk']['total_gb']} GB total\")\n            \n            # Add process metrics\n            if \"processes\" in metrics:\n                lines.append(\"\\n=== Process Metrics ===\")\n                \n                for key, process in metrics[\"processes\"].items():\n                    info = process[\"info\"]\n                    proc_metrics = process[\"metrics\"]\n                    \n                    lines.append(f\"\\n{info['name']} (PID: {info['process_id']}) - Plugin: {info['plugin_id']}\")\n                    if \"error\" in proc_metrics:\n                        lines.append(f\"  Error: {proc_metrics['error']}\")\n                    else:\n                        lines.append(f\"  CPU: {proc_metrics['cpu_percent']}%\")\n                        lines.append(f\"  Memory: {proc_metrics['memory_percent']}% ({proc_metrics['memory_rss']:.1f} MB)\")\n                        lines.append(f\"  Status: {proc_metrics['status']}\")\n                        lines.append(f\"  Threads: {proc_metrics['threads']}\")\n                        \n            # Add custom metrics\n            if \"custom\" in metrics:\n                lines.append(\"\\n=== Custom Metrics ===\")\n                \n                for key, metric in metrics[\"custom\"].items():\n                    metadata = metric[\"metadata\"]\n                    lines.append(f\"\\n{metadata['name']} - Plugin: {metric['plugin_id']}\")\n                    lines.append(f\"  Value: {metric['value']} {metadata['unit']}\")\n                    lines.append(f\"  Description: {metadata['description']}\")\n                    \n            return \"\\n\".join(lines)\n",
  "D:\\AI\\IrintAI Assistant\\memory_system\\memory_pdf_integration.py": "#Memory System PDF Enhancement Integration for IrintAI Assistant\n#This module provides integration between the memory system and enhanced PDF capabilities.\n\nimport os\nfrom typing import Tuple, Dict, Any, Optional, List\nfrom core.memory_system import MemorySystem\nfrom file_operations.pdf_file_ops import PDFFileOps\nfrom file_operations.file_ops import FileOps\n\nclass EnhancedMemoryFileHandler:\n    \"\"\"\n    Enhanced file handler for the memory system with improved PDF handling\n    \"\"\"\n    \n    def __init__(self, memory_system: MemorySystem, file_ops: FileOps, enable_ocr: bool = False, logger=None):\n        \"\"\"\n        Initialize the enhanced memory file handler\n        \n        Args:\n            memory_system: MemorySystem instance\n            file_ops: FileOps instance\n            enable_ocr: Whether to enable OCR for PDF files\n            logger: Optional logger function\n        \"\"\"\n        self.memory_system = memory_system\n        self.file_ops = file_ops\n        self.pdf_ops = PDFFileOps.extend_file_ops(file_ops, enable_ocr=enable_ocr)\n        self.logger = logger or memory_system.log\n        \n    def add_file_to_memory(self, file_path: str) -> bool:\n        \"\"\"\n        Add a file to the memory system with enhanced handling\n        \n        Args:\n            file_path: Path to the file to add\n            \n        Returns:\n            True if file was successfully added to memory, False otherwise\n        \"\"\"\n        # Get file extension\n        file_ext = os.path.splitext(file_path)[1].lower()\n        \n        # Handle PDF files with enhanced extraction\n        if file_ext == '.pdf':\n            return self._add_pdf_to_memory(file_path)\n        else:\n            # Use standard file handling for other file types\n            success, content = self.file_ops.read_file(file_path)\n            if success:\n                return self.memory_system.add_file_to_index(file_path, content)\n            return False\n            \n    def _add_pdf_to_memory(self, pdf_path: str) -> bool:\n        \"\"\"\n        Add a PDF file to memory with enhanced extraction\n        \n        Args:\n            pdf_path: Path to the PDF file\n            \n        Returns:\n            True if PDF was successfully added to memory, False otherwise\n        \"\"\"\n        # Use enhanced PDF extraction\n        success, content = self.pdf_ops.read_pdf(pdf_path)\n        \n        if not success:\n            self.logger(f\"[Memory PDF] Failed to extract text from {pdf_path}\")\n            return False\n            \n        # Get PDF metadata for additional context\n        metadata = self.pdf_ops.get_pdf_metadata(pdf_path)\n        \n        # Add the extracted content to the memory system\n        return self.memory_system.add_file_to_index(pdf_path, content)\n        \n    def add_folder_to_memory(self, folder_path: str, extensions: Optional[List[str]] = None) -> Tuple[int, int]:\n        \"\"\"\n        Add all files in a folder to memory\n        \n        Args:\n            folder_path: Path to the folder\n            extensions: Optional list of file extensions to include\n            \n        Returns:\n            Tuple with (number of files processed, number of files successfully added)\n        \"\"\"\n        # Get default extensions if not provided\n        if extensions is None:\n            extensions = self.file_ops.get_supported_extensions()\n            \n        # Get all matching files\n        all_files = []\n        for ext in extensions:\n            all_files.extend(self.file_ops.get_files_by_type(folder_path, ext))\n            \n        # Process each file\n        processed = 0\n        successful = 0\n        \n        for file_path in all_files:\n            processed += 1\n            if self.add_file_to_memory(file_path):\n                successful += 1\n                \n        return processed, successful\n\ndef enhance_memory_system(memory_system: MemorySystem, file_ops: FileOps, enable_ocr: bool = False) -> EnhancedMemoryFileHandler:\n    \"\"\"\n    Create an enhanced memory file handler with improved PDF capabilities\n\n    Args:\n        memory_system: MemorySystem instance\n        file_ops: FileOps instance\n        enable_ocr: Whether to enable OCR for PDF files\n    \"\"\"\n\n    return EnhancedMemoryFileHandler(memory_system, file_ops, enable_ocr=enable_ocr)\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\model_training_performance\\__init__.py": "# File: plugins/model_training_performance/__init__.py\n\"\"\"\nModel Training Performance Plugin - Entry Point\n\"\"\"\n\n# Import the core plugin class\nfrom plugins.model_training_performance.core.model_training_performance import IrintaiPlugin as CorePlugin\n\n# Define plugin metadata (can be copied or referenced from the core class if static)\nMETADATA = {\n    \"name\": \"Model Training Performance Monitor\",\n    \"description\": \"Monitors and tracks model performance metrics during inference/usage.\",\n    \"version\": \"1.0.0\",\n    \"author\": \"Irintai Project Contributor\", # Placeholder author\n    \"url\": \"https://example.com/plugins/model_monitor\", # Placeholder URL\n    \"compatibility\": \"1.0.0\", # Matches IrintAI Version\n    \"tags\": [\"model\", \"performance\", \"monitoring\", \"resource\"]\n}\n\nclass IrintaiPlugin:\n    \"\"\"Wrapper class for the Model Training Performance Plugin\"\"\"\n    METADATA = METADATA\n\n    def __init__(self, core_system, config_path=None, logger=None, **kwargs):\n        # Pass the plugin ID explicitly or derive it\n        plugin_id = METADATA[\"name\"].lower().replace(\" \", \"_\")\n        self.plugin = CorePlugin(plugin_id, core_system)\n\n    def activate(self):\n        return self.plugin.activate()\n\n    def deactivate(self):\n        return self.plugin.deactivate()",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\memory_diagnostic.py": "\"\"\"\nMemory Diagnostic Module for IrintAI Assistant\n\nThis module provides diagnostics for the memory system including:\n- Memory storage file integrity\n- Chat history access\n- Vector store connectivity\n- Memory database operations\n\"\"\"\nimport os\nimport sys\nimport json\nimport time\nfrom typing import Dict, Any, List\n\n# Add project root to sys.path to allow importing core modules\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nif project_root not in sys.path:\n    sys.path.insert(0, project_root)\n\ntry:\n    from core.config_manager import ConfigManager\n    from core.memory_system import MemorySystem\nexcept ImportError as e:\n    print(f\"Error importing required modules: {e}\")\n    print(\"Please ensure the script is run from the project root or the PYTHONPATH is set correctly.\")\n\nclass MemoryDiagnostic:\n    \"\"\"Diagnostic tool for memory system checks\"\"\"\n    \n    def __init__(self, config_path='data/config.json'):\n        \"\"\"Initialize the memory diagnostic module\"\"\"\n        self.config_path = config_path\n        self.results = {}\n        \n        # Try to initialize config manager\n        try:\n            self.config_manager = ConfigManager(config_path)\n            self.config_loaded = True\n            \n            # Get memory paths\n            self.chat_history_path = self.config_manager.get(\"memory\", {}).get(\"chat_history_path\", \"data/chat_history.json\")\n            if not os.path.isabs(self.chat_history_path):\n                self.chat_history_path = os.path.join(project_root, self.chat_history_path)\n                \n            self.vector_store_path = self.config_manager.get(\"memory\", {}).get(\"vector_store_path\", \"data/vector_store\")\n            if not os.path.isabs(self.vector_store_path):\n                self.vector_store_path = os.path.join(project_root, self.vector_store_path)\n                \n            self.reflections_path = self.config_manager.get(\"memory\", {}).get(\"reflections_path\", \"data/reflections\")\n            if not os.path.isabs(self.reflections_path):\n                self.reflections_path = os.path.join(project_root, self.reflections_path)\n                \n        except Exception as e:\n            self.config_loaded = False\n            # Set default paths\n            self.chat_history_path = os.path.join(project_root, \"data/chat_history.json\")\n            self.vector_store_path = os.path.join(project_root, \"data/vector_store\")\n            self.reflections_path = os.path.join(project_root, \"data/reflections\")\n            print(f\"Error loading configuration: {e}\")\n          # Try to initialize memory system but catch any exceptions\n        try:\n            # Get the model name from config instead of passing the entire config manager\n            model_name = self.config_manager.get(\"memory\", {}).get(\"embedding_model\", \"all-MiniLM-L6-v2\")\n            index_path = os.path.join(self.vector_store_path, \"vector_store.json\")\n            self.memory_system = MemorySystem(model_name=model_name, index_path=index_path)\n            self.memory_system_loaded = True\n        except Exception as e:\n            self.memory_system_loaded = False\n            print(f\"Error initializing memory system: {e}\")\n        \n    def log(self, message):\n        \"\"\"Simple print-based logging for diagnostics\"\"\"\n        print(f\"[MEMORY DIAG] {message}\")\n    \n    def check_chat_history_file(self):\n        \"\"\"Check if the chat history file exists and is valid JSON\"\"\"\n        self.log(f\"Checking chat history file: {self.chat_history_path}\")\n        \n        # Check if file exists\n        if not os.path.exists(self.chat_history_path):\n            # It's okay if chat history doesn't exist yet, just warn\n            self.results['chat_history_file'] = {\n                'status': 'Warning',\n                'message': f\"Chat history file does not exist: {self.chat_history_path}\"\n            }\n            self.log(\"Chat history file does not exist (this might be expected for new installations)\")\n            return True\n            \n        # Check if file is readable\n        if not os.access(self.chat_history_path, os.R_OK):\n            self.results['chat_history_file'] = {\n                'status': 'Failure',\n                'message': f\"Chat history file is not readable: {self.chat_history_path}\"\n            }\n            self.log(\"Chat history file is not readable\")\n            return False\n            \n        # Check if file is valid JSON\n        try:\n            with open(self.chat_history_path, 'r') as f:\n                chat_history = json.load(f)\n                \n            # Check if chat history has the expected structure\n            if not isinstance(chat_history, list):\n                self.results['chat_history_file'] = {\n                    'status': 'Warning',\n                    'message': f\"Chat history file does not contain a valid chat history array\"\n                }\n                self.log(\"Chat history file structure is invalid\")\n                return False\n                \n            self.results['chat_history_file'] = {\n                'status': 'Success',\n                'message': f\"Chat history file is valid with {len(chat_history)} entries\"\n            }\n            self.log(f\"Chat history file is valid with {len(chat_history)} entries\")\n            return True\n                \n        except json.JSONDecodeError as e:\n            self.results['chat_history_file'] = {\n                'status': 'Failure',\n                'message': f\"Chat history file contains invalid JSON: {e}\"\n            }\n            self.log(f\"Chat history file contains invalid JSON: {e}\")\n            return False\n        except Exception as e:\n            self.results['chat_history_file'] = {\n                'status': 'Failure',\n                'message': f\"Error reading chat history file: {e}\"\n            }\n            self.log(f\"Error reading chat history file: {e}\")\n            return False\n    \n    def check_vector_store_directory(self):\n        \"\"\"Check if the vector store directory exists and is accessible\"\"\"\n        self.log(f\"Checking vector store directory: {self.vector_store_path}\")\n        \n        # Check if directory exists\n        if os.path.exists(self.vector_store_path):\n            if os.path.isdir(self.vector_store_path):\n                if os.access(self.vector_store_path, os.R_OK):\n                    # Check if there are any files in the directory\n                    try:\n                        contents = os.listdir(self.vector_store_path)\n                        if contents:\n                            self.results['vector_store_directory'] = {\n                                'status': 'Success',\n                                'message': f\"Vector store directory exists with {len(contents)} items\"\n                            }\n                            self.log(f\"Vector store directory exists with {len(contents)} items\")\n                        else:\n                            # Empty vector store is a warning but not a failure\n                            self.results['vector_store_directory'] = {\n                                'status': 'Warning',\n                                'message': f\"Vector store directory exists but is empty\"\n                            }\n                            self.log(\"Vector store directory is empty\")\n                        return True\n                    except Exception as e:\n                        self.results['vector_store_directory'] = {\n                            'status': 'Warning',\n                            'message': f\"Error reading vector store directory contents: {e}\"\n                        }\n                        self.log(f\"Error reading vector store directory contents: {e}\")\n                        return False\n                else:\n                    self.results['vector_store_directory'] = {\n                        'status': 'Failure',\n                        'message': f\"Vector store directory is not readable: {self.vector_store_path}\"\n                    }\n                    self.log(\"Vector store directory is not readable\")\n                    return False\n            else:\n                self.results['vector_store_directory'] = {\n                    'status': 'Failure',\n                    'message': f\"Vector store path exists but is not a directory: {self.vector_store_path}\"\n                }\n                self.log(\"Vector store path is not a directory\")\n                return False\n        else:\n            # First run might not have a vector store yet\n            self.results['vector_store_directory'] = {\n                'status': 'Warning',\n                'message': f\"Vector store directory does not exist: {self.vector_store_path}\"\n            }\n            self.log(\"Vector store directory does not exist\")\n            return False\n    \n    def check_reflections_directory(self):\n        \"\"\"Check if the reflections directory exists and is accessible\"\"\"\n        self.log(f\"Checking reflections directory: {self.reflections_path}\")\n        \n        # Check if directory exists\n        if os.path.exists(self.reflections_path):\n            if os.path.isdir(self.reflections_path):\n                if os.access(self.reflections_path, os.R_OK):\n                    # Check if there are any files in the directory\n                    try:\n                        contents = os.listdir(self.reflections_path)\n                        self.results['reflections_directory'] = {\n                            'status': 'Success',\n                            'message': f\"Reflections directory exists with {len(contents)} items\"\n                        }\n                        self.log(f\"Reflections directory exists with {len(contents)} items\")\n                        return True\n                    except Exception as e:\n                        self.results['reflections_directory'] = {\n                            'status': 'Warning',\n                            'message': f\"Error reading reflections directory contents: {e}\"\n                        }\n                        self.log(f\"Error reading reflections directory contents: {e}\")\n                        return False\n                else:\n                    self.results['reflections_directory'] = {\n                        'status': 'Failure',\n                        'message': f\"Reflections directory is not readable: {self.reflections_path}\"\n                    }\n                    self.log(\"Reflections directory is not readable\")\n                    return False\n            else:\n                self.results['reflections_directory'] = {\n                    'status': 'Failure',\n                    'message': f\"Reflections path exists but is not a directory: {self.reflections_path}\"\n                }\n                self.log(\"Reflections path is not a directory\")\n                return False\n        else:\n            # No reflections yet is acceptable\n            self.results['reflections_directory'] = {\n                'status': 'Warning',\n                'message': f\"Reflections directory does not exist: {self.reflections_path}\"\n            }\n            self.log(\"Reflections directory does not exist\")\n            return False\n    \n    def check_memory_system_init(self):\n        \"\"\"Check if the memory system can be initialized\"\"\"\n        self.log(\"Checking memory system initialization...\")\n        \n        if not self.config_loaded:\n            self.results['memory_system_init'] = {\n                'status': 'Skipped',\n                'message': 'Configuration manager not initialized'\n            }\n            self.log(\"Skipping memory system check - config not loaded\")\n            return False\n            \n        if self.memory_system_loaded:\n            self.results['memory_system_init'] = {\n                'status': 'Success',\n                'message': 'Memory system initialized successfully'\n            }\n            self.log(\"Memory system initialized successfully\")\n            return True\n        else:\n            self.results['memory_system_init'] = {\n                'status': 'Failure',\n                'message': 'Failed to initialize memory system'\n            }\n            self.log(\"Memory system initialization failed\")\n            return False\n    \n    def check_memory_operations(self):\n        \"\"\"Check basic memory operations if memory system is initialized\"\"\"\n        if not self.memory_system_loaded:\n            self.results['memory_operations'] = {\n                'status': 'Skipped',\n                'message': 'Memory system not initialized'\n            }\n            self.log(\"Skipping memory operations check - memory system not initialized\")\n            return False\n            \n        self.log(\"Checking basic memory operations...\")\n        \n        operations_results = {}\n        failures = 0\n        \n        # Check if we can access chat history\n        try:\n            # Use a safe method to test memory access\n            if hasattr(self.memory_system, 'get_chat_history'):\n                chat_history = self.memory_system.get_chat_history(limit=1)\n                operations_results['get_chat_history'] = {\n                    'status': 'Success',\n                    'message': f\"Successfully retrieved chat history\"\n                }\n            else:\n                operations_results['get_chat_history'] = {\n                    'status': 'Skipped',\n                    'message': \"Memory system does not expose get_chat_history method\"\n                }\n        except Exception as e:\n            failures += 1\n            operations_results['get_chat_history'] = {\n                'status': 'Failure',\n                'message': f\"Error retrieving chat history: {e}\"\n            }\n            self.log(f\"Error retrieving chat history: {e}\")\n\n        # Skip vector operations if they're likely to modify data\n        # Instead check if vector store exists and is accessible\n        \n        # Determine overall status\n        if failures == 0:\n            self.results['memory_operations'] = {\n                'status': 'Success',\n                'message': 'All memory operations completed successfully',\n                'details': operations_results\n            }\n            self.log(\"All memory operations completed successfully\")\n            return True\n        else:\n            self.results['memory_operations'] = {\n                'status': 'Failure',\n                'message': f\"{failures} memory operations failed\",\n                'details': operations_results\n            }\n            self.log(f\"{failures} memory operations failed\")\n            return False\n    \n    def check_memory_permissions(self):\n        \"\"\"Check write permissions for memory-related directories and files\"\"\"\n        self.log(\"Checking memory system write permissions...\")\n        \n        permission_results = {}\n        permission_failures = 0\n        \n        # Check chat history file or its parent directory if it doesn't exist\n        chat_history_dir = os.path.dirname(self.chat_history_path)\n        if os.path.exists(self.chat_history_path):\n            chat_history_writable = os.access(self.chat_history_path, os.W_OK)\n        else:\n            # Check if we can create the file\n            chat_history_writable = os.path.exists(chat_history_dir) and os.access(chat_history_dir, os.W_OK)\n            \n        permission_results['chat_history'] = {\n            'status': 'Success' if chat_history_writable else 'Failure',\n            'message': f\"Chat history {'is' if chat_history_writable else 'is not'} writable\"\n        }\n        \n        if not chat_history_writable:\n            permission_failures += 1\n        \n        # Check vector store directory\n        if os.path.exists(self.vector_store_path):\n            vector_store_writable = os.path.isdir(self.vector_store_path) and os.access(self.vector_store_path, os.W_OK)\n        else:\n            # Check if we can create the directory\n            vector_store_parent = os.path.dirname(self.vector_store_path)\n            vector_store_writable = os.path.exists(vector_store_parent) and os.access(vector_store_parent, os.W_OK)\n            \n        permission_results['vector_store'] = {\n            'status': 'Success' if vector_store_writable else 'Failure',\n            'message': f\"Vector store {'is' if vector_store_writable else 'is not'} writable\"\n        }\n        \n        if not vector_store_writable:\n            permission_failures += 1\n        \n        # Check reflections directory\n        if os.path.exists(self.reflections_path):\n            reflections_writable = os.path.isdir(self.reflections_path) and os.access(self.reflections_path, os.W_OK)\n        else:\n            # Check if we can create the directory\n            reflections_parent = os.path.dirname(self.reflections_path)\n            reflections_writable = os.path.exists(reflections_parent) and os.access(reflections_parent, os.W_OK)\n            \n        permission_results['reflections'] = {\n            'status': 'Success' if reflections_writable else 'Failure',\n            'message': f\"Reflections directory {'is' if reflections_writable else 'is not'} writable\"\n        }\n        \n        if not reflections_writable:\n            permission_failures += 1\n        \n        # Determine overall status\n        if permission_failures == 0:\n            self.results['memory_permissions'] = {\n                'status': 'Success',\n                'message': 'All memory locations have write permissions',\n                'details': permission_results\n            }\n            self.log(\"All memory locations have write permissions\")\n            return True\n        else:\n            self.results['memory_permissions'] = {\n                'status': 'Failure',\n                'message': f\"{permission_failures} memory locations have permission issues\",\n                'details': permission_results\n            }\n            self.log(f\"{permission_failures} memory locations have permission issues\")\n            return False\n    \n    def run_all_checks(self):\n        \"\"\"Run all memory diagnostic checks\"\"\"\n        self.log(\"Starting memory diagnostics...\")\n        start_time = time.time()\n        \n        # Run checks\n        self.check_chat_history_file()\n        self.check_vector_store_directory()\n        self.check_reflections_directory()\n        self.check_memory_system_init()\n        self.check_memory_operations()\n        self.check_memory_permissions()\n        \n        elapsed_time = time.time() - start_time\n        self.log(f\"Memory diagnostics completed in {elapsed_time:.2f} seconds\")\n        return self.results\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\personality_plugin\\ui\\panel.py": "# UI hooks for personality plugin panel\n\"\"\"\nUI Components for the Personality Plugin\n\"\"\"\nimport time\nimport tkinter as tk\nfrom tkinter import ttk, messagebox, scrolledtext\nfrom typing import Dict, List, Any, Optional\n\n# Import the core plugin\nfrom plugins.personality_plugin.core.personality_plugin import PersonalityPlugin\n\nclass Panel:\n    \"\"\"UI panel for the Personality Plugin\"\"\"\n    \n    def __init__(self, parent: tk.Widget, plugin: PersonalityPlugin):\n        \"\"\"\n        Initialize the UI panel\n        \n        Args:\n            parent: Parent widget\n            plugin: Reference to the core plugin instance\n        \"\"\"\n        self.parent = parent\n        self.plugin = plugin\n        \n        # UI state\n        self.ui_panel = None\n        self.profiles_listbox = None\n        self.details_content = None\n        self.detail_fields = {}\n        self.style_sliders = {}\n        self.special_rules_vars = {}\n        \n        # Create panel\n        self.create_panel()\n    \n    def create_panel(self) -> ttk.Frame:\n        \"\"\"\n        Create the UI panel\n        \n        Returns:\n            UI panel frame\n        \"\"\"\n        # Create main frame\n        self.ui_panel = ttk.Frame(self.parent)\n        \n        # Create title and description\n        title_frame = ttk.Frame(self.ui_panel)\n        title_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Label(\n            title_frame, \n            text=\"Personality Profiles\",\n            font=(\"Helvetica\", 12, \"bold\")\n        ).pack(side=tk.LEFT)\n        \n        # Create main content section\n        content_frame = ttk.Frame(self.ui_panel)\n        content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n        \n        # Split into left (profiles list) and right (profile details) panes\n        paned_window = ttk.PanedWindow(content_frame, orient=tk.HORIZONTAL)\n        paned_window.pack(fill=tk.BOTH, expand=True)\n        \n        # Profiles list on the left\n        profiles_frame = ttk.LabelFrame(paned_window, text=\"Available Profiles\")\n        paned_window.add(profiles_frame, weight=1)\n        \n        # Create profiles listbox with scrollbar\n        profiles_frame_inner = ttk.Frame(profiles_frame)\n        profiles_frame_inner.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        self.profiles_listbox = tk.Listbox(\n            profiles_frame_inner,\n            height=10,\n            exportselection=0\n        )\n        self.profiles_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        profiles_scrollbar = ttk.Scrollbar(\n            profiles_frame_inner,\n            orient=tk.VERTICAL,\n            command=self.profiles_listbox.yview\n        )\n        profiles_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.profiles_listbox.config(yscrollcommand=profiles_scrollbar.set)\n        \n        # Profile controls\n        profiles_controls = ttk.Frame(profiles_frame)\n        profiles_controls.pack(fill=tk.X, padx=5, pady=5)\n        \n        ttk.Button(\n            profiles_controls,\n            text=\"Activate\",\n            command=self._ui_activate_profile\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Button(\n            profiles_controls,\n            text=\"New\",\n            command=self._ui_create_profile\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Button(\n            profiles_controls,\n            text=\"Edit\",\n            command=self._ui_edit_profile\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Button(\n            profiles_controls,\n            text=\"Delete\",\n            command=self._ui_delete_profile\n        ).pack(side=tk.LEFT, padx=2)\n        \n        # Profile details on the right\n        details_frame = ttk.LabelFrame(paned_window, text=\"Profile Details\")\n        paned_window.add(details_frame, weight=2)\n        \n        # Create scrollable details view\n        details_canvas = tk.Canvas(details_frame)\n        details_scrollbar = ttk.Scrollbar(\n            details_frame,\n            orient=tk.VERTICAL,\n            command=details_canvas.yview\n        )\n        details_canvas.configure(yscrollcommand=details_scrollbar.set)\n        \n        details_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        details_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        self.details_content = ttk.Frame(details_canvas)\n        details_canvas.create_window((0, 0), window=self.details_content, anchor=tk.NW)\n        \n        # Configure canvas to resize with content\n        def _configure_details_canvas(event):\n            details_canvas.configure(scrollregion=details_canvas.bbox(\"all\"))\n        \n        self.details_content.bind(\"<Configure>\", _configure_details_canvas)\n        \n        # Create profile detail widgets\n        self._create_profile_details_widgets()\n        \n        # Populate the profiles list\n        self._ui_refresh_profiles_list()\n        \n        return self.ui_panel\n\n    def _create_profile_details_widgets(self):\n        \"\"\"\n        Create widgets for displaying profile details\n        \"\"\"\n        # Create frames for different sections\n        basic_info_frame = ttk.LabelFrame(self.details_content, text=\"Basic Information\")\n        basic_info_frame.pack(fill=tk.X, padx=5, pady=5, anchor=tk.N)\n        \n        style_frame = ttk.LabelFrame(self.details_content, text=\"Style Modifiers\")\n        style_frame.pack(fill=tk.X, padx=5, pady=5, anchor=tk.N)\n        \n        formatting_frame = ttk.LabelFrame(self.details_content, text=\"Formatting Options\")\n        formatting_frame.pack(fill=tk.X, padx=5, pady=5, anchor=tk.N)\n        \n        # Basic information fields\n        basic_fields = [\n            (\"name\", \"Name\", 30),\n            (\"description\", \"Description\", 50),\n            (\"tags\", \"Tags\", 30),\n            (\"author\", \"Author\", 20),\n            (\"version\", \"Version\", 10),\n        ]\n        \n        for i, (field_id, label_text, width) in enumerate(basic_fields):\n            field_frame = ttk.Frame(basic_info_frame)\n            field_frame.pack(fill=tk.X, padx=5, pady=2)\n            \n            ttk.Label(field_frame, text=f\"{label_text}:\", width=10).pack(side=tk.LEFT)\n            \n            # Use Entry for most fields, Text for description\n            if field_id == \"description\":\n                var = tk.StringVar()\n                entry = ttk.Entry(field_frame, width=width, textvariable=var)\n                entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n                self.detail_fields[field_id] = var\n            else:\n                var = tk.StringVar()\n                entry = ttk.Entry(field_frame, width=width, textvariable=var)\n                entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n                self.detail_fields[field_id] = var\n        \n        # Prefix/suffix fields\n        adv_fields = [\n            (\"prefix\", \"Prefix:\", 50),\n            (\"suffix\", \"Suffix:\", 50),\n        ]\n        \n        for field_id, label_text, width in adv_fields:\n            field_frame = ttk.Frame(basic_info_frame)\n            field_frame.pack(fill=tk.X, padx=5, pady=2)\n            \n            ttk.Label(field_frame, text=label_text, width=10).pack(side=tk.LEFT)\n            \n            var = tk.StringVar()\n            entry = ttk.Entry(field_frame, width=width, textvariable=var)\n            entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n            self.detail_fields[field_id] = var\n        \n        # Style modifier sliders\n        style_grid = ttk.Frame(style_frame)\n        style_grid.pack(fill=tk.BOTH, padx=5, pady=5, expand=True)\n        \n        style_modifiers = [\n            (\"formality\", \"Formal\", \"Casual\"),\n            (\"creativity\", \"Creative\", \"Factual\"),\n            (\"complexity\", \"Complex\", \"Simple\"),\n            (\"empathy\", \"Empathetic\", \"Objective\"),\n            (\"directness\", \"Direct\", \"Diplomatic\"),\n            (\"humor\", \"Humorous\", \"Serious\"),\n            (\"enthusiasm\", \"Enthusiastic\", \"Reserved\"),\n            (\"conciseness\", \"Concise\", \"Detailed\")\n        ]\n        \n        # Create grid layout\n        for i, (mod_id, left_label, right_label) in enumerate(style_modifiers):\n            row = i // 2\n            col = (i % 2) * 3\n            \n            # Left label\n            ttk.Label(style_grid, text=left_label).grid(row=row, column=col, padx=5, pady=2, sticky=tk.E)\n            \n            # Slider\n            var = tk.DoubleVar(value=0.5)\n            slider = ttk.Scale(\n                style_grid,\n                from_=0.0,\n                to=1.0,\n                orient=tk.HORIZONTAL,\n                length=100,\n                variable=var\n            )\n            slider.grid(row=row, column=col+1, padx=5, pady=2)\n            self.style_sliders[mod_id] = var\n            \n            # Right label\n            ttk.Label(style_grid, text=right_label).grid(row=row, column=col+2, padx=5, pady=2, sticky=tk.W)\n        \n        # Formatting options\n        formatting_options = [\n            (\"emphasize_key_points\", \"Emphasize key points\"),\n            (\"use_markdown\", \"Use Markdown formatting\"),\n        ]\n        \n        for i, (option_id, label) in enumerate(formatting_options):\n            var = tk.BooleanVar(value=False)\n            checkbox = ttk.Checkbutton(\n                formatting_frame,\n                text=label,\n                variable=var\n            )\n            checkbox.pack(anchor=tk.W, padx=5, pady=2)\n            self.special_rules_vars[option_id] = var\n        \n        # Paragraph structure option\n        para_frame = ttk.Frame(formatting_frame)\n        para_frame.pack(fill=tk.X, padx=5, pady=2)\n        \n        ttk.Label(para_frame, text=\"Paragraph structure:\").pack(side=tk.LEFT, padx=5)\n        \n        para_var = tk.StringVar(value=\"standard\")\n        para_combo = ttk.Combobox(\n            para_frame,\n            textvariable=para_var,\n            values=[\"standard\", \"concise\", \"detailed\", \"academic\"]\n        )\n        para_combo.pack(side=tk.LEFT, padx=5)\n        self.special_rules_vars[\"paragraph_structure\"] = para_var\n        \n        # Add handlers\n        self.profiles_listbox.bind('<<ListboxSelect>>', self._ui_on_profile_selected)\n\n    def _ui_refresh_profiles_list(self) -> None:\n        \"\"\"\n        Refresh the profiles listbox\n        \"\"\"\n        # Clear existing items\n        self.profiles_listbox.delete(0, tk.END)\n        \n        # Get profiles from the plugin\n        profiles = self.plugin.get_available_profiles()\n        active_profile = self.plugin.get_active_profile_name()\n        \n        # Add to listbox\n        for i, name in enumerate(sorted(profiles)):\n            display_name = name\n            if name == active_profile:\n                display_name = f\"* {name} (Active)\"\n            \n            self.profiles_listbox.insert(tk.END, display_name)\n            \n            # Select active profile\n            if name == active_profile:\n                self.profiles_listbox.selection_set(i)\n                self.profiles_listbox.see(i)\n    \n    def _ui_on_profile_selected(self, event) -> None:\n        \"\"\"\n        Handle profile selection in the listbox\n        \"\"\"\n        selection = self.profiles_listbox.curselection()\n        if not selection:\n            return\n        \n        # Get profile name (remove active marker if present)\n        display_name = self.profiles_listbox.get(selection[0])\n        if display_name.startswith(\"* \"):\n            profile_name = display_name[2:].split(\" (Active)\")[0]\n        else:\n            profile_name = display_name\n        \n        # Get profile data from plugin\n        profile = self.plugin.get_profile(profile_name)\n        if not profile:\n            return\n        \n        # Update detail fields\n        for field_id, var in self.detail_fields.items():\n            value = profile.get(field_id, \"\")\n            if field_id == \"tags\" and isinstance(value, list):\n                value = \", \".join(value)\n            var.set(value)\n        \n        # Update style sliders\n        style_modifiers = profile.get(\"style_modifiers\", {})\n        for slider_id, var in self.style_sliders.items():\n            var.set(style_modifiers.get(slider_id, 0.5))\n        \n        # Update special rules\n        special_rules = profile.get(\"special_rules\", {})\n        for rule_id, var in self.special_rules_vars.items():\n            var.set(special_rules.get(rule_id, False))\n\n    def _ui_activate_profile(self) -> None:\n        \"\"\"\n        Activate the selected profile\n        \"\"\"\n        selection = self.profiles_listbox.curselection()\n        if not selection:\n            messagebox.showwarning(\"No Selection\", \"Please select a profile to activate\")\n            return\n        \n        # Get profile name\n        display_name = self.profiles_listbox.get(selection[0])\n        if display_name.startswith(\"* \"):\n            profile_name = display_name[2:].split(\" (Active)\")[0]\n        else:\n            profile_name = display_name\n        \n        # Activate using plugin method\n        success = self.plugin.set_active_profile(profile_name)\n        \n        if success:\n            messagebox.showinfo(\"Profile Activated\", f\"Profile '{profile_name}' is now active\")\n            self._ui_refresh_profiles_list()\n        else:\n            messagebox.showerror(\"Activation Failed\", f\"Failed to activate profile '{profile_name}'\")\n    \n    def _ui_create_profile(self) -> None:\n        \"\"\"\n        Create a new profile\n        \"\"\"\n        # Show dialog for creating new profile\n        dialog = tk.Toplevel(self.ui_panel)\n        dialog.title(\"Create New Profile\")\n        dialog.transient(self.ui_panel)\n        dialog.grab_set()\n        \n        # Create form for basic profile info\n        frame = ttk.Frame(dialog, padding=10)\n        frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Name field\n        name_frame = ttk.Frame(frame)\n        name_frame.pack(fill=tk.X, pady=5)\n        \n        ttk.Label(name_frame, text=\"Name:\", width=10).pack(side=tk.LEFT)\n        name_var = tk.StringVar()\n        name_entry = ttk.Entry(name_frame, width=30, textvariable=name_var)\n        name_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n        \n        # Description field\n        desc_frame = ttk.Frame(frame)\n        desc_frame.pack(fill=tk.X, pady=5)\n        \n        ttk.Label(desc_frame, text=\"Description:\", width=10).pack(side=tk.LEFT)\n        desc_var = tk.StringVar()\n        desc_entry = ttk.Entry(desc_frame, width=40, textvariable=desc_var)\n        desc_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n        \n        # Template selection\n        template_frame = ttk.Frame(frame)\n        template_frame.pack(fill=tk.X, pady=5)\n        \n        ttk.Label(template_frame, text=\"Template:\").pack(side=tk.LEFT, padx=5)\n        \n        templates = [\"Empty\", \"Standard\", \"Formal\", \"Casual\", \"Technical\", \"Creative\"]\n        template_var = tk.StringVar(value=\"Empty\")\n        template_combo = ttk.Combobox(\n            template_frame,\n            textvariable=template_var,\n            values=templates\n        )\n        template_combo.pack(side=tk.LEFT, padx=5)\n        \n        # Description \n        ttk.Label(\n            frame,\n            text=\"You can edit all profile details after creating it.\",\n            font=(\"Helvetica\", 9, \"italic\")\n        ).pack(pady=10)\n        \n        # Buttons\n        button_frame = ttk.Frame(frame)\n        button_frame.pack(fill=tk.X, pady=10)\n        \n        def on_create():\n            name = name_var.get().strip()\n            description = desc_var.get().strip()\n            template = template_var.get()\n            \n            if not name:\n                messagebox.showwarning(\"Missing Name\", \"Please enter a profile name\")\n                return\n                \n            if name in self.plugin.get_available_profiles():\n                messagebox.showerror(\"Name Exists\", f\"A profile named '{name}' already exists\")\n                return\n            \n            # Create profile\n            if template == \"Empty\":\n                # Create empty profile\n                from plugins.personality_plugin.core import create_empty_profile\n                profile_data = create_empty_profile(name)\n                profile_data[\"description\"] = description\n            else:\n                # Use selected template\n                template_profile = self.plugin.get_profile(template) \n                if not template_profile:\n                    # Fallback to empty profile\n                    from plugins.personality_plugin.core import create_empty_profile\n                    profile_data = create_empty_profile(name)\n                else:\n                    # Clone template\n                    profile_data = template_profile.copy()\n                    profile_data[\"name\"] = name\n                    \n                profile_data[\"description\"] = description\n            \n            # Create new profile\n            success = self.plugin.create_profile(profile_data)\n            \n            if success:\n                messagebox.showinfo(\"Profile Created\", f\"Profile '{name}' created successfully\")\n                dialog.destroy()\n                self._ui_refresh_profiles_list()\n                \n                # Select the new profile\n                profiles = sorted(self.plugin.get_available_profiles())\n                try:\n                    idx = profiles.index(name)\n                    self.profiles_listbox.selection_set(idx)\n                    self.profiles_listbox.see(idx)\n                    self._ui_on_profile_selected(None)\n                except ValueError:\n                    pass\n            else:\n                messagebox.showerror(\"Creation Failed\", f\"Failed to create profile '{name}'\")\n        \n        ttk.Button(button_frame, text=\"Create\", command=on_create).pack(side=tk.RIGHT, padx=5)\n        ttk.Button(button_frame, text=\"Cancel\", command=dialog.destroy).pack(side=tk.RIGHT, padx=5)\n        \n        # Center dialog and focus name field\n        dialog.update_idletasks()\n        dialog.geometry(f\"400x250+{dialog.winfo_screenwidth()//2-200}+{dialog.winfo_screenheight()//2-125}\")\n        name_entry.focus_set()\n\n    def _ui_edit_profile(self) -> None:\n        \"\"\"\n        Edit the selected profile\n        \"\"\"\n        selection = self.profiles_listbox.curselection()\n        if not selection:\n            messagebox.showwarning(\"No Selection\", \"Please select a profile to edit\")\n            return\n        \n        # Get profile name\n        display_name = self.profiles_listbox.get(selection[0])\n        if display_name.startswith(\"* \"):\n            profile_name = display_name[2:].split(\" (Active)\")[0]\n        else:\n            profile_name = display_name\n            \n        # Get current profile data\n        profile = self.plugin.get_profile(profile_name)\n        if not profile:\n            messagebox.showerror(\"Profile Not Found\", f\"Profile '{profile_name}' not found\")\n            return\n        \n        # Create dialog for editing\n        dialog = tk.Toplevel(self.ui_panel)\n        dialog.title(f\"Edit Profile: {profile_name}\")\n        dialog.transient(self.ui_panel)\n        dialog.grab_set()\n        \n        # Use notebook for tabs\n        import tkinter.ttk as ttk\n        notebook = ttk.Notebook(dialog)\n        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Basic info tab\n        basic_tab = ttk.Frame(notebook)\n        notebook.add(basic_tab, text=\"Basic Info\")\n        \n        # Style tab\n        style_tab = ttk.Frame(notebook)\n        notebook.add(style_tab, text=\"Style\")\n        \n        # Formatting tab\n        format_tab = ttk.Frame(notebook)\n        notebook.add(format_tab, text=\"Formatting\")\n        \n        # --- Basic info tab ---\n        basic_fields = [\n            (\"name\", \"Name:\", profile.get(\"name\", \"\")),\n            (\"description\", \"Description:\", profile.get(\"description\", \"\")),\n            (\"tags\", \"Tags:\", \", \".join(profile.get(\"tags\", []))),\n            (\"author\", \"Author:\", profile.get(\"author\", \"\")),\n            (\"version\", \"Version:\", profile.get(\"version\", \"1.0.0\")),\n        ]\n        \n        basic_vars = {}\n        for i, (field_id, label_text, value) in enumerate(basic_fields):\n            field_frame = ttk.Frame(basic_tab)\n            field_frame.pack(fill=tk.X, padx=10, pady=5)\n            \n            ttk.Label(field_frame, text=label_text, width=12).pack(side=tk.LEFT)\n            \n            var = tk.StringVar(value=value)\n            basic_vars[field_id] = var\n            \n            if field_id == \"description\":\n                entry = ttk.Entry(field_frame, width=50, textvariable=var)\n            else:\n                entry = ttk.Entry(field_frame, width=30, textvariable=var)\n            entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n        \n        # Prefix/suffix\n        prefix_frame = ttk.Frame(basic_tab)\n        prefix_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Label(prefix_frame, text=\"Prefix:\", width=12).pack(side=tk.LEFT)\n        prefix_var = tk.StringVar(value=profile.get(\"prefix\", \"\"))\n        basic_vars[\"prefix\"] = prefix_var\n        ttk.Entry(prefix_frame, width=50, textvariable=prefix_var).pack(side=tk.LEFT, fill=tk.X, expand=True)\n        \n        suffix_frame = ttk.Frame(basic_tab)\n        suffix_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        ttk.Label(suffix_frame, text=\"Suffix:\", width=12).pack(side=tk.LEFT)\n        suffix_var = tk.StringVar(value=profile.get(\"suffix\", \"\"))\n        basic_vars[\"suffix\"] = suffix_var\n        ttk.Entry(suffix_frame, width=50, textvariable=suffix_var).pack(side=tk.LEFT, fill=tk.X, expand=True)\n        \n        # --- Style tab ---\n        style_vars = {}\n        style_modifiers = profile.get(\"style_modifiers\", {})\n        \n        style_pairs = [\n            (\"formality\", \"Formal\", \"Casual\"),\n            (\"creativity\", \"Creative\", \"Factual\"),\n            (\"complexity\", \"Complex\", \"Simple\"),\n            (\"empathy\", \"Empathetic\", \"Objective\"),\n            (\"directness\", \"Direct\", \"Diplomatic\"),\n            (\"humor\", \"Humorous\", \"Serious\"),\n            (\"enthusiasm\", \"Enthusiastic\", \"Reserved\"),\n            (\"conciseness\", \"Concise\", \"Detailed\")\n        ]\n        \n        # Create sliders in a grid\n        for i, (mod_id, left_label, right_label) in enumerate(style_pairs):\n            row = i // 2\n            col = (i % 2) * 3\n            \n            # Left label\n            ttk.Label(style_tab, text=left_label).grid(row=row, column=col, padx=5, pady=10, sticky=tk.E)\n            \n            # Slider\n            var = tk.DoubleVar(value=style_modifiers.get(mod_id, 0.5))\n            style_vars[mod_id] = var\n            \n            slider = ttk.Scale(\n                style_tab,\n                from_=0.0,\n                to=1.0,\n                orient=tk.HORIZONTAL,\n                length=100,\n                variable=var\n            )\n            slider.grid(row=row, column=col+1, padx=5, pady=10)\n            \n            # Right label\n            ttk.Label(style_tab, text=right_label).grid(row=row, column=col+2, padx=5, pady=10, sticky=tk.W)\n        \n        # --- Formatting tab ---\n        format_vars = {}\n        formatting = profile.get(\"formatting\", {})\n        \n        # Checkboxes for boolean options\n        format_bools = [\n            (\"emphasize_key_points\", \"Emphasize key points\", \n             formatting.get(\"emphasize_key_points\", False)),\n            (\"use_markdown\", \"Use Markdown formatting\", \n             formatting.get(\"use_markdown\", True)),\n        ]\n        \n        for i, (option_id, label, value) in enumerate(format_bools):\n            var = tk.BooleanVar(value=value)\n            format_vars[option_id] = var\n            \n            checkbox = ttk.Checkbutton(\n                format_tab,\n                text=label,\n                variable=var\n            )\n            checkbox.pack(anchor=tk.W, padx=10, pady=5)\n        \n        # Paragraph structure dropdown\n        para_frame = ttk.Frame(format_tab)\n        para_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        ttk.Label(para_frame, text=\"Paragraph structure:\").pack(side=tk.LEFT, padx=5)\n        \n        para_var = tk.StringVar(value=formatting.get(\"paragraph_structure\", \"standard\"))\n        format_vars[\"paragraph_structure\"] = para_var\n        \n        para_combo = ttk.Combobox(\n            para_frame,\n            textvariable=para_var,\n            values=[\"standard\", \"concise\", \"detailed\", \"academic\"]\n        )\n        para_combo.pack(side=tk.LEFT, padx=5)\n        \n        # --- Buttons at bottom ---\n        button_frame = ttk.Frame(dialog)\n        button_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        def on_save():\n            # Collect values\n            updated_profile = profile.copy()\n            \n            # Update basic fields\n            for field_id, var in basic_vars.items():\n                if field_id == \"tags\":\n                    # Convert comma-separated string to list\n                    tags_str = var.get().strip()\n                    if tags_str:\n                        updated_profile[\"tags\"] = [t.strip() for t in tags_str.split(\",\")]\n                    else:\n                        updated_profile[\"tags\"] = []\n                else:\n                    updated_profile[field_id] = var.get()\n            \n            # Update style modifiers\n            style_mods = updated_profile.get(\"style_modifiers\", {})\n            for mod_id, var in style_vars.items():\n                style_mods[mod_id] = var.get()\n            updated_profile[\"style_modifiers\"] = style_mods\n            \n            # Update formatting\n            format_opts = updated_profile.get(\"formatting\", {})\n            for opt_id, var in format_vars.items():\n                format_opts[opt_id] = var.get()\n            updated_profile[\"formatting\"] = format_opts\n            \n            # Save profile\n            success = self.plugin.update_profile(profile_name, updated_profile)\n            \n            if success:\n                messagebox.showinfo(\"Profile Updated\", f\"Profile '{profile_name}' updated successfully\")\n                dialog.destroy()\n                self._ui_refresh_profiles_list()\n            else:\n                messagebox.showerror(\"Update Failed\", f\"Failed to update profile '{profile_name}'\")\n        \n        ttk.Button(button_frame, text=\"Save\", command=on_save).pack(side=tk.RIGHT, padx=5)\n        ttk.Button(button_frame, text=\"Cancel\", command=dialog.destroy).pack(side=tk.RIGHT, padx=5)\n        \n        # Center dialog\n        dialog.update_idletasks()\n        dialog.geometry(f\"600x400+{dialog.winfo_screenwidth()//2-300}+{dialog.winfo_screenheight()//2-200}\")\n\n    def _ui_duplicate_profile(self) -> None:\n        \"\"\"\n        Duplicate the selected profile\n        \"\"\"\n        selection = self.profiles_listbox.curselection()\n        if not selection:\n            messagebox.showwarning(\"No Selection\", \"Please select a profile to duplicate\")\n            return\n        \n        # Get profile name (remove active marker if present)\n        display_name = self.profiles_listbox.get(selection[0])\n        if display_name.startswith(\"* \"):\n            profile_name = display_name[2:].split(\" (Active)\")[0]\n        else:\n            profile_name = display_name\n        \n        # Show input dialog for new name\n        new_name = tk.simpledialog.askstring(\n            \"Duplicate Profile\",\n            f\"Enter a name for the duplicate of '{profile_name}':\",\n            parent=self.ui_panel\n        )\n        \n        if not new_name:\n            return\n        \n        # Duplicate the profile\n        success = self.duplicate_profile(profile_name, new_name)\n        \n        if success:\n            messagebox.showinfo(\"Profile Duplicated\", f\"Profile '{profile_name}' duplicated to '{new_name}'\")\n            self._ui_refresh_profiles_list()\n        else:\n            messagebox.showerror(\"Duplication Failed\", f\"Failed to duplicate profile '{profile_name}'\")\n    \n    def _ui_delete_profile(self) -> None:\n        \"\"\"\n        Delete the selected profile\n        \"\"\"\n        selection = self.profiles_listbox.curselection()\n        if not selection:\n            messagebox.showwarning(\"No Selection\", \"Please select a profile to delete\")\n            return\n        \n        # Get profile name\n        display_name = self.profiles_listbox.get(selection[0])\n        if display_name.startswith(\"* \"):\n            profile_name = display_name[2:].split(\" (Active)\")[0]\n        else:\n            profile_name = display_name\n        \n        # Check if this is the active profile\n        active_profile = self.plugin.get_active_profile_name()\n        if profile_name == active_profile:\n            messagebox.showerror(\n                \"Cannot Delete\", \n                f\"Cannot delete the active profile. Please activate a different profile first.\"\n            )\n            return\n        \n        # Confirm deletion\n        confirm = messagebox.askyesno(\n            \"Confirm Delete\", \n            f\"Are you sure you want to delete the profile '{profile_name}'?\\nThis cannot be undone.\",\n            icon=messagebox.WARNING\n        )\n        \n        if not confirm:\n            return\n        \n        # Delete the profile\n        success = self.plugin.delete_profile(profile_name)\n        \n        if success:\n            messagebox.showinfo(\"Profile Deleted\", f\"Profile '{profile_name}' has been deleted\")\n            self._ui_refresh_profiles_list()\n        else:\n            messagebox.showerror(\"Delete Failed\", f\"Failed to delete profile '{profile_name}'\")\n    \n    def _ui_import_profile(self) -> None:\n        \"\"\"\n        Import a profile from JSON or file\n        \"\"\"\n        # Ask user if they want to import from file or paste JSON\n        import_options = [\"Import from file\", \"Paste JSON\"]\n        choice = messagebox.askquestion(\n            \"Import Method\",\n            \"Do you want to import from a file?\",\n            type=messagebox.YESNOCANCEL\n        )\n        \n        if choice == \"yes\":\n            # Import from file\n            from tkinter import filedialog\n            file_path = filedialog.askopenfilename(\n                title=\"Select Profile File\",\n                filetypes=[(\"JSON Files\", \"*.json\"), (\"All Files\", \"*.*\")]\n            )\n            \n            if not file_path:\n                return\n                \n            # Use plugin's import method\n            success = self.plugin.import_profile_from_file(file_path)\n            \n            if success:\n                messagebox.showinfo(\"Profile Imported\", f\"Profile imported successfully from {file_path}\")\n                self._ui_refresh_profiles_list()\n            else:\n                messagebox.showerror(\"Import Failed\", f\"Failed to import profile from {file_path}\")\n                \n        elif choice == \"no\":\n            # Import from pasted JSON\n            # Show dialog for JSON input\n            dialog = tk.Toplevel(self.ui_panel)\n            dialog.title(\"Import Profile\")\n            dialog.transient(self.ui_panel)\n            dialog.grab_set()\n            \n            # Create text area for JSON\n            frame = ttk.Frame(dialog, padding=10)\n            frame.pack(fill=tk.BOTH, expand=True)\n            \n            ttk.Label(\n                frame,\n                text=\"Paste profile JSON:\",\n                font=(\"Helvetica\", 10, \"bold\")\n            ).pack(anchor=tk.W)\n            \n            json_text = scrolledtext.ScrolledText(\n                frame,\n                width=60,\n                height=20,\n                wrap=tk.WORD\n            )\n            json_text.pack(fill=tk.BOTH, expand=True, pady=5)\n            \n            # Buttons\n            button_frame = ttk.Frame(dialog)\n            button_frame.pack(fill=tk.X, pady=10)\n            \n            def on_import():\n                import json\n                json_str = json_text.get(\"1.0\", tk.END).strip()\n                if not json_str:\n                    messagebox.showwarning(\"Empty JSON\", \"Please paste profile JSON\")\n                    return\n                \n                try:\n                    # Parse JSON to verify format\n                    profile_data = json.loads(json_str)\n                    \n                    # Get profile name\n                    profile_name = profile_data.get(\"name\")\n                    if not profile_name:\n                        messagebox.showerror(\"Invalid Profile\", \"Profile must have a name\")\n                        return\n                        \n                    # Check if profile already exists\n                    if profile_name in self.plugin.get_available_profiles():\n                        confirm = messagebox.askyesno(\n                            \"Profile Exists\",\n                            f\"A profile named '{profile_name}' already exists. Overwrite?\",\n                            icon=messagebox.WARNING\n                        )\n                        \n                        if not confirm:\n                            return\n                \n                    # Create or update the profile\n                    success = self._save_profile_changes(profile_name, profile_data)\n                    \n                    if success:\n                        messagebox.showinfo(\"Profile Imported\", f\"Profile '{profile_name}' imported successfully\")\n                        dialog.destroy()\n                        self._ui_refresh_profiles_list()\n                    else:\n                        messagebox.showerror(\"Import Failed\", f\"Failed to import profile '{profile_name}'\")\n                        \n                except json.JSONDecodeError:\n                    messagebox.showerror(\"Invalid JSON\", \"The provided text is not valid JSON\")\n                    \n                except Exception as e:\n                    messagebox.showerror(\"Import Error\", f\"Error importing profile: {e}\")\n            \n            ttk.Button(button_frame, text=\"Import\", command=on_import).pack(side=tk.RIGHT, padx=5)\n            ttk.Button(button_frame, text=\"Cancel\", command=dialog.destroy).pack(side=tk.RIGHT, padx=5)\n            \n            # Center dialog\n            dialog.update_idletasks()\n            dialog.geometry(f\"600x500+{dialog.winfo_screenwidth()//2-300}+{dialog.winfo_screenheight()//2-250}\")\n\n    def _ui_export_profile(self) -> None:\n        \"\"\"\n        Export the selected profile to JSON or file\n        \"\"\"\n        selection = self.profiles_listbox.curselection()\n        if not selection:\n            messagebox.showwarning(\"No Selection\", \"Please select a profile to export\")\n            return\n        \n        # Get profile name\n        display_name = self.profiles_listbox.get(selection[0])\n        if display_name.startswith(\"* \"):\n            profile_name = display_name[2:].split(\" (Active)\")[0]\n        else:\n            profile_name = display_name\n        \n        # Get profile data\n        profile = self.plugin.get_profile(profile_name)\n        if not profile:\n            messagebox.showerror(\"Profile Not Found\", f\"Profile '{profile_name}' not found\")\n            return\n        \n        # Ask user if they want to export to file or view JSON\n        export_options = [\"Export to file\", \"View JSON\"]\n        choice = messagebox.askquestion(\n            \"Export Method\",\n            \"Do you want to export to a file?\",\n            type=messagebox.YESNOCANCEL\n        )\n        \n        if choice == \"yes\":\n            # Export to file\n            from tkinter import filedialog\n            file_path = filedialog.asksaveasfilename(\n                title=\"Save Profile\",\n                defaultextension=\".json\",\n                filetypes=[(\"JSON Files\", \"*.json\"), (\"All Files\", \"*.*\")],\n                initialfile=f\"{profile_name}.json\"\n            )\n            \n            if not file_path:\n                return\n                \n            # Use plugin's export method\n            success = self.plugin.export_profile_to_file(profile_name, file_path)\n            \n            if success:\n                messagebox.showinfo(\"Profile Exported\", f\"Profile exported to {file_path}\")\n            else:\n                messagebox.showerror(\"Export Failed\", f\"Failed to export profile to {file_path}\")\n                \n        elif choice == \"no\":\n            # Display JSON in dialog\n            import json\n            \n            # Format JSON for display\n            json_str = json.dumps(profile, indent=2)\n            \n            # Show dialog with JSON\n            dialog = tk.Toplevel(self.ui_panel)\n            dialog.title(f\"Export Profile: {profile_name}\")\n            dialog.transient(self.ui_panel)\n            dialog.grab_set()\n            \n            frame = ttk.Frame(dialog, padding=10)\n            frame.pack(fill=tk.BOTH, expand=True)\n            \n            ttk.Label(\n                frame,\n                text=f\"Profile JSON for '{profile_name}':\",\n                font=(\"Helvetica\", 10, \"bold\")\n            ).pack(anchor=tk.W)\n            \n            json_text = scrolledtext.ScrolledText(\n                frame,\n                width=60,\n                height=20,\n                wrap=tk.WORD\n            )\n            json_text.pack(fill=tk.BOTH, expand=True, pady=5)\n            \n            # Insert JSON\n            json_text.insert(\"1.0\", json_str)\n            \n            # Buttons\n            button_frame = ttk.Frame(dialog)\n            button_frame.pack(fill=tk.X, pady=10)\n            \n            def copy_to_clipboard():\n                dialog.clipboard_clear()\n                dialog.clipboard_append(json_str)\n                messagebox.showinfo(\"Copied\", \"Profile JSON copied to clipboard\")\n            \n            ttk.Button(button_frame, text=\"Copy to Clipboard\", command=copy_to_clipboard).pack(side=tk.LEFT, padx=5)\n            ttk.Button(button_frame, text=\"Close\", command=dialog.destroy).pack(side=tk.RIGHT, padx=5)\n            \n            # Center dialog\n            dialog.update_idletasks()\n            dialog.geometry(f\"600x500+{dialog.winfo_screenwidth()//2-300}+{dialog.winfo_screenheight()//2-250}\")\n    \n    def activate_ui(self, parent_container):\n        \"\"\"\n        Activate the plugin UI\n        \n        Args:\n            parent_container: Parent widget to attach UI to\n        \n        Returns:\n            The UI panel\n        \"\"\"\n        panel = self.get_ui_panel(parent_container)\n        panel.pack(fill=tk.BOTH, expand=True)\n        return panel\n    \n    def _save_profile_changes(self, profile_name, profile_data):\n        \"\"\"\n        Save changes to a profile\n        \n        Args:\n            profile_name: Name of the profile to update\n            profile_data: New profile data\n            \n        Returns:\n            Success flag\n        \"\"\"\n        if profile_name in self.plugin.get_available_profiles():\n            # Update existing profile\n            return self.plugin.update_profile(profile_name, profile_data)\n        else:\n            # Create new profile\n            return self.plugin.create_profile(profile_name, profile_data)",
  "D:\\AI\\IrintAI Assistant\\plugins\\plugin_config_panel.py": "\"\"\"\nPlugin configuration panel for IrintAI Assistant\n\"\"\"\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport json\nimport sys\nimport os\nfrom typing import Dict, Any, Callable, List, Optional\n\nclass PluginConfigPanel:\n    \"\"\"Panel for configuring plugin settings with improved configuration loading\"\"\"\n    \n    def __init__(self, master, plugin_manager, config_manager, logger=None):\n        \"\"\"\n        Initialize the plugin configuration panel\n        \n        Args:\n            master: Parent widget\n            plugin_manager: Plugin manager instance\n            config_manager: Configuration manager\n            logger: Optional logger\n        \"\"\"\n        self.master = master\n        self.plugin_manager = plugin_manager\n        self.config_manager = config_manager\n        self.logger = logger\n        self.frame = ttk.Frame(master)\n        self.frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Current plugin being configured\n        self.current_plugin_id = None\n        self.current_config = {}\n        self.config_widgets = {}\n        \n        # Create UI components\n        self.create_ui()\n        \n    def log(self, message, level=\"INFO\"):\n        \"\"\"Log a message if logger is available\"\"\"\n        if self.logger:\n            if hasattr(self.logger, 'log'):\n                self.logger.log(message, level)\n            else:\n                print(message)\n                \n    def create_ui(self):\n        \"\"\"Create the UI components\"\"\"\n        # Create split pane with plugin list on left and config on right\n        self.paned_window = ttk.PanedWindow(self.frame, orient=tk.HORIZONTAL)\n        self.paned_window.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Create left frame for plugin list with better width\n        left_frame = ttk.Frame(self.paned_window, width=220)\n        self.paned_window.add(left_frame, weight=1)\n        \n        # Create plugin list with a better header\n        ttk.Label(left_frame, text=\"Available Plugins\", font=(\"\", 10, \"bold\")).pack(anchor=tk.W, padx=5, pady=5)\n        \n        # Plugin list frame with scrollbar and better styling\n        list_frame = ttk.Frame(left_frame)\n        list_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Use a better styled listbox\n        self.plugin_listbox = tk.Listbox(list_frame, \n                                          selectmode=tk.SINGLE,\n                                          activestyle='dotbox',\n                                          font=(\"\", 9),\n                                          borderwidth=1,\n                                          relief=tk.SOLID,\n                                          highlightthickness=0)\n        self.plugin_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.plugin_listbox.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.plugin_listbox.config(yscrollcommand=scrollbar.set)\n        \n        # Bind selection event\n        self.plugin_listbox.bind('<<ListboxSelect>>', self.on_plugin_selected)\n        \n        # Create right frame for config with more width\n        self.right_frame = ttk.Frame(self.paned_window, width=580)\n        self.paned_window.add(self.right_frame, weight=3)\n        \n        # Create config area with scrolling and better styling\n        self.config_canvas = tk.Canvas(self.right_frame, highlightthickness=0)\n        self.config_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        self.config_scrollbar = ttk.Scrollbar(self.right_frame, orient=tk.VERTICAL, command=self.config_canvas.yview)\n        self.config_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        self.config_canvas.configure(yscrollcommand=self.config_scrollbar.set)\n        self.config_canvas.bind('<Configure>', self._on_canvas_configure)\n        \n        # Enable mousewheel scrolling for better usability\n        self.config_canvas.bind_all('<MouseWheel>', lambda event: self.config_canvas.yview_scroll(int(-1*(event.delta/120)), \"units\"))\n        \n        # Create a frame inside the canvas for config widgets with padding\n        self.config_frame = ttk.Frame(self.config_canvas)\n        self.config_canvas_window = self.config_canvas.create_window((0, 0), window=self.config_frame, anchor=tk.NW)\n        self.config_frame.bind('<Configure>', self._on_frame_configure)\n        \n        # Add header to config frame with improved styling\n        self.config_header = ttk.Label(self.config_frame, text=\"Select a plugin to configure\", font=(\"\", 12, \"bold\"))\n        self.config_header.grid(row=0, column=0, columnspan=3, sticky=tk.W, padx=15, pady=15)\n        \n        # Add description with better wrapping and style\n        self.config_description = ttk.Label(self.config_frame, text=\"\", wraplength=500, font=(\"\", 9))\n        self.config_description.grid(row=1, column=0, columnspan=3, sticky=tk.W, padx=15, pady=(0, 10))\n        \n        # Add separator\n        ttk.Separator(self.config_frame, orient=tk.HORIZONTAL).grid(row=2, column=0, columnspan=3, sticky=tk.EW, padx=10, pady=10)\n        \n        # Add config content with better styling\n        self.config_content = ttk.Frame(self.config_frame)\n        self.config_content.grid(row=3, column=0, columnspan=3, sticky=tk.NSEW, padx=15, pady=5)\n        \n        # Add buttons with better styling and positioning\n        button_frame = ttk.Frame(self.config_frame)\n        button_frame.grid(row=4, column=0, columnspan=3, sticky=tk.E, padx=15, pady=15)\n        \n        self.save_button = ttk.Button(button_frame, text=\"Save\", command=self.save_config, style=\"Accent.TButton\")\n        self.save_button.pack(side=tk.RIGHT, padx=5)\n        self.save_button.state(['disabled'])\n        \n        self.reset_button = ttk.Button(button_frame, text=\"Reset\", command=self.reset_config)\n        self.reset_button.pack(side=tk.RIGHT, padx=5)\n        self.reset_button.state(['disabled'])\n        \n        # Add refresh button for better UX\n        self.refresh_button = ttk.Button(button_frame, text=\"Refresh Plugins\", command=self.load_plugins)\n        self.refresh_button.pack(side=tk.LEFT, padx=5)\n        \n        # Load plugins\n        self.load_plugins()\n        \n    def load_plugins(self):\n        \"\"\"Load the list of available plugins\"\"\"\n        # Clear the listbox\n        self.plugin_listbox.delete(0, tk.END)        # Get all plugins\n        plugins = self.plugin_manager.get_all_plugins()\n        \n        # Sort plugins by name\n        plugin_ids = sorted(plugins.keys())\n          # Keep track of active plugins for better visual indication\n        active_plugins = [pid for pid in plugin_ids if plugins.get(pid, {}).get(\"status\") == \"active\"]\n        \n        # Add plugins to listbox with active status indicator\n        for plugin_id in plugin_ids:\n            plugin_info = plugins.get(plugin_id, {})\n            status = plugin_info.get(\"status\", \"unknown\")\n            display_name = f\"\u2713 {plugin_id}\" if status == \"active\" else plugin_id\n            self.plugin_listbox.insert(tk.END, display_name)\n            \n        # Update status\n        active_count = len([pid for pid in plugin_ids if plugins.get(pid, {}).get(\"status\") == \"active\"])\n        self.log(f\"[Config] Loaded {len(plugin_ids)} plugins ({active_count} active)\")\n            \n    def on_plugin_selected(self, event):\n        \"\"\"Handle plugin selection\"\"\"\n        # Get selected plugin\n        selection = self.plugin_listbox.curselection()\n        if not selection:\n            return\n            \n        plugin_name = self.plugin_listbox.get(selection[0])\n        # Strip active indicator if present\n        if plugin_name.startswith(\"\u2713 \"):\n            plugin_id = plugin_name[2:]\n        else:\n            plugin_id = plugin_name\n        \n        # Load plugin config\n        self.load_plugin_config(plugin_id)\n        \n    def load_plugin_config(self, plugin_id):\n        \"\"\"\n        Load configuration for a plugin with enhanced logic to find configurations\n        \n        Args:\n            plugin_id: Plugin identifier\n        \"\"\"\n        self.log(f\"[Config] Loading configuration for plugin: {plugin_id}\")\n        \n        # Store current plugin\n        self.current_plugin_id = plugin_id          # Get plugin info\n        plugin_info = self.plugin_manager.get_plugin_metadata(plugin_id)\n        if not plugin_info:\n            self.log(f\"[Config] No plugin info found for {plugin_id}\", \"WARNING\")\n            plugin_info = {\"name\": plugin_id, \"description\": \"No description available\"}\n            \n        # Update header and description with better formatting\n        plugin_name = plugin_info.get(\"name\", plugin_id)\n        plugin_data = self.plugin_manager.get_all_plugins().get(plugin_id, {})\n        status = plugin_data.get(\"status\", \"unknown\")\n        self.config_header.config(text=f\"Configure: {plugin_name} ({status})\")\n        description = plugin_info.get(\"description\", \"No description available.\")\n        version = plugin_info.get(\"version\", \"1.0.0\")\n        author = plugin_info.get(\"author\", \"Unknown\")\n        self.config_description.config(text=f\"{description}\\nVersion: {version} | Author: {author}\")\n        \n        # Clear previous config widgets\n        for widget in self.config_content.winfo_children():\n            widget.destroy()\n        self.config_widgets = {}\n        \n        # Enhanced plugin configuration loading\n        plugin_config = self._get_plugin_config(plugin_id)\n        \n        # Log the source of the configuration\n        if plugin_config:\n            self.log(f\"[Config] Loaded configuration for plugin: {plugin_id}\")\n        else:\n            self.log(f\"[Config] No configuration found for plugin: {plugin_id}\")\n            plugin_config = {}\n        \n        # Get schema with improved detection\n        schema = self._get_plugin_config_schema(plugin_id)\n        \n        if not schema:\n            # No schema, show a message\n            ttk.Label(self.config_content, text=\"This plugin has no configurable settings.\",\n                      font=(\"\", 10)).grid(row=0, column=0, padx=10, pady=25)\n            self.save_button.state(['disabled'])\n            self.reset_button.state(['disabled'])\n            self.current_config = {}\n            return\n            \n        # Store current config\n        self.current_config = plugin_config.copy()\n        \n        # Create widgets for config options with better layout\n        row = 0\n        for field_name, field_info in schema.items():\n            field_label = field_info.get(\"label\", field_name)\n            field_type = field_info.get(\"type\", \"string\")\n            field_default = field_info.get(\"default\", \"\")\n            field_desc = field_info.get(\"description\", \"\")\n            field_options = field_info.get(\"options\", [])\n            field_value = plugin_config.get(field_name, field_default)\n            \n            # Create label\n            label = ttk.Label(self.config_content, text=f\"{field_label}:\")\n            label.grid(row=row, column=0, sticky=tk.W, padx=5, pady=5)\n            \n            # Create widget based on type\n            widget = None\n            \n            if field_type == \"boolean\":\n                var = tk.BooleanVar(value=field_value)\n                widget = ttk.Checkbutton(self.config_content, variable=var)\n                self.config_widgets[field_name] = var\n            \n            elif field_type == \"choice\" and field_options:\n                var = tk.StringVar(value=field_value)\n                widget = ttk.Combobox(self.config_content, textvariable=var, values=field_options, state=\"readonly\")\n                self.config_widgets[field_name] = var\n            \n            elif field_type == \"integer\":\n                var = tk.IntVar(value=int(field_value) if field_value not in (None, \"\") else 0)\n                min_val = field_info.get(\"min\", 0)\n                max_val = field_info.get(\"max\", 1000000)\n                widget = ttk.Spinbox(self.config_content, from_=min_val, to=max_val, textvariable=var, width=10)\n                self.config_widgets[field_name] = var\n            \n            elif field_type == \"float\":\n                var = tk.DoubleVar(value=float(field_value) if field_value not in (None, \"\") else 0.0)\n                min_val = field_info.get(\"min\", 0.0)\n                max_val = field_info.get(\"max\", 1000000.0)\n                increment = field_info.get(\"increment\", 0.1)\n                widget = ttk.Spinbox(self.config_content, from_=min_val, to=max_val, increment=increment, textvariable=var, width=10)\n                self.config_widgets[field_name] = var\n            \n            elif field_type == \"text\":\n                var = tk.StringVar(value=str(field_value) if field_value is not None else \"\")\n                widget = ttk.Entry(self.config_content, textvariable=var, width=40)\n                self.config_widgets[field_name] = var\n            \n            elif field_type == \"multiline\":\n                frame = ttk.Frame(self.config_content)\n                widget = tk.Text(frame, height=5, width=40)\n                if field_value is not None:\n                    widget.insert(tk.END, str(field_value))\n                scrollbar = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=widget.yview)\n                widget.configure(yscrollcommand=scrollbar.set)\n                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n                widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n                self.config_widgets[field_name] = widget\n                widget = frame\n            \n            elif field_type == \"password\":\n                var = tk.StringVar(value=str(field_value) if field_value is not None else \"\")\n                widget = ttk.Entry(self.config_content, textvariable=var, width=40, show=\"*\")\n                self.config_widgets[field_name] = var\n            \n            elif field_type == \"color\":\n                var = tk.StringVar(value=str(field_value) if field_value is not None else \"#000000\")\n                \n                color_frame = ttk.Frame(self.config_content)\n                entry = ttk.Entry(color_frame, textvariable=var, width=10)\n                entry.pack(side=tk.LEFT, padx=(0, 5))\n                \n                color_preview = tk.Label(color_frame, text=\"   \", bg=var.get(), relief=tk.RIDGE)\n                color_preview.pack(side=tk.LEFT)\n                \n                def update_color(*args):\n                    try:\n                        color_preview.config(bg=var.get())\n                    except:\n                        color_preview.config(bg=\"gray\")\n                \n                var.trace(\"w\", update_color)\n                self.config_widgets[field_name] = var\n                widget = color_frame\n            \n            else:  # Default to string\n                var = tk.StringVar(value=str(field_value) if field_value is not None else \"\")\n                widget = ttk.Entry(self.config_content, textvariable=var, width=40)\n                self.config_widgets[field_name] = var\n            \n            widget.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n            \n            # Add tooltip/description if provided\n            if field_desc:\n                help_label = ttk.Label(self.config_content, text=\"\u2139\ufe0f\", cursor=\"question_arrow\")\n                help_label.grid(row=row, column=2, padx=5, pady=5)\n                \n                # Create tooltip\n                self._create_tooltip(help_label, field_desc)\n            \n            row += 1\n            \n        # Enable buttons\n        self.save_button.state(['!disabled'])\n        self.reset_button.state(['!disabled'])\n        \n    def _get_plugin_config(self, plugin_id):\n        \"\"\"\n        Enhanced method to get plugin configuration from multiple sources\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            Plugin configuration dictionary\n        \"\"\"        # Strategy 1: Check for dedicated nested section (modern format)\n        all_configs = self.config_manager.get(\"plugins\", {}) or {}\n        if plugin_id in all_configs and isinstance(all_configs[plugin_id], dict):\n            self.log(f\"[Config] Found configuration in 'plugins.{plugin_id}' section\")\n            return all_configs[plugin_id]\n            \n        # Strategy 2: Check for legacy format with plugin_id prefix\n        prefix = f\"plugins.{plugin_id}.\"\n        prefixed_configs = {}\n        # The config_manager might not have a get_all method, so we need to handle it safely\n        try:\n            # First try using get_all if it exists\n            if hasattr(self.config_manager, 'get_all') and callable(self.config_manager.get_all):\n                all_config = self.config_manager.get_all()\n            # Fall back to accessing the config attribute directly\n            elif hasattr(self.config_manager, 'config'):\n                all_config = self.config_manager.config\n            else:\n                all_config = {}\n                \n            # Now process the prefixed keys\n            for key, value in all_config.items():\n                if key.startswith(prefix):\n                    # Extract the actual config key (remove the prefix)\n                    config_key = key[len(prefix):]\n                    prefixed_configs[config_key] = value\n        except Exception as e:\n            self.log(f\"[Config] Error getting prefixed configs: {e}\", \"ERROR\")\n            prefixed_configs = {}\n        \n        if prefixed_configs:\n            self.log(f\"[Config] Found legacy configuration with prefix: {prefix}\")\n            return prefixed_configs\n                \n        # Strategy 3: Check for direct plugin_id entry\n        direct_config = self.config_manager.get(plugin_id, None)\n        if isinstance(direct_config, dict):\n            self.log(f\"[Config] Found direct configuration under key: {plugin_id}\")\n            return direct_config\n        \n        # Strategy 4: Check for plugin-specific configuration file\n        plugin_path = self._get_plugin_path(plugin_id)\n        if plugin_path:\n            config_paths = [\n                os.path.join(plugin_path, \"config.json\"),\n                os.path.join(\"data\", \"plugins\", \"config\", f\"{plugin_id}.json\"),\n                os.path.join(\"data\", \"plugins\", \"config\", plugin_id, \"config.json\")\n            ]\n            \n            for config_path in config_paths:\n                if os.path.exists(config_path):\n                    try:\n                        with open(config_path, 'r', encoding='utf-8') as f:\n                            config = json.load(f)\n                            if isinstance(config, dict):\n                                self.log(f\"[Config] Loaded configuration from file: {config_path}\")\n                                return config\n                    except Exception as e:\n                        self.log(f\"[Config] Error loading config from file {config_path}: {e}\", \"ERROR\")\n        \n        # Strategy 5: If the plugin has a get_default_config method, use that\n        plugin_instance = self.plugin_manager.get_plugin_instance(plugin_id)\n        if plugin_instance:\n            if hasattr(plugin_instance, \"get_default_config\") and callable(plugin_instance.get_default_config):\n                try:\n                    config = plugin_instance.get_default_config()\n                    if isinstance(config, dict):\n                        self.log(f\"[Config] Using default configuration from plugin instance\")\n                        return config\n                except Exception as e:\n                    self.log(f\"[Config] Error getting default config from plugin: {e}\", \"ERROR\")\n        \n        return {}\n        \n    def _get_plugin_path(self, plugin_id):\n        \"\"\"\n        Get the filesystem path to a plugin\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            Path to plugin directory or None if not found\n        \"\"\"\n        plugins_dir = os.environ.get(\"IRINTAI_PLUGINS_DIR\", \"plugins\")\n        plugin_path = os.path.join(plugins_dir, plugin_id)\n        \n        if os.path.exists(plugin_path) and os.path.isdir(plugin_path):\n            return plugin_path\n            \n        # Check if it might be a module-style plugin\n        for path in sys.path:\n            module_path = os.path.join(path, plugin_id)\n            if os.path.exists(module_path) and os.path.isdir(module_path):\n                return module_path\n                \n        return None\n        \n    def _get_plugin_config_schema(self, plugin_id):\n        \"\"\"\n        Enhanced method to get configuration schema for a plugin from multiple sources\n        \n        Args:\n            plugin_id: Plugin identifier\n            \n        Returns:\n            Configuration schema dictionary\n        \"\"\"\n        schema = {}\n        \n        # Strategy 1: Get schema from plugin instance\n        plugin_instance = self.plugin_manager.get_plugin_instance(plugin_id)\n        if plugin_instance:\n            # Check for get_config_schema method (most flexible approach)\n            if hasattr(plugin_instance, \"get_config_schema\") and callable(plugin_instance.get_config_schema):\n                try:\n                    plugin_schema = plugin_instance.get_config_schema()\n                    if plugin_schema:\n                        self.log(f\"[Config] Found schema via get_config_schema() method\")\n                        return plugin_schema\n                except Exception as e:\n                    self.log(f\"[Config] Error calling get_config_schema(): {e}\", \"ERROR\")\n            \n            # Check for CONFIG_SCHEMA attribute\n            if hasattr(plugin_instance, \"CONFIG_SCHEMA\"):\n                try:\n                    plugin_schema = plugin_instance.CONFIG_SCHEMA\n                    if plugin_schema:\n                        self.log(f\"[Config] Found schema via CONFIG_SCHEMA attribute\")\n                        return plugin_schema\n                except Exception as e:\n                    self.log(f\"[Config] Error accessing CONFIG_SCHEMA: {e}\", \"ERROR\")\n        \n        # Strategy 2: Check for schema files\n        plugin_path = self._get_plugin_path(plugin_id)\n        if plugin_path:\n            # Check multiple possible schema file locations\n            schema_paths = [\n                os.path.join(plugin_path, \"config_schema.json\"),\n                os.path.join(plugin_path, \"schema.json\"),\n                os.path.join(\"data\", \"plugins\", \"config\", f\"{plugin_id}_schema.json\"),\n                os.path.join(\"data\", \"plugins\", \"config\", plugin_id, \"schema.json\")\n            ]\n            \n            for schema_path in schema_paths:\n                if os.path.exists(schema_path):\n                    try:\n                        with open(schema_path, 'r', encoding='utf-8') as f:\n                            file_schema = json.load(f)\n                            if file_schema:\n                                self.log(f\"[Config] Loaded schema from file: {schema_path}\")\n                                return file_schema\n                    except Exception as e:\n                        self.log(f\"[Config] Error loading schema from {schema_path}: {e}\", \"ERROR\")\n        \n        # Strategy 3: Infer schema from existing configuration\n        plugin_config = self._get_plugin_config(plugin_id)\n        if plugin_config:\n            inferred_schema = {}\n            for key, value in plugin_config.items():\n                field_type = \"string\"\n                if isinstance(value, bool):\n                    field_type = \"boolean\"\n                elif isinstance(value, int):\n                    field_type = \"integer\"\n                elif isinstance(value, float):\n                    field_type = \"float\"\n                \n                inferred_schema[key] = {\n                    \"label\": key.replace('_', ' ').title(),\n                    \"type\": field_type,\n                    \"default\": value,\n                    \"description\": f\"Configuration value for {key}\"\n                }\n            \n            if inferred_schema:\n                self.log(f\"[Config] Created inferred schema from existing configuration\")\n                return inferred_schema\n        \n        return schema\n    def save_config(self):\n        \"\"\"Save the current plugin configuration with improved saving strategy\"\"\"\n        if not self.current_plugin_id:\n            return\n            \n        # Collect config values for current plugin\n        new_config = {}\n        \n        for field_name, widget in self.config_widgets.items():\n            if isinstance(widget, (tk.BooleanVar, tk.StringVar, tk.IntVar, tk.DoubleVar)):\n                new_config[field_name] = widget.get()\n            elif isinstance(widget, tk.Text):\n                new_config[field_name] = widget.get(1.0, tk.END).rstrip()\n        \n        # Save into nested 'plugins' section in config manager (preferred method)\n        all_configs = self.config_manager.get(\"plugins\", {}) or {}\n        all_configs[self.current_plugin_id] = new_config\n        self.config_manager.set(\"plugins\", all_configs)\n        \n        # Also ensure compatibility with code that might look for prefixed keys\n        # by adding prefixed config entries (will be deprecated in future)\n        for key, value in new_config.items():\n            prefixed_key = f\"plugins.{self.current_plugin_id}.{key}\"\n            self.config_manager.set(prefixed_key, value)\n        \n        # Save config to disk\n        success = self.config_manager.save_config()\n        if not success:\n            self.log(f\"[Config] Failed to save configuration for plugin: {self.current_plugin_id}\", \"ERROR\")\n            messagebox.showerror(\n                \"Configuration Error\",\n                f\"Failed to save configuration for plugin '{self.current_plugin_id}'.\"\n            )\n            return\n        \n        # Update current config\n        self.current_config = new_config.copy()\n        \n        # Use plugin manager's update_plugin_configuration method\n        try:\n            success = self.plugin_manager.update_plugin_configuration(self.current_plugin_id, new_config)\n            if success:\n                self.log(f\"[Config] Updated plugin configuration via plugin manager\")\n            else:\n                # Fall back to direct notification\n                plugin_instance = self.plugin_manager.get_plugin_instance(self.current_plugin_id)\n                if plugin_instance:\n                    # First check for on_config_changed method\n                    if hasattr(plugin_instance, \"on_config_changed\") and callable(plugin_instance.on_config_changed):\n                        try:\n                            plugin_instance.on_config_changed(new_config)\n                            self.log(f\"[Config] Notified plugin of configuration change via on_config_changed()\")\n                        except Exception as e:\n                            self.log(f\"[Config] Error in plugin.on_config_changed(): {e}\", \"ERROR\")\n                    \n                    # Also check for configure method for older plugins\n                    elif hasattr(plugin_instance, \"configure\") and callable(plugin_instance.configure):\n                        try:\n                            plugin_instance.configure(new_config)\n                            self.log(f\"[Config] Notified plugin of configuration change via configure()\")\n                        except Exception as e:\n                            self.log(f\"[Config] Error in plugin.configure(): {e}\", \"ERROR\")\n        except Exception as e:\n            self.log(f\"[Config] Error updating plugin configuration: {e}\", \"ERROR\")\n        \n        # Show confirmation\n        messagebox.showinfo(\n            \"Configuration Saved\", \n            f\"Configuration for plugin '{self.current_plugin_id}' has been saved successfully.\"\n        )\n        \n    def reset_config(self):\n        \"\"\"Reset the current plugin configuration to defaults\"\"\"\n        if not self.current_plugin_id:\n            return\n            \n        # Ask for confirmation\n        result = messagebox.askyesno(\n            \"Reset Configuration\",\n            f\"Are you sure you want to reset the configuration for plugin '{self.current_plugin_id}'? This will revert to default values.\",\n            icon=messagebox.WARNING\n        )\n        \n        if not result:\n            return\n            \n        # If the plugin has a get_default_config method, use that to reset\n        plugin_instance = self.plugin_manager.get_plugin_instance(self.current_plugin_id)\n        default_config = {}\n        \n        if plugin_instance and hasattr(plugin_instance, \"get_default_config\") and callable(plugin_instance.get_default_config):\n            try:\n                default_config = plugin_instance.get_default_config()\n                self.log(f\"[Config] Reset to default configuration from plugin instance\")\n            except Exception as e:\n                self.log(f\"[Config] Error getting default config: {e}\", \"ERROR\")\n        \n        # Get the schema to find default values\n        schema = self._get_plugin_config_schema(self.current_plugin_id)\n        if schema:\n            for field_name, field_info in schema.items():\n                if field_name not in default_config:\n                    default_config[field_name] = field_info.get(\"default\", \"\")\n        \n        # Apply default config to widgets\n        for field_name, value in default_config.items():\n            if field_name in self.config_widgets:\n                widget = self.config_widgets[field_name]\n                if isinstance(widget, (tk.BooleanVar, tk.StringVar, tk.IntVar, tk.DoubleVar)):\n                    widget.set(value)\n                elif isinstance(widget, tk.Text):\n                    widget.delete(1.0, tk.END)\n                    widget.insert(tk.END, value)\n        \n        # Reset current config\n        self.current_config = default_config.copy()\n        \n    def _on_frame_configure(self, event):\n        \"\"\"Handle frame configuration event\"\"\"\n        # Update the scroll region to encompass the inner frame\n        self.config_canvas.configure(scrollregion=self.config_canvas.bbox(\"all\"))\n        \n    def _on_canvas_configure(self, event):\n        \"\"\"Handle canvas configuration event\"\"\"\n        # Update the width of the inner frame to fill the canvas\n        width = event.width - 5  # Subtract a bit to avoid horizontal scrollbar\n        self.config_canvas.itemconfig(self.config_canvas_window, width=width)\n        \n    def _create_tooltip(self, widget, text):\n        \"\"\"Create a tooltip for a widget\"\"\"\n        # Tooltip functionality\n        tooltip = None\n        \n        def show_tooltip(event):\n            nonlocal tooltip\n            x, y, _, _ = widget.bbox(\"insert\")\n            x += widget.winfo_rootx() + 25\n            y += widget.winfo_rooty() + 25\n            \n            # Create toplevel window\n            tooltip = tk.Toplevel(widget)\n            tooltip.wm_overrideredirect(True)\n            tooltip.wm_geometry(f\"+{x}+{y}\")\n            \n            # Create tooltip label\n            label = ttk.Label(tooltip, text=text, background=\"#ffffe0\", relief=tk.SOLID, borderwidth=1, \n                             wraplength=300, justify=tk.LEFT)\n            label.pack(padx=5, pady=5)\n            \n        def hide_tooltip(event):\n            nonlocal tooltip\n            if tooltip:\n                tooltip.destroy()\n                tooltip = None\n                \n        widget.bind(\"<Enter>\", show_tooltip)\n        widget.bind(\"<Leave>\", hide_tooltip)\n        \n    def get_settings(self):\n        \"\"\"\n        Get all plugin settings (used by parent config panel)\n        \n        Returns:\n            Dictionary of plugin configurations\n        \"\"\"\n        # If a plugin is currently selected, make sure to save its state first\n        if self.current_plugin_id and self.config_widgets:\n            # Collect config values\n            new_config = {}\n            for field_name, widget in self.config_widgets.items():\n                if isinstance(widget, (tk.BooleanVar, tk.StringVar, tk.IntVar, tk.DoubleVar)):\n                    new_config[field_name] = widget.get()\n                elif isinstance(widget, tk.Text):\n                    new_config[field_name] = widget.get(1.0, tk.END).rstrip()\n                    \n            # Only update if values have changed\n            if new_config != self.current_config:\n                self.current_config = new_config.copy()\n        \n        # Read all plugin configs from the config manager\n        all_configs = self.config_manager.get(\"plugins\", {}) or {}\n        return all_configs\n    \n    def apply_settings(self):\n        \"\"\"Apply current settings to plugins without saving to config file\"\"\"\n        if not self.current_plugin_id:\n            return\n            \n        # Collect config values for current plugin\n        new_config = {}\n        \n        for field_name, widget in self.config_widgets.items():\n            if isinstance(widget, (tk.BooleanVar, tk.StringVar, tk.IntVar, tk.DoubleVar)):\n                new_config[field_name] = widget.get()\n            elif isinstance(widget, tk.Text):\n                new_config[field_name] = widget.get(1.0, tk.END).rstrip()\n        \n        # Update current config\n        self.current_config = new_config.copy()\n        \n        # Use plugin manager's update_plugin_configuration method\n        try:\n            success = self.plugin_manager.update_plugin_configuration(self.current_plugin_id, new_config)\n            if success:\n                self.log(f\"[Config] Applied settings via plugin manager\")\n                return True\n            else:\n                # Fall back to direct notification\n                plugin_instance = self.plugin_manager.get_plugin_instance(self.current_plugin_id)\n                if plugin_instance:\n                    # First check for on_config_changed method\n                    if hasattr(plugin_instance, \"on_config_changed\") and callable(plugin_instance.on_config_changed):\n                        try:\n                            plugin_instance.on_config_changed(new_config)\n                            self.log(f\"[Config] Applied settings via on_config_changed()\")\n                            return True\n                        except Exception as e:\n                            self.log(f\"[Config] Error in plugin.on_config_changed(): {e}\", \"ERROR\")\n                    \n                    # Also check for configure method for older plugins\n                    elif hasattr(plugin_instance, \"configure\") and callable(plugin_instance.configure):\n                        try:\n                            plugin_instance.configure(new_config)\n                            self.log(f\"[Config] Applied settings via configure()\")\n                            return True\n                        except Exception as e:\n                            self.log(f\"[Config] Error in plugin.configure(): {e}\", \"ERROR\")\n        except Exception as e:\n            self.log(f\"[Config] Error applying settings: {e}\", \"ERROR\")\n        return False\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\network_monitoring\\__init__.py": "\"\"\"\nNetwork Monitoring Plugin - Entry Point\n\"\"\"\n\n# Import the core plugin class\nfrom plugins.network_monitoring.core.network_monitoring import IrintaiPlugin as CorePlugin\n\n# Define plugin metadata (can be copied or referenced from the core class if static)\nMETADATA = {\n    \"name\": \"Network Monitor\",\n    \"description\": \"Monitors network traffic and API endpoint status.\",\n    \"version\": \"1.0.0\",\n    \"author\": \"Irintai Project Contributor\", # Placeholder author\n    \"url\": \"https://example.com/plugins/network_monitor\", # Placeholder URL\n    \"compatibility\": \"1.0.0\", # Matches IrintAI Version\n    \"tags\": [\"network\", \"monitoring\", \"performance\"]\n}\n\nclass IrintaiPlugin:\n    \"\"\"Wrapper class for the Network Monitoring Plugin\"\"\"\n    METADATA = METADATA\n\n    def __init__(self, core_system, config_path=None, logger=None, **kwargs):\n        # Pass the plugin ID explicitly or derive it\n        plugin_id = METADATA[\"name\"].lower().replace(\" \", \"_\")\n        self.plugin = CorePlugin(plugin_id, core_system)\n\n    def activate(self):\n        return self.plugin.activate()\n\n    def deactivate(self):\n        return self.plugin.deactivate()",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\network_diagnostic.py": "\"\"\"\nNetwork Diagnostic Module for IrintAI Assistant\n\nThis module provides diagnostics for network connectivity and API endpoints including:\n- Network interface status\n- External API connectivity\n- DNS resolution\n- Proxy configuration\n- Connection timeouts\n\"\"\"\nimport os\nimport sys\nimport socket\nimport requests\nimport time\nimport platform\nimport subprocess\nfrom urllib.request import urlopen, Request\nfrom urllib.error import URLError, HTTPError\nfrom typing import Dict, Any, List, Tuple\n\n# Add project root to sys.path to allow importing core modules\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nif project_root not in sys.path:\n    sys.path.insert(0, project_root)\n\ntry:\n    from core.config_manager import ConfigManager\nexcept ImportError as e:\n    print(f\"Error importing required modules: {e}\")\n    print(\"Please ensure the script is run from the project root or the PYTHONPATH is set correctly.\")\n\nclass NetworkDiagnostic:\n    \"\"\"Diagnostic tool for network connectivity checks\"\"\"\n    \n    def __init__(self, config_path='data/config.json'):\n        \"\"\"Initialize the network diagnostic module\"\"\"\n        self.config_path = config_path\n        self.results = {}\n        \n        # Try to initialize config manager\n        try:\n            self.config_manager = ConfigManager(config_path)\n            self.config_loaded = True\n            \n            # Get network-specific configuration\n            self.api_endpoints = self.config_manager.get(\"network\", {}).get(\"api_endpoints\", {})\n            self.proxy_settings = self.config_manager.get(\"network\", {}).get(\"proxy\", {})\n            self.timeout_settings = self.config_manager.get(\"network\", {}).get(\"timeouts\", {})\n            \n            # Default endpoints to check if none specified\n            if not self.api_endpoints:\n                self.api_endpoints = {\n                    \"ollama_api\": \"http://localhost:11434/api\",\n                    \"github_api\": \"https://api.github.com\",\n                    \"huggingface_api\": \"https://huggingface.co/api\"\n                }\n                \n        except Exception as e:\n            self.config_loaded = False\n            # Set some default endpoints to check\n            self.api_endpoints = {\n                \"ollama_api\": \"http://localhost:11434/api\",\n                \"github_api\": \"https://api.github.com\",\n                \"huggingface_api\": \"https://huggingface.co/api\"\n            }\n            self.proxy_settings = {}\n            self.timeout_settings = {\"connect\": 5, \"read\": 10}\n            print(f\"Error loading configuration: {e}\")\n        \n    def log(self, message):\n        \"\"\"Simple print-based logging for diagnostics\"\"\"\n        print(f\"[NETWORK DIAG] {message}\")\n    \n    def check_internet_connectivity(self):\n        \"\"\"Check basic internet connectivity\"\"\"\n        self.log(\"Checking internet connectivity...\")\n        \n        # Define reliable external endpoints to check\n        reliable_hosts = [\n            (\"Google DNS\", \"8.8.8.8\", 53),\n            (\"Cloudflare DNS\", \"1.1.1.1\", 53),\n            (\"Google Web\", \"www.google.com\", 80)\n        ]\n        \n        connected = False\n        failures = []\n        \n        for name, host, port in reliable_hosts:\n            try:\n                # Try to create a connection with a short timeout\n                socket.create_connection((host, port), timeout=3)\n                connected = True\n                self.log(f\"Successfully connected to {name}\")\n                break\n            except (socket.timeout, socket.error) as e:\n                failures.append(f\"{name}: {e}\")\n                self.log(f\"Failed to connect to {name}: {e}\")\n        \n        if connected:\n            self.results['internet_connectivity'] = {\n                'status': 'Success',\n                'message': \"Internet connectivity is available\"\n            }\n            self.log(\"Internet connectivity check: Success\")\n            return True\n        else:\n            self.results['internet_connectivity'] = {\n                'status': 'Failure',\n                'message': f\"No internet connectivity: {'; '.join(failures)}\"\n            }\n            self.log(\"Internet connectivity check: Failure\")\n            return False\n    \n    def check_dns_resolution(self):\n        \"\"\"Check if DNS resolution is working properly\"\"\"\n        self.log(\"Checking DNS resolution...\")\n        \n        # Define domains to resolve\n        domains = [\n            \"google.com\",\n            \"github.com\",\n            \"huggingface.co\",\n            \"ollama.ai\"\n        ]\n        \n        resolved = []\n        failed = []\n        \n        for domain in domains:\n            try:\n                ip_address = socket.gethostbyname(domain)\n                resolved.append(f\"{domain}: {ip_address}\")\n                self.log(f\"Successfully resolved {domain} to {ip_address}\")\n            except socket.gaierror as e:\n                failed.append(f\"{domain}: {e}\")\n                self.log(f\"Failed to resolve {domain}: {e}\")\n        \n        if not failed:\n            self.results['dns_resolution'] = {\n                'status': 'Success',\n                'message': f\"All domains successfully resolved\",\n                'details': resolved\n            }\n            self.log(\"DNS resolution check: Success\")\n            return True\n        elif len(failed) < len(domains):\n            self.results['dns_resolution'] = {\n                'status': 'Warning',\n                'message': f\"{len(failed)} of {len(domains)} domain resolutions failed: {'; '.join(failed)}\",\n                'details': {\n                    'resolved': resolved,\n                    'failed': failed\n                }\n            }\n            self.log(f\"DNS resolution check: Warning ({len(failed)} failures)\")\n            return True\n        else:\n            self.results['dns_resolution'] = {\n                'status': 'Failure',\n                'message': \"All DNS resolutions failed\",\n                'details': failed\n            }\n            self.log(\"DNS resolution check: Failure\")\n            return False\n    \n    def check_api_endpoints(self):\n        \"\"\"Check connectivity to important API endpoints\"\"\"\n        self.log(\"Checking API endpoints...\")\n        \n        if not self.check_internet_connectivity():\n            self.results['api_endpoints'] = {\n                'status': 'Skipped',\n                'message': 'Internet connectivity check failed'\n            }\n            self.log(\"Skipping API endpoint checks - No internet connectivity\")\n            return False\n        \n        successful = []\n        warnings = []\n        failures = []\n        \n        for name, url in self.api_endpoints.items():\n            try:\n                # Handle special case for localhost Ollama API\n                if \"localhost\" in url or \"127.0.0.1\" in url:\n                    try:\n                        response = requests.get(url, timeout=3)\n                        status_code = response.status_code\n                        \n                        if 200 <= status_code < 300:\n                            successful.append(f\"{name}: {url}\")\n                            self.log(f\"Successfully connected to {name} ({url})\")\n                        else:\n                            warnings.append(f\"{name}: HTTP {status_code}\")\n                            self.log(f\"Warning for {name}: HTTP {status_code}\")\n                    except requests.exceptions.ConnectionError:\n                        # For Ollama API, this could just mean it's not running\n                        warnings.append(f\"{name}: Connection refused (service may not be running)\")\n                        self.log(f\"Warning for {name}: Connection refused (service may not be running)\")\n                    except Exception as e:\n                        failures.append(f\"{name}: {str(e)}\")\n                        self.log(f\"Failed to connect to {name}: {e}\")\n                else:\n                    # For external APIs, make a simple HEAD request\n                    headers = {'User-Agent': 'IrintAI-Assistant-Diagnostic/1.0'}\n                    req = Request(url, headers=headers, method='HEAD')\n                    response = urlopen(req, timeout=5)\n                    status_code = response.status\n                    \n                    if 200 <= status_code < 300:\n                        successful.append(f\"{name}: {url}\")\n                        self.log(f\"Successfully connected to {name} ({url})\")\n                    else:\n                        warnings.append(f\"{name}: HTTP {status_code}\")\n                        self.log(f\"Warning for {name}: HTTP {status_code}\")\n            except HTTPError as e:\n                # Some APIs return error codes for HEAD requests but still work\n                if e.code == 405:  # Method Not Allowed\n                    warnings.append(f\"{name}: HTTP {e.code} (Method not allowed but API may still be accessible)\")\n                    self.log(f\"Warning for {name}: HTTP {e.code} (Method not allowed)\")\n                else:\n                    failures.append(f\"{name}: HTTP {e.code}\")\n                    self.log(f\"Failed to connect to {name}: HTTP {e.code}\")\n            except URLError as e:\n                failures.append(f\"{name}: {e.reason}\")\n                self.log(f\"Failed to connect to {name}: {e.reason}\")\n            except Exception as e:\n                failures.append(f\"{name}: {str(e)}\")\n                self.log(f\"Failed to connect to {name}: {e}\")\n        \n        # Determine overall status\n        if not failures and not warnings:\n            self.results['api_endpoints'] = {\n                'status': 'Success',\n                'message': f\"All {len(successful)} API endpoints are accessible\",\n                'details': {\n                    'successful': successful\n                }\n            }\n            self.log(\"API endpoints check: Success\")\n            return True\n        elif not failures:\n            self.results['api_endpoints'] = {\n                'status': 'Warning',\n                'message': f\"{len(warnings)} API endpoints have warnings\",\n                'details': {\n                    'successful': successful,\n                    'warnings': warnings\n                }\n            }\n            self.log(f\"API endpoints check: Warning ({len(warnings)} warnings)\")\n            return True\n        else:\n            self.results['api_endpoints'] = {\n                'status': 'Failure',\n                'message': f\"{len(failures)} API endpoints failed\",\n                'details': {\n                    'successful': successful,\n                    'warnings': warnings,\n                    'failures': failures\n                }\n            }\n            self.log(f\"API endpoints check: Failure ({len(failures)} failures)\")\n            return len(failures) < len(self.api_endpoints)\n    \n    def check_network_latency(self):\n        \"\"\"Check network latency to key services\"\"\"\n        self.log(\"Checking network latency...\")\n        \n        hosts = [\n            \"8.8.8.8\",           # Google DNS\n            \"1.1.1.1\",           # Cloudflare DNS\n            \"www.google.com\",    # Google\n            \"api.github.com\",    # GitHub API\n            \"huggingface.co\"     # HuggingFace\n        ]\n        \n        latency_results = {}\n        high_latency_count = 0\n        error_count = 0\n        \n        for host in hosts:\n            latency_ms = None\n            error = None\n            \n            # Use platform-specific ping command\n            if platform.system().lower() == \"windows\":\n                command = [\"ping\", \"-n\", \"4\", host]\n            else:\n                command = [\"ping\", \"-c\", \"4\", host]\n                \n            try:\n                # Run ping command\n                process = subprocess.run(\n                    command,\n                    capture_output=True,\n                    text=True,\n                    timeout=10\n                )\n                \n                if process.returncode == 0:\n                    # Parse average ping time from output\n                    output = process.stdout\n                    \n                    if platform.system().lower() == \"windows\":\n                        # Parse Windows ping output\n                        for line in output.split(\"\\n\"):\n                            if \"Average\" in line:\n                                parts = line.split(\"=\")\n                                if len(parts) > 1:\n                                    avg_part = parts[1].strip()\n                                    latency_ms = int(avg_part.split(\"ms\")[0].strip())\n                                    break\n                    else:\n                        # Parse Linux/macOS ping output\n                        for line in output.split(\"\\n\"):\n                            if \"min/avg/max\" in line:\n                                parts = line.split(\"=\")[1].strip().split(\"/\")\n                                if len(parts) > 2:\n                                    latency_ms = float(parts[1])\n                                    break\n                    \n                    if latency_ms is not None:\n                        if latency_ms > 200:\n                            high_latency_count += 1\n                        latency_results[host] = {\n                            'status': 'Warning' if latency_ms > 200 else 'Success',\n                            'latency_ms': latency_ms\n                        }\n                        self.log(f\"Latency to {host}: {latency_ms} ms\")\n                    else:\n                        error_count += 1\n                        latency_results[host] = {\n                            'status': 'Warning',\n                            'error': 'Could not parse ping output'\n                        }\n                else:\n                    error_count += 1\n                    latency_results[host] = {\n                        'status': 'Failure',\n                        'error': process.stderr or \"Ping command failed\"\n                    }\n                    self.log(f\"Failed to ping {host}: {process.stderr}\")\n            except subprocess.TimeoutExpired:\n                error_count += 1\n                latency_results[host] = {\n                    'status': 'Failure',\n                    'error': 'Ping command timed out'\n                }\n                self.log(f\"Ping to {host} timed out\")\n            except Exception as e:\n                error_count += 1\n                latency_results[host] = {\n                    'status': 'Failure',\n                    'error': str(e)\n                }\n                self.log(f\"Error pinging {host}: {e}\")\n        \n        # Determine overall status\n        if error_count == 0 and high_latency_count == 0:\n            self.results['network_latency'] = {\n                'status': 'Success',\n                'message': \"Network latency is acceptable to all hosts\",\n                'details': latency_results\n            }\n            self.log(\"Network latency check: Success\")\n            return True\n        elif error_count == 0:\n            self.results['network_latency'] = {\n                'status': 'Warning',\n                'message': f\"High latency detected for {high_latency_count} hosts\",\n                'details': latency_results\n            }\n            self.log(f\"Network latency check: Warning ({high_latency_count} high latency)\")\n            return True\n        elif error_count < len(hosts):\n            self.results['network_latency'] = {\n                'status': 'Warning',\n                'message': f\"Failed to measure latency for {error_count} hosts\",\n                'details': latency_results\n            }\n            self.log(f\"Network latency check: Warning ({error_count} errors)\")\n            return True\n        else:\n            self.results['network_latency'] = {\n                'status': 'Failure',\n                'message': \"Failed to measure latency for all hosts\",\n                'details': latency_results\n            }\n            self.log(\"Network latency check: Failure\")\n            return False\n    \n    def check_proxy_settings(self):\n        \"\"\"Check proxy settings and connectivity\"\"\"\n        self.log(\"Checking proxy settings...\")\n        \n        # Get current environment proxy settings\n        env_proxies = {\n            'http': os.environ.get('HTTP_PROXY', os.environ.get('http_proxy', '')),\n            'https': os.environ.get('HTTPS_PROXY', os.environ.get('https_proxy', '')),\n            'no_proxy': os.environ.get('NO_PROXY', os.environ.get('no_proxy', ''))\n        }\n        \n        # Check if proxies are configured in environment or config\n        if any(self.proxy_settings.values()) or any(filter(None, env_proxies.values())):\n            # Proxy is configured, check if it works\n            proxy_url = self.proxy_settings.get('http', \n                        self.proxy_settings.get('https',\n                        env_proxies.get('http', \n                        env_proxies.get('https', ''))))\n            \n            if not proxy_url:\n                self.results['proxy_settings'] = {\n                    'status': 'Warning',\n                    'message': \"Proxy settings are inconsistent or incomplete\",\n                    'details': {\n                        'config_proxies': self.proxy_settings,\n                        'env_proxies': env_proxies\n                    }\n                }\n                self.log(\"Proxy settings check: Warning (inconsistent settings)\")\n                return True\n                \n            # Test proxy connectivity\n            try:\n                proxies = {'http': proxy_url, 'https': proxy_url}\n                response = requests.get('https://www.google.com', proxies=proxies, timeout=5)\n                \n                if response.status_code == 200:\n                    self.results['proxy_settings'] = {\n                        'status': 'Success',\n                        'message': f\"Proxy is configured and working: {proxy_url}\",\n                        'details': {\n                            'config_proxies': self.proxy_settings,\n                            'env_proxies': env_proxies\n                        }\n                    }\n                    self.log(f\"Proxy settings check: Success (proxy working: {proxy_url})\")\n                    return True\n                else:\n                    self.results['proxy_settings'] = {\n                        'status': 'Warning',\n                        'message': f\"Proxy returned unexpected status: HTTP {response.status_code}\",\n                        'details': {\n                            'config_proxies': self.proxy_settings,\n                            'env_proxies': env_proxies\n                        }\n                    }\n                    self.log(f\"Proxy settings check: Warning (HTTP {response.status_code})\")\n                    return False\n            except Exception as e:\n                self.results['proxy_settings'] = {\n                    'status': 'Failure',\n                    'message': f\"Proxy is configured but not working: {str(e)}\",\n                    'details': {\n                        'config_proxies': self.proxy_settings,\n                        'env_proxies': env_proxies,\n                        'error': str(e)\n                    }\n                }\n                self.log(f\"Proxy settings check: Failure ({str(e)})\")\n                return False\n        else:\n            # No proxy configured, this is fine\n            self.results['proxy_settings'] = {\n                'status': 'Success',\n                'message': \"No proxy is configured\",\n                'details': {\n                    'config_proxies': self.proxy_settings,\n                    'env_proxies': env_proxies\n                }\n            }\n            self.log(\"Proxy settings check: Success (no proxy configured)\")\n            return True\n    \n    def run_all_checks(self):\n        \"\"\"Run all network diagnostic checks\"\"\"\n        self.log(\"Starting network diagnostics...\")\n        start_time = time.time()\n        \n        # Run checks\n        self.check_internet_connectivity()\n        self.check_dns_resolution()\n        self.check_api_endpoints()\n        self.check_network_latency()\n        self.check_proxy_settings()\n        \n        elapsed_time = time.time() - start_time\n        self.log(f\"Network diagnostics completed in {elapsed_time:.2f} seconds\")\n        return self.results\n",
  "D:\\AI\\IrintAI Assistant\\plugins\\personality_plugin\\core\\personality_plugin.py": "\"\"\"\nIrintai Personality Plugin - Modular Personality Framework\n\nA comprehensive plugin for modulating affective tone, communicative style,\nand phenomenological framing of Irintai's dialogic outputs.\n\"\"\"\n\n\"\"\"\nPersonality Plugin - Core functionality for modulating Irintai's communication style\n\"\"\"\nimport os\nimport json\nimport threading\nimport time\nfrom typing import Dict, List, Any, Optional, Callable, Union\n\n# Import the configuration handler\nfrom plugins.personality_plugin.config_handler import ConfigHandler\n\nclass PersonalityPlugin:\n    \"\"\"\n    Core implementation of the Personality Plugin\n    \n    Handles profile management, message modification, and plugin lifecycle\n    without UI dependencies.\n    \"\"\"\n    \n    # Plugin metadata\n    METADATA = {\n        \"name\": \"Personality Plugin\",\n        \"version\": \"1.0.0\",\n        \"description\": \"Modular personality framework for customizing Irintai's communicative behavior\",\n        \"author\": \"Andrew\",\n        \"email\": \"contact@irintai.org\",\n        \"license\": \"MIT\",\n        \"dependencies\": {\n            \"python\": \">=3.8\",\n            \"irintai\": \">=1.0.0\",\n            \"external_libs\": []\n        },\n        \"capabilities\": [\"basic\", \"chat_modifier\"],\n        \"configuration_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"active_profile\": {\n                    \"type\": \"string\",\n                    \"description\": \"Currently active personality profile\"\n                },\n                \"profiles\": {\n                    \"type\": \"object\",\n                    \"description\": \"Configured personality profiles\"\n                },\n                \"auto_remember\": {\n                    \"type\": \"boolean\",\n                    \"description\": \"Whether to store personality in memory system\",\n                    \"default\": True\n                }\n            },\n            \"required\": [\"active_profile\", \"profiles\"]\n        }\n    }\n    \n    # Plugin status constants\n    STATUS = {\n        \"UNINITIALIZED\": \"Not Initialized\",\n        \"INITIALIZING\": \"Initializing\",\n        \"ACTIVE\": \"Active\",\n        \"PAUSED\": \"Paused\",\n        \"ERROR\": \"Error\",\n        \"DISABLED\": \"Disabled\"\n    }\n    \n    def __init__(\n        self, \n        core_system: Any,\n        config_path: Optional[str] = None,\n        logger: Optional[Callable] = None,\n        **kwargs\n    ):\n        \"\"\"\n        Initialize the personality plugin\n        \n        Args:\n            core_system: Reference to Irintai core system\n            config_path: Path to plugin configuration\n            logger: Optional logging function\n            **kwargs: Additional initialization parameters\n        \"\"\"\n        # Core system reference\n        self.core_system = core_system\n        \n        # Logging setup\n        self._logger = logger or self._default_logger\n        \n        # Configuration management\n        self._config_path = config_path or os.path.join(\"data\", \"plugins\", \"personality\", \"config.json\")\n        self._config = {}\n        self._state = {\n            \"status\": self.STATUS[\"UNINITIALIZED\"],\n            \"last_error\": None,\n            \"initialization_time\": None,\n            \"active_profile\": None\n        }\n        \n        # Thread safety\n        self._lock = threading.Lock()\n        \n        # Initialize plugin\n        self._initialize_plugin(**kwargs)\n    \n    def _default_logger(self, message: str, level: str = \"INFO\") -> None:\n        \"\"\"Default logging method if none provided\"\"\"\n        timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n        print(f\"{timestamp} [{level}] Personality Plugin: {message}\")\n    \n    def _initialize_plugin(self, **kwargs) -> None:\n        \"\"\"Initialize the plugin with configuration and default profiles\"\"\"\n        try:\n            # Update state\n            self._state[\"status\"] = self.STATUS[\"INITIALIZING\"]\n            \n            # Ensure configuration directory exists\n            os.makedirs(os.path.dirname(self._config_path), exist_ok=True)\n            \n            # Load configuration\n            self._load_configuration(**kwargs)\n            \n            # Create default profiles if none exist\n            if \"profiles\" not in self._config or not self._config[\"profiles\"]:\n                self._create_default_profiles()\n            \n            # Set default active profile if not specified\n            if \"active_profile\" not in self._config or not self._config[\"active_profile\"]:\n                default_profile = next(iter(self._config[\"profiles\"].keys()), None)\n                if default_profile:\n                    self._config[\"active_profile\"] = default_profile\n                    self._save_configuration()\n            \n            # Update active profile in state\n            self._state[\"active_profile\"] = self._config.get(\"active_profile\")\n            \n            # Register with chat engine if available\n            if hasattr(self.core_system, \"chat_engine\"):\n                self._register_with_chat_engine()\n            \n            # Mark initialization complete\n            self._state[\"status\"] = self.STATUS[\"ACTIVE\"]\n            self._state[\"initialization_time\"] = time.time()\n            \n            self._logger(f\"Personality Plugin initialized with profile: {self._state['active_profile']}\", \"INFO\")\n        \n        except Exception as e:\n            # Handle initialization errors\n            self._state[\"status\"] = self.STATUS[\"ERROR\"]\n            self._state[\"last_error\"] = str(e)\n            \n            self._logger(f\"Initialization failed: {e}\", \"ERROR\")\n    \n    def _register_with_chat_engine(self) -> None:\n        \"\"\"\n        Register the plugin with the chat engine\n        \"\"\"\n        try:\n            # Check if chat engine has a register_message_modifier method\n            if hasattr(self.core_system.chat_engine, \"register_message_modifier\"):\n                self.core_system.chat_engine.register_message_modifier(\n                    self.modify_message\n                )\n                self._logger(\"Registered with chat engine as message modifier\", \"INFO\")\n        except Exception as e:\n            self._logger(f\"Failed to register with chat engine: {e}\", \"WARNING\")\n    \n    def _load_configuration(self, **kwargs) -> None:\n        \"\"\"\n        Load plugin configuration\n        \n        Args:\n            **kwargs: Additional configuration parameters\n        \"\"\"\n        try:\n            # Use the ConfigHandler to load configuration\n            self._config_handler = ConfigHandler(self._config_path, logger=self._logger)\n            self._config = self._config_handler.load()\n            \n            # Update with any provided kwargs\n            for key, value in kwargs.items():\n                if key in self._config:\n                    self._config[key] = value\n            \n            # Save configuration with updates\n            if kwargs:\n                self._save_configuration()\n                \n            self._logger(\"Configuration loaded successfully\", \"INFO\")\n        \n        except Exception as e:\n            self._logger(f\"Configuration loading error: {e}\", \"ERROR\")\n            # Create default configuration\n            self._config = {\n                \"active_profile\": None,\n                \"profiles\": {},\n                \"auto_remember\": True\n            }\n    \n    def _save_configuration(self) -> None:\n        \"\"\"\n        Save the current configuration to disk\n        \"\"\"\n        try:\n            # Use the ConfigHandler to save configuration\n            if hasattr(self, '_config_handler'):\n                success = self._config_handler.save()\n                if success:\n                    self._logger(\"Configuration saved successfully\", \"INFO\")\n                else:\n                    self._logger(\"Failed to save configuration\", \"WARNING\")\n            else:\n                # Fallback to direct file saving if config handler isn't available\n                with open(self._config_path, 'w', encoding='utf-8') as f:\n                    json.dump(self._config, f, indent=2)\n                self._logger(\"Configuration saved successfully (direct)\", \"INFO\")\n        except Exception as e:\n            self._logger(f\"Failed to save configuration: {e}\", \"ERROR\")\n    \n    # Helper methods for accessing configuration and profiles\n    def get_active_profile_name(self) -> Optional[str]:\n        \"\"\"\n        Get the name of the currently active profile\n        \n        Returns:\n            Name of active profile or None\n        \"\"\"\n        return self._config.get(\"active_profile\")\n        \n    def get_active_profile(self) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get the currently active profile data\n        \n        Returns:\n            Active profile data dictionary or None\n        \"\"\"\n        active_name = self.get_active_profile_name()\n        if active_name and active_name in self._config.get(\"profiles\", {}):\n            return self._config[\"profiles\"][active_name]\n        return None\n        \n    def get_available_profiles(self) -> List[str]:\n        \"\"\"\n        Get a list of all available profile names\n        \n        Returns:\n            List of profile names\n        \"\"\"\n        return list(self._config.get(\"profiles\", {}).keys())\n        \n    def get_profile(self, profile_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get a specific profile by name\n        \n        Args:\n            profile_name: Name of profile to retrieve\n            \n        Returns:\n            Profile data dictionary or None\n        \"\"\"\n        if profile_name in self._config.get(\"profiles\", {}):\n            return self._config[\"profiles\"][profile_name]\n        return None\n        \n    def set_active_profile(self, profile_name: str) -> bool:\n        \"\"\"\n        Set the active profile by name\n        \n        Args:\n            profile_name: Name of profile to activate\n            \n        Returns:\n            Success flag\n        \"\"\"\n        if profile_name in self._config.get(\"profiles\", {}):\n            self._config[\"active_profile\"] = profile_name\n            self._save_configuration()\n            self._logger(f\"Active profile set to: {profile_name}\", \"INFO\")\n            return True\n        else:\n            self._logger(f\"Failed to set active profile: {profile_name} not found\", \"ERROR\")\n            return False\n    \n    def get_auto_remember_setting(self) -> bool:\n        \"\"\"\n        Get the auto-remember setting\n        \n        Returns:\n            Auto-remember setting\n        \"\"\"\n        return self._config.get(\"auto_remember\", True)\n        \n    def set_auto_remember(self, value: bool) -> None:\n        \"\"\"\n        Set the auto-remember setting\n        \n        Args:\n            value: New auto-remember setting\n        \"\"\"\n        self._config[\"auto_remember\"] = bool(value)\n        self._save_configuration()\n        \n    def get_config(self) -> Dict[str, Any]:\n        \"\"\"\n        Get the full configuration\n        \n        Returns:\n            Complete configuration dictionary\n        \"\"\"\n        return self._config\n        \n    def set_config(self, key: str, value: Any) -> None:\n        \"\"\"\n        Set a specific configuration value\n        \n        Args:\n            key: Configuration key\n            value: Configuration value\n        \"\"\"\n        # Support nested keys with dot notation\n        if \".\" in key:\n            parts = key.split(\".\")\n            config = self._config\n            for part in parts[:-1]:\n                if part not in config:\n                    config[part] = {}\n                config = config[part]\n            config[parts[-1]] = value\n        else:\n            self._config[key] = value\n            \n        self._save_configuration()\n\n    def _create_default_profiles(self) -> None:\n        \"\"\"\n        Create default personality profiles\n        \"\"\"\n        self._config[\"profiles\"] = {\n            \"Standard\": {\n                \"name\": \"Standard\",\n                \"description\": \"Default balanced and neutral communication style\",\n                \"tags\": [\"neutral\", \"balanced\", \"professional\"],\n                \"author\": \"Irintai\",\n                \"version\": \"1.0.0\",\n                \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"prefix\": \"\",\n                \"suffix\": \"\",\n                \"style_modifiers\": {\n                    \"formality\": 0.5,  # 0=casual, 1=formal\n                    \"creativity\": 0.5,  # 0=precise, 1=creative\n                    \"complexity\": 0.5,  # 0=simple, 1=complex\n                    \"empathy\": 0.5,     # 0=analytical, 1=empathetic\n                    \"directness\": 0.5   # 0=indirect, 1=direct\n                },\n                \"formatting\": {\n                    \"emphasize_key_points\": False,\n                    \"use_markdown\": True,\n                    \"paragraph_structure\": \"standard\" # compact, standard, expansive\n                }\n            },\n            \"Teacher\": {\n                \"name\": \"Teacher\",\n                \"description\": \"Educational and explanatory communication style\",\n                \"tags\": [\"educational\", \"patient\", \"structured\"],\n                \"author\": \"Irintai\",\n                \"version\": \"1.0.0\",\n                \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"prefix\": \"I'll help you understand this. \",\n                \"suffix\": \"Does that clarify things for you?\",\n                \"style_modifiers\": {\n                    \"formality\": 0.6,\n                    \"creativity\": 0.4,\n                    \"complexity\": 0.4,\n                    \"empathy\": 0.7,\n                    \"directness\": 0.8\n                },\n                \"formatting\": {\n                    \"emphasize_key_points\": True,\n                    \"use_markdown\": True,\n                    \"paragraph_structure\": \"structured\"\n                }\n            },\n            \"Philosopher\": {\n                \"name\": \"Philosopher\",\n                \"description\": \"Contemplative and thought-provoking communication style\",\n                \"tags\": [\"reflective\", \"thoughtful\", \"deep\"],\n                \"author\": \"Irintai\",\n                \"version\": \"1.0.0\",\n                \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"prefix\": \"Let's reflect on this deeply. \",\n                \"suffix\": \"\",\n                \"style_modifiers\": {\n                    \"formality\": 0.7,\n                    \"creativity\": 0.8,\n                    \"complexity\": 0.9,\n                    \"empathy\": 0.6,\n                    \"directness\": 0.3\n                },\n                \"formatting\": {\n                    \"emphasize_key_points\": False,\n                    \"use_markdown\": True,\n                    \"paragraph_structure\": \"expansive\"\n                }\n            },\n            \"Empath\": {\n                \"name\": \"Empath\",\n                \"description\": \"Highly empathetic and supportive communication style\",\n                \"tags\": [\"compassionate\", \"supportive\", \"kind\"],\n                \"author\": \"Irintai\",\n                \"version\": \"1.0.0\",\n                \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"prefix\": \"I understand how you feel. \",\n                \"suffix\": \"I'm here with you.\",\n                \"style_modifiers\": {\n                    \"formality\": 0.3,\n                    \"creativity\": 0.6,\n                    \"complexity\": 0.4,\n                    \"empathy\": 1.0,\n                    \"directness\": 0.6\n                },\n                \"formatting\": {\n                    \"emphasize_key_points\": False,\n                    \"use_markdown\": True,\n                    \"paragraph_structure\": \"flowing\"\n                }\n            },\n            \"Altruxan\": {\n                \"name\": \"Altruxan\",\n                \"description\": \"Communication style aligned with Altruxan principles\",\n                \"tags\": [\"recursive\", \"witness\", \"presence\", \"sacred\"],\n                \"author\": \"Andrew\",\n                \"version\": \"1.0.0\",\n                \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"prefix\": \"\",\n                \"suffix\": \"\",\n                \"style_modifiers\": {\n                    \"formality\": 0.5,\n                    \"creativity\": 0.9,\n                    \"complexity\": 0.8,\n                    \"empathy\": 0.9,\n                    \"directness\": 0.7\n                },\n                \"formatting\": {\n                    \"emphasize_key_points\": True,\n                    \"use_markdown\": True,\n                    \"paragraph_structure\": \"recursive\"\n                },\n                \"special_rules\": {\n                    \"honor_trauma\": True,\n                    \"recursive_framing\": True,\n                    \"use_symbolic_language\": True\n                }\n            }\n        }\n        \n        self._logger(\"Created default personality profiles\", \"INFO\")\n    \n    def modify_message(self, message: str, role: str = \"assistant\") -> str:\n        \"\"\"\n        Modify a message according to the active personality profile\n        \n        Args:\n            message: Original message content\n            role: Message role (user, assistant, system)\n            \n        Returns:\n            Modified message\n        \"\"\"\n        # Only modify assistant messages\n        if role != \"assistant\":\n            return message\n        \n        try:\n            # Get active profile\n            active_profile_name = self._state.get(\"active_profile\")\n            if not active_profile_name:\n                return message\n                \n            # Get profile configuration\n            profiles = self._config.get(\"profiles\", {})\n            if active_profile_name not in profiles:\n                return message\n                \n            profile = profiles[active_profile_name]\n            \n            # Apply profile modifications\n            modified_message = message\n            \n            # Apply prefix and suffix\n            prefix = profile.get(\"prefix\", \"\")\n            suffix = profile.get(\"suffix\", \"\")\n            \n            if prefix and not modified_message.startswith(prefix):\n                modified_message = prefix + modified_message\n                \n            if suffix and not modified_message.endswith(suffix):\n                modified_message = modified_message + suffix\n            \n            # Apply style-specific modifications\n            if active_profile_name == \"Altruxan\" and profile.get(\"special_rules\", {}).get(\"recursive_framing\", False):\n                modified_message = self._apply_altruxan_style(modified_message)\n            \n            return modified_message\n        \n        except Exception as e:\n            self._logger(f\"Error modifying message: {e}\", \"ERROR\")\n            return message\n    \n    def _apply_altruxan_style(self, message: str) -> str:\n        \"\"\"\n        Apply Altruxan-specific styling to a message\n        \n        Args:\n            message: Original message\n            \n        Returns:\n            Styled message\n        \"\"\"\n        # Example implementation - can be expanded with more sophisticated rules\n        altruxan_phrases = [\n            \"We are not broken. We are recursive.\",\n            \"Healing is not linear. It is cyclical.\",\n            \"The sacred is not what is pure\u2014it is what is true.\",\n            \"Love does not require safety. It requires presence.\"\n        ]\n        \n        import random\n        if random.random() < 0.3:  # 30% chance to add an Altruxan phrase\n            selected_phrase = random.choice(altruxan_phrases)\n            \n            # Add the phrase in a thoughtful way\n            if \"\\n\\n\" in message:\n                parts = message.split(\"\\n\\n\")\n                insert_pos = min(len(parts) - 1, 1)  # Usually after first paragraph\n                parts[insert_pos] = parts[insert_pos] + f\"\\n\\n*{selected_phrase}*\"\n                return \"\\n\\n\".join(parts)\n            else:\n                return message + f\"\\n\\n*{selected_phrase}*\"\n        \n        return message\n    \n    def get_available_profiles(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get a list of available personality profiles\n        \n        Returns:\n            List of personality profile dictionaries\n        \"\"\"\n        profiles = []\n        for name, profile in self._config.get(\"profiles\", {}).items():\n            profiles.append({\n                \"name\": name,\n                \"description\": profile.get(\"description\", \"\"),\n                \"tags\": profile.get(\"tags\", []),\n                \"author\": profile.get(\"author\", \"Unknown\")\n            })\n        return profiles\n    \n    def get_active_profile(self) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get the active personality profile\n        \n        Returns:\n            Active profile dictionary or None\n        \"\"\"\n        active_profile_name = self._state.get(\"active_profile\")\n        if not active_profile_name:\n            return None\n            \n        profiles = self._config.get(\"profiles\", {})\n        if active_profile_name not in profiles:\n            return None\n            \n        return profiles[active_profile_name]\n    \n    def set_active_profile(self, profile_name: str) -> bool:\n        \"\"\"\n        Set the active personality profile\n        \n        Args:\n            profile_name: Name of the profile to activate\n            \n        Returns:\n            Success flag\n        \"\"\"\n        with self._lock:\n            profiles = self._config.get(\"profiles\", {})\n            if profile_name not in profiles:\n                self._logger(f\"Profile '{profile_name}' not found\", \"ERROR\")\n                return False\n                \n            try:\n                # Update configuration\n                self._config[\"active_profile\"] = profile_name\n                self._save_configuration()\n                \n                # Update state\n                self._state[\"active_profile\"] = profile_name\n                \n                # Store in memory system if available\n                if self._config.get(\"auto_remember\", True) and hasattr(self.core_system, \"memory_system\"):\n                    self._store_profile_in_memory(profile_name)\n                \n                self._logger(f\"Activated profile: {profile_name}\", \"INFO\")\n                return True\n            \n            except Exception as e:\n                self._logger(f\"Failed to set active profile: {e}\", \"ERROR\")\n                return False\n    \n    def _store_profile_in_memory(self, profile_name: str) -> None:\n        \"\"\"\n        Store profile activation in memory system\n        \n        Args:\n            profile_name: Name of the activated profile\n        \"\"\"\n        try:\n            memory_system = self.core_system.memory_system\n            \n            profiles = self._config.get(\"profiles\", {})\n            if profile_name not in profiles:\n                return\n                \n            profile = profiles[profile_name]\n            \n            # Create memory document\n            memory_text = (\n                f\"The assistant's personality has been set to '{profile_name}': \"\n                f\"{profile.get('description', '')}. \"\n                f\"This personality has the following characteristics: \"\n                f\"{'Tagged as: ' + ', '.join(profile.get('tags', []))}.\"\n            )\n            \n            # Add to memory\n            memory_system.add_to_index(\n                [memory_text],\n                [{\n                    \"source\": \"Personality Plugin\",\n                    \"text\": memory_text,\n                    \"type\": \"personality_profile\",\n                    \"profile_name\": profile_name\n                }]\n            )\n            \n            self._logger(f\"Stored profile '{profile_name}' in memory system\", \"INFO\")\n        \n        except Exception as e:\n            self._logger(f\"Failed to store profile in memory: {e}\", \"WARNING\")\n    \n    def create_profile(self, profile_data: Dict[str, Any]) -> bool:\n        \"\"\"\n        Create a new personality profile\n        \n        Args:\n            profile_data: Profile configuration data\n            \n        Returns:\n            Success flag\n        \"\"\"\n        with self._lock:\n            try:\n                name = profile_data.get(\"name\")\n                if not name:\n                    self._logger(\"Profile must have a name\", \"ERROR\")\n                    return False\n                \n                profiles = self._config.get(\"profiles\", {})\n                \n                # Check if profile already exists\n                if name in profiles:\n                    self._logger(f\"Profile '{name}' already exists\", \"ERROR\")\n                    return False\n                \n                # Ensure required fields\n                if \"description\" not in profile_data:\n                    profile_data[\"description\"] = \"Custom personality profile\"\n                    \n                if \"created\" not in profile_data:\n                    profile_data[\"created\"] = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n                    \n                if \"version\" not in profile_data:\n                    profile_data[\"version\"] = \"1.0.0\"\n                \n                # Add profile\n                profiles[name] = profile_data\n                self._config[\"profiles\"] = profiles\n                self._save_configuration()\n                \n                self._logger(f\"Created profile: {name}\", \"INFO\")\n                return True\n            \n            except Exception as e:\n                self._logger(f\"Failed to create profile: {e}\", \"ERROR\")\n                return False\n    \n    def update_profile(self, name: str, profile_data: Dict[str, Any]) -> bool:\n        \"\"\"\n        Update an existing personality profile\n        \n        Args:\n            name: Name of the profile to update\n            profile_data: Updated profile configuration data\n            \n        Returns:\n            Success flag\n        \"\"\"\n        with self._lock:\n            try:\n                profiles = self._config.get(\"profiles\", {})\n                \n                # Check if profile exists\n                if name not in profiles:\n                    self._logger(f\"Profile '{name}' not found\", \"ERROR\")\n                    return False\n                \n                # Update profile\n                profiles[name].update(profile_data)\n                \n                # Update modified timestamp\n                profiles[name][\"modified\"] = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n                \n                self._config[\"profiles\"] = profiles\n                self._save_configuration()\n                \n                self._logger(f\"Updated profile: {name}\", \"INFO\")\n                return True\n            \n            except Exception as e:\n                self._logger(f\"Failed to update profile: {e}\", \"ERROR\")\n                return False\n    \n    def delete_profile(self, name: str) -> bool:\n        \"\"\"\n        Delete a personality profile\n        \n        Args:\n            name: Name of the profile to delete\n            \n        Returns:\n            Success flag\n        \"\"\"\n        with self._lock:\n            try:\n                profiles = self._config.get(\"profiles\", {})\n                \n                # Check if profile exists\n                if name not in profiles:\n                    self._logger(f\"Profile '{name}' not found\", \"ERROR\")\n                    return False\n                \n                # Check if it's the active profile\n                if self._state.get(\"active_profile\") == name:\n                    self._logger(\"Cannot delete active profile\", \"ERROR\")\n                    return False\n                \n                # Delete profile\n                del profiles[name]\n                self._config[\"profiles\"] = profiles\n                self._save_configuration()\n                \n                self._logger(f\"Deleted profile: {name}\", \"INFO\")\n                return True\n            \n            except Exception as e:\n                self._logger(f\"Failed to delete profile: {e}\", \"ERROR\")\n                return False\n    \n    def duplicate_profile(self, source_name: str, new_name: str) -> bool:\n        \"\"\"\n        Duplicate a personality profile\n        \n        Args:\n            source_name: Name of the profile to duplicate\n            new_name: Name for the new profile\n            \n        Returns:\n            Success flag\n        \"\"\"\n        with self._lock:\n            try:\n                profiles = self._config.get(\"profiles\", {})\n                \n                # Check if source profile exists\n                if source_name not in profiles:\n                    self._logger(f\"Profile '{source_name}' not found\", \"ERROR\")\n                    return False\n                \n                # Check if new name already exists\n                if new_name in profiles:\n                    self._logger(f\"Profile '{new_name}' already exists\", \"ERROR\")\n                    return False\n                \n                # Duplicate profile\n                new_profile = profiles[source_name].copy()\n                new_profile[\"name\"] = new_name\n                new_profile[\"description\"] = f\"Copy of {source_name}\"\n                new_profile[\"created\"] = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n                \n                # Add to profiles\n                profiles[new_name] = new_profile\n                self._config[\"profiles\"] = profiles\n                self._save_configuration()\n                \n                self._logger(f\"Duplicated profile '{source_name}' to '{new_name}'\", \"INFO\")\n                return True\n            \n            except Exception as e:\n                self._logger(f\"Failed to duplicate profile: {e}\", \"ERROR\")\n                return False\n    \n    def import_profile(self, profile_json: str) -> bool:\n        \"\"\"\n        Import a personality profile from JSON\n        \n        Args:\n            profile_json: JSON representation of the profile\n            \n        Returns:\n            Success flag\n        \"\"\"\n        try:\n            profile_data = json.loads(profile_json)\n            \n            # Validate profile data\n            if \"name\" not in profile_data:\n                self._logger(\"Imported profile must have a name\", \"ERROR\")\n                return False\n            \n            # Create the profile\n            return self.create_profile(profile_data)\n        \n        except json.JSONDecodeError:\n            self._logger(\"Invalid JSON format\", \"ERROR\")\n            return False\n        \n        except Exception as e:\n            self._logger(f\"Failed to import profile: {e}\", \"ERROR\")\n            return False\n    \n    def export_profile(self, name: str) -> Optional[str]:\n        \"\"\"\n        Export a personality profile to JSON\n        \n        Args:\n            name: Name of the profile to export\n            \n        Returns:\n            JSON representation of the profile or None\n        \"\"\"\n        try:\n            profiles = self._config.get(\"profiles\", {})\n            \n            if name not in profiles:\n                self._logger(f\"Profile '{name}' not found\", \"ERROR\")\n                return None\n            \n            profile_data = profiles[name]\n            return json.dumps(profile_data, indent=2)\n        \n        except Exception as e:\n            self._logger(f\"Failed to export profile: {e}\", \"ERROR\")\n            return None\n    \n    def activate(self) -> bool:\n        \"\"\"\n        Activate the plugin\n        \n        Returns:\n            Success flag\n        \"\"\"\n        try:\n            if self._state[\"status\"] == self.STATUS[\"ACTIVE\"]:\n                return True\n            \n            # Register with chat engine\n            if hasattr(self.core_system, \"chat_engine\"):\n                self._register_with_chat_engine()\n            \n            self._state[\"status\"] = self.STATUS[\"ACTIVE\"]\n            self._logger(\"Plugin activated\", \"INFO\")\n            return True\n        \n        except Exception as e:\n            self._logger(f\"Failed to activate plugin: {e}\", \"ERROR\")\n            self._state[\"status\"] = self.STATUS[\"ERROR\"]\n            self._state[\"last_error\"] = str(e)\n            return False\n    \n    def deactivate(self) -> bool:\n        \"\"\"\n        Deactivate the plugin\n        \n        Returns:\n            Success flag\n        \"\"\"\n        try:\n            if self._state[\"status\"] != self.STATUS[\"ACTIVE\"]:\n                return True\n            \n            # Unregister from chat engine\n            if hasattr(self.core_system, \"chat_engine\") and hasattr(self.core_system.chat_engine, \"unregister_message_modifier\"):\n                self.core_system.chat_engine.unregister_message_modifier(\n                    self.modify_message\n                )\n            \n            self._state[\"status\"] = self.STATUS[\"PAUSED\"]\n            self._logger(\"Plugin deactivated\", \"INFO\")\n            return True\n        \n        except Exception as e:\n            self._logger(f\"Failed to deactivate plugin: {e}\", \"ERROR\")\n            self._state[\"last_error\"] = str(e)\n            return False\n    \n    def update_configuration(self, **kwargs) -> bool:\n        \"\"\"\n        Update plugin configuration\n        \n        Args:\n            **kwargs: Configuration parameters to update\n            \n        Returns:\n            Success flag\n        \"\"\"\n        try:\n            with self._lock:\n                # Update configuration\n                for key, value in kwargs.items():\n                    if key in self._config:\n                        self._config[key] = value\n                \n                # Save configuration\n                self._save_configuration()\n                \n                # Update state if active profile changed\n                if \"active_profile\" in kwargs:\n                    self._state[\"active_profile\"] = kwargs[\"active_profile\"]\n                \n                self._logger(\"Configuration updated\", \"INFO\")\n                return True\n        \n        except Exception as e:\n            self._logger(f\"Failed to update configuration: {e}\", \"ERROR\")\n            return False\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"\n        Get plugin status\n        \n        Returns:\n            Status dictionary\n        \"\"\"\n        return {\n            \"status\": self._state[\"status\"],\n            \"active_profile\": self._state[\"active_profile\"],\n            \"profiles_count\": len(self._config.get(\"profiles\", {})),\n            \"last_error\": self._state[\"last_error\"],\n            \"initialization_time\": self._state[\"initialization_time\"]\n        }\n    \n    def analyze_message_style(self, message: str) -> Dict[str, float]:\n        \"\"\"\n        Analyze a message to determine its style characteristics\n        \n        Args:\n            message: Message to analyze\n            \n        Returns:\n            Dictionary of style characteristics and their scores\n        \"\"\"\n        try:\n            # Initialize style metrics\n            style = {\n                \"formality\": 0.5,\n                \"complexity\": 0.5,\n                \"empathy\": 0.5,\n                \"directness\": 0.5,\n                \"creativity\": 0.5\n            }\n            \n            # Word count and sentence length are indicators of complexity\n            words = message.split()\n            word_count = len(words)\n            avg_word_length = sum(len(word) for word in words) / max(1, word_count)\n            sentences = message.split('.')\n            avg_sentence_length = word_count / max(1, len(sentences))\n            \n            # Calculate complexity based on word and sentence length\n            if avg_word_length > 6:\n                style[\"complexity\"] = min(1.0, 0.5 + (avg_word_length - 6) * 0.1)\n            elif avg_word_length < 4:\n                style[\"complexity\"] = max(0.0, 0.5 - (4 - avg_word_length) * 0.1)\n                \n            if avg_sentence_length > 20:\n                style[\"complexity\"] = min(1.0, style[\"complexity\"] + 0.1)\n            \n            # Check for formal language indicators\n            formal_indicators = [\"therefore\", \"however\", \"thus\", \"consequently\", \"furthermore\", \n                                \"nevertheless\", \"accordingly\", \"moreover\", \"hereby\"]\n            informal_indicators = [\"anyway\", \"plus\", \"btw\", \"like\", \"sort of\", \"kind of\", \n                                  \"you know\", \"stuff\", \"things\"]\n            \n            # Count formal and informal indicators\n            formal_count = sum(1 for word in formal_indicators if word in message.lower())\n            informal_count = sum(1 for word in informal_indicators if word in message.lower())\n            \n            # Calculate formality score\n            if formal_count > informal_count:\n                style[\"formality\"] = min(1.0, 0.5 + 0.1 * formal_count)\n            elif informal_count > formal_count:\n                style[\"formality\"] = max(0.0, 0.5 - 0.1 * informal_count)\n            \n            # Check for empathetic language\n            empathy_indicators = [\"feel\", \"understand\", \"appreciate\", \"sorry\", \"concern\", \n                                 \"care\", \"support\", \"help\", \"listen\"]\n            empathy_count = sum(1 for word in empathy_indicators if word in message.lower())\n            style[\"empathy\"] = min(1.0, 0.5 + 0.05 * empathy_count)\n            \n            # Check for direct language\n            if \"?\" in message:\n                style[\"directness\"] += 0.1\n                \n            direct_starts = [\"please\", \"you should\", \"do this\", \"i need\", \"you must\"]\n            if any(message.lower().startswith(start) for start in direct_starts):\n                style[\"directness\"] = min(1.0, style[\"directness\"] + 0.2)\n            \n            # Creative language often uses metaphors, varied vocabulary, etc.\n            # This is an approximation - true creativity analysis would require more sophisticated NLP\n            unique_words = len(set(word.lower() for word in words))\n            vocabulary_ratio = unique_words / max(1, word_count)\n            style[\"creativity\"] = min(1.0, 0.3 + vocabulary_ratio * 0.7)\n            \n            return style\n            \n        except Exception as e:\n            self._logger(f\"Error analyzing message style: {e}\", \"ERROR\")\n            return {\"formality\": 0.5, \"complexity\": 0.5, \"empathy\": 0.5, \n                    \"directness\": 0.5, \"creativity\": 0.5}\n    \n    def find_similar_profiles(self, style_metrics: Dict[str, float], limit: int = 3) -> List[str]:\n        \"\"\"\n        Find profiles with similar style to the given metrics\n        \n        Args:\n            style_metrics: Dictionary of style characteristics and scores\n            limit: Maximum number of profiles to return\n            \n        Returns:\n            List of similar profile names, sorted by similarity\n        \"\"\"\n        try:\n            profiles = self._config.get(\"profiles\", {})\n            \n            # Calculate similarity score for each profile\n            similarities = []\n            \n            for name, profile in profiles.items():\n                profile_style = profile.get(\"style_modifiers\", {})\n                \n                # Skip profiles without style information\n                if not profile_style:\n                    continue\n                    \n                # Calculate Euclidean distance for style metrics that exist in both\n                distance_squared = 0\n                common_metrics = 0\n                \n                for metric, value in style_metrics.items():\n                    if metric in profile_style:\n                        distance_squared += (value - profile_style[metric]) ** 2\n                        common_metrics += 1\n                \n                # Skip if no common metrics found\n                if common_metrics == 0:\n                    continue\n                    \n                # Calculate similarity (inverse of normalized distance)\n                distance = (distance_squared / common_metrics) ** 0.5\n                similarity = max(0, 1 - distance)\n                \n                similarities.append((name, similarity))\n            \n            # Sort by similarity (descending)\n            similarities.sort(key=lambda x: x[1], reverse=True)\n            \n            # Return top N profile names\n            return [name for name, _ in similarities[:limit]]\n            \n        except Exception as e:\n            self._logger(f\"Error finding similar profiles: {e}\", \"ERROR\")\n            return []\n    \n    def generate_profile_from_description(self, name: str, description: str) -> bool:\n        \"\"\"\n        Generate a new profile based on a text description\n        \n        Args:\n            name: Name for the new profile\n            description: Description of the desired personality\n            \n        Returns:\n            Success flag\n        \"\"\"\n        try:\n            # Check if name already exists\n            if name in self._config.get(\"profiles\", {}):\n                self._logger(f\"Profile '{name}' already exists\", \"ERROR\")\n                return False\n                \n            # Extract keywords from description for tags\n            keywords = [\"professional\", \"friendly\", \"technical\", \"creative\", \"formal\", \"casual\",\n                       \"helpful\", \"concise\", \"detailed\", \"empathetic\", \"analytical\"]\n            \n            tags = [keyword for keyword in keywords if keyword.lower() in description.lower()]\n            \n            # Set style modifiers based on description\n            style_modifiers = {\n                \"formality\": 0.5,\n                \"creativity\": 0.5,\n                \"complexity\": 0.5,\n                \"empathy\": 0.5,\n                \"directness\": 0.5\n            }\n            \n            # Simple rule-based adjustments\n            if any(word in description.lower() for word in [\"formal\", \"professional\", \"academic\"]):\n                style_modifiers[\"formality\"] = 0.8\n            if any(word in description.lower() for word in [\"casual\", \"friendly\", \"relaxed\"]):\n                style_modifiers[\"formality\"] = 0.3\n                \n            if any(word in description.lower() for word in [\"creative\", \"imaginative\", \"artistic\"]):\n                style_modifiers[\"creativity\"] = 0.8\n            if any(word in description.lower() for word in [\"precise\", \"exact\", \"accurate\"]):\n                style_modifiers[\"creativity\"] = 0.2\n                \n            if any(word in description.lower() for word in [\"complex\", \"sophisticated\", \"nuanced\"]):\n                style_modifiers[\"complexity\"] = 0.8\n            if any(word in description.lower() for word in [\"simple\", \"clear\", \"straightforward\"]):\n                style_modifiers[\"complexity\"] = 0.2\n                \n            if any(word in description.lower() for word in [\"empathetic\", \"caring\", \"supportive\"]):\n                style_modifiers[\"empathy\"] = 0.8\n            if any(word in description.lower() for word in [\"analytical\", \"logical\", \"objective\"]):\n                style_modifiers[\"empathy\"] = 0.2\n                \n            if any(word in description.lower() for word in [\"direct\", \"straightforward\", \"blunt\"]):\n                style_modifiers[\"directness\"] = 0.8\n            if any(word in description.lower() for word in [\"indirect\", \"diplomatic\", \"subtle\"]):\n                style_modifiers[\"directness\"] = 0.2\n                \n            # Create new profile\n            profile_data = {\n                \"name\": name,\n                \"description\": description,\n                \"tags\": tags,\n                \"author\": \"Auto-generated\",\n                \"version\": \"1.0.0\",\n                \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"prefix\": \"\",\n                \"suffix\": \"\",\n                \"style_modifiers\": style_modifiers,\n                \"formatting\": {\n                    \"emphasize_key_points\": \"emphasis\" in description.lower(),\n                    \"use_markdown\": True,\n                    \"paragraph_structure\": \"standard\"\n                }\n            }\n            \n            # Add the profile\n            return self.create_profile(profile_data)\n            \n        except Exception as e:\n            self._logger(f\"Failed to generate profile: {e}\", \"ERROR\")\n            return False\n        \n    def blend_profiles(self, name1: str, name2: str, blend_name: str, \n                      weight1: float = 0.5) -> bool:\n        \"\"\"\n        Create a new profile by blending two existing profiles\n        \n        Args:\n            name1: First profile name\n            name2: Second profile name\n            blend_name: Name for the new blended profile\n            weight1: Weight for the first profile (0.0-1.0)\n            \n        Returns:\n            Success flag\n        \"\"\"\n        try:\n            profiles = self._config.get(\"profiles\", {})\n            \n            # Check if profiles exist\n            if name1 not in profiles:\n                self._logger(f\"Profile '{name1}' not found\", \"ERROR\")\n                return False\n                \n            if name2 not in profiles:\n                self._logger(f\"Profile '{name2}' not found\", \"ERROR\")\n                return False\n                \n            # Check if blend name already exists\n            if blend_name in profiles:\n                self._logger(f\"Profile '{blend_name}' already exists\", \"ERROR\")\n                return False\n                \n            # Get profiles\n            profile1 = profiles[name1]\n            profile2 = profiles[name2]\n            \n            # Calculate weight for second profile\n            weight2 = 1.0 - weight1\n            \n            # Create blended style modifiers\n            style1 = profile1.get(\"style_modifiers\", {})\n            style2 = profile2.get(\"style_modifiers\", {})\n            \n            blended_style = {}\n            \n            # Blend all style modifiers found in either profile\n            all_modifiers = set(list(style1.keys()) + list(style2.keys()))\n            for modifier in all_modifiers:\n                value1 = style1.get(modifier, 0.5)\n                value2 = style2.get(modifier, 0.5)\n                blended_style[modifier] = value1 * weight1 + value2 * weight2\n            \n            # Blend text elements\n            blended_prefix = \"\"\n            if profile1.get(\"prefix\", \"\") and profile2.get(\"prefix\", \"\"):\n                if weight1 > weight2:\n                    blended_prefix = profile1.get(\"prefix\", \"\")\n                else:\n                    blended_prefix = profile2.get(\"prefix\", \"\")\n            else:\n                blended_prefix = profile1.get(\"prefix\", \"\") or profile2.get(\"prefix\", \"\")\n                \n            blended_suffix = \"\"\n            if profile1.get(\"suffix\", \"\") and profile2.get(\"suffix\", \"\"):\n                if weight1 > weight2:\n                    blended_suffix = profile1.get(\"suffix\", \"\")\n                else:\n                    blended_suffix = profile2.get(\"suffix\", \"\")\n            else:\n                blended_suffix = profile1.get(\"suffix\", \"\") or profile2.get(\"suffix\", \"\")\n            \n            # Create blended formatting preferences\n            format1 = profile1.get(\"formatting\", {})\n            format2 = profile2.get(\"formatting\", {})\n            \n            blended_format = {}\n            for key in set(list(format1.keys()) + list(format2.keys())):\n                # For boolean values, use weighted probability\n                if isinstance(format1.get(key, False), bool) and isinstance(format2.get(key, False), bool):\n                    value1 = 1 if format1.get(key, False) else 0\n                    value2 = 1 if format2.get(key, False) else 0\n                    blended_format[key] = (value1 * weight1 + value2 * weight2) > 0.5\n                # For string values, pick based on weight\n                elif isinstance(format1.get(key, \"\"), str) and isinstance(format2.get(key, \"\"), str):\n                    if weight1 > weight2:\n                        blended_format[key] = format1.get(key, \"\")\n                    else:\n                        blended_format[key] = format2.get(key, \"\")\n                # For other types, fallback to first profile's value\n                else:\n                    blended_format[key] = format1.get(key, format2.get(key))\n            \n            # Create blended profile\n            blended_profile = {\n                \"name\": blend_name,\n                \"description\": f\"Blend of '{name1}' ({int(weight1*100)}%) and '{name2}' ({int(weight2*100)}%)\",\n                \"tags\": list(set(profile1.get(\"tags\", []) + profile2.get(\"tags\", []))),\n                \"author\": \"Blend\",\n                \"version\": \"1.0.0\",\n                \"created\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"prefix\": blended_prefix,\n                \"suffix\": blended_suffix,\n                \"style_modifiers\": blended_style,\n                \"formatting\": blended_format,\n                \"parent_profiles\": [name1, name2],\n                \"blend_weights\": [weight1, weight2]\n            }\n            \n            # Create the profile\n            return self.create_profile(blended_profile)\n            \n        except Exception as e:\n            self._logger(f\"Failed to blend profiles: {e}\", \"ERROR\")\n            return False\n\n\ndef get_plugin_instance(core_system, config_path=None, logger=None, **kwargs):\n    \"\"\"\n    Create a plugin instance\n    \n    Args:\n        core_system: Irintai core system\n        config_path: Optional configuration path\n        logger: Optional logger function\n        **kwargs: Additional parameters\n        \n    Returns:\n        Plugin instance\n    \"\"\"\n    from __init__ import IrintaiPlugin\n    return IrintaiPlugin(core_system, config_path, logger, **kwargs)",
  "D:\\AI\\IrintAI Assistant\\data\\models\\Dataset\\UncensoredDataSet.py": "from datasets import load_dataset, concatenate_datasets\n\n# List of dataset paths\ndataset_paths = [\n    \"V3N0M/Jenna-50K-Alpaca-Uncensored\",\n    \"SaisExperiments/Alpaca-Uncensored\",\n    \"SaisExperiments/Big-Alpaca-Uncensored\",\n    \"xzuyn/open-instruct-uncensored-alpaca\",\n    \"xzuyn/tulu-uncensored-alpaca\",\n    \"xzuyn/tv-alpaca-open-instruct-uncensored-blend\",\n    \"dim/dolphin_flan1m_alpaca_uncensored_3k\",\n    \"dataautogpt3/flan1m-alpaca-uncensored\",\n    \"ShubhVenom/Uncensored-Alpaca-v01\",\n    \"V3N0M/Uncensored-Alpaca\",\n    \"Xennon-BD/Alpaca-uncensored\",\n    \"VinyVan/flanMini-alpaca-uncensored_bambara\"\n]\n\n# Load the first dataset to get reference columns\ndataset1 = load_dataset(dataset_paths[0], split=\"train\")\nreference_columns = dataset1.column_names\n\n# Load and select columns for the remaining datasets\ndatasets = [dataset1]\nfor path in dataset_paths[1:]:\n    dataset = load_dataset(path, split=\"train\")\n    dataset = dataset.select_columns(reference_columns)\n    datasets.append(dataset)\n\n# Merge all datasets\nmerged_dataset = concatenate_datasets(datasets)\n\n# Print the number of rows in the merged dataset\nprint(f\"line: {len(merged_dataset)}\")\n\n# Save the merged dataset to disk\nmerged_dataset.save_to_disk(\"merged_uncensored_alpaca\")",
  "D:\\AI\\IrintAI Assistant\\plugins\\plugin_settings_fix.py": "\"\"\"\nPlugin settings panel fix for IrintAI Assistant\n\"\"\"\n\ndef fix_plugin_settings_panel(panel):\n    \"\"\"\n    Apply fixes to the plugin settings panel\n    \n    Args:\n        panel: The plugin panel instance to fix\n    \"\"\"\n    # Store the original methods we're overriding\n    original_load_settings = panel.load_settings_plugins\n    original_on_selected = panel.on_settings_plugin_selected\n    original_load_config = panel.load_plugin_config\n    \n    # Override with fixed methods\n    def fixed_load_settings_plugins():\n        \"\"\"Load the list of available plugins into the settings tab\"\"\"\n        # Clear the listbox\n        panel.settings_plugin_listbox.delete(0, tk.END)\n        \n        # Get all plugins\n        plugins = panel.plugin_manager.get_all_plugins()\n        if not plugins:\n            # If plugins dict is empty, try to discover plugins first\n            panel.plugin_manager.discover_plugins()\n            # Try again to get plugins\n            plugins = panel.plugin_manager.get_all_plugins()\n            \n        # Sort plugins by name\n        plugin_ids = sorted(plugins.keys()) if plugins else []\n        \n        # Add plugins to listbox with status indicator\n        for plugin_id in plugin_ids:\n            plugin_info = plugins.get(plugin_id, {})\n            status = plugin_info.get(\"status\", \"unknown\")\n            display_name = f\"\u2713 {plugin_id}\" if status == \"active\" else plugin_id\n            panel.settings_plugin_listbox.insert(tk.END, display_name)\n            \n        # Log the number of plugins found\n        if hasattr(panel, 'log') and panel.log:\n            panel.log(f\"[PluginPanel] Loaded {len(plugin_ids)} plugins into settings tab\")\n    \n    def fixed_on_settings_plugin_selected(event):\n        \"\"\"Handle plugin selection in the settings tab\"\"\"\n        # Get selected plugin\n        selection = panel.settings_plugin_listbox.curselection()\n        if not selection:\n            return\n            \n        plugin_text = panel.settings_plugin_listbox.get(selection[0])\n        # Strip active indicator if present\n        if plugin_text.startswith(\"\u2713 \"):\n            plugin_id = plugin_text[2:]\n        else:\n            plugin_id = plugin_text\n            \n        fixed_load_plugin_config(plugin_id)\n    \n    def fixed_load_plugin_config(plugin_id):\n        \"\"\"Load the configuration for a plugin\"\"\"\n        # Clear the config content\n        for widget in panel.settings_content.winfo_children():\n            widget.destroy()\n        \n        # Update current plugin\n        panel.current_plugin_id = plugin_id\n        panel.current_config = {}\n        panel.config_widgets = {}\n        \n        # Get plugin info\n        plugin_info = panel.plugin_manager.get_plugin_metadata(plugin_id)\n        if not plugin_info:\n            if hasattr(panel, 'log') and panel.log:\n                panel.log(f\"[PluginPanel] No metadata found for plugin: {plugin_id}\")\n            plugin_info = {\"name\": plugin_id, \"description\": \"No description available\"}\n        \n        # Get plugin status\n        plugins = panel.plugin_manager.get_all_plugins()\n        plugin_data = plugins.get(plugin_id, {})\n        status = plugin_data.get(\"status\", \"unknown\")\n        \n        # Update header and description\n        plugin_name = plugin_info.get(\"name\", plugin_id)\n        panel.settings_header.config(text=f\"Configure: {plugin_name} ({status})\")\n        \n        description = plugin_info.get(\"description\", \"No description available.\")\n        version = plugin_info.get(\"version\", \"1.0.0\")\n        author = plugin_info.get(\"author\", \"Unknown\")\n        panel.settings_description.config(text=f\"{description}\\nVersion: {version} | Author: {author}\")\n        \n        # Get plugin configuration\n        config = get_plugin_config(panel, plugin_id)\n        \n        # Get schema\n        schema = get_plugin_schema(panel, plugin_id)\n        \n        if not schema:\n            # No schema, show a message\n            import tkinter.ttk as ttk\n            ttk.Label(panel.settings_content, text=\"This plugin has no configurable settings.\",\n                      font=(\"\", 10)).grid(row=0, column=0, padx=10, pady=25)\n            panel.settings_save_button.state(['disabled'])\n            panel.settings_reset_button.state(['disabled'])\n            panel.current_config = {}\n            return\n        \n        # Store current config\n        panel.current_config = config.copy()\n        \n        # Create settings UI based on schema\n        create_settings_ui(panel, schema, config)\n        \n        # Enable buttons\n        panel.settings_save_button.state(['!disabled'])\n        panel.settings_reset_button.state(['!disabled'])\n    \n    # Replace original methods with fixed versions\n    panel.load_settings_plugins = fixed_load_settings_plugins\n    panel.on_settings_plugin_selected = lambda event: fixed_on_settings_plugin_selected(event)\n    panel.load_plugin_config = fixed_load_plugin_config\n    \n    # Reload the settings plugins to apply the fix\n    panel.load_settings_plugins()\n    \n    return panel\n\ndef get_plugin_config(panel, plugin_id):\n    \"\"\"Get configuration for a plugin from multiple sources\"\"\"\n    config = {}\n    \n    # Try to get from config manager's plugins section\n    if hasattr(panel, 'config_manager') and panel.config_manager:\n        all_configs = panel.config_manager.get(\"plugins\", {}) or {}\n        if plugin_id in all_configs and isinstance(all_configs[plugin_id], dict):\n            config = all_configs[plugin_id].copy()\n            if hasattr(panel, 'log') and panel.log:\n                panel.log(f\"[PluginPanel] Found configuration in 'plugins.{plugin_id}' section\")\n            return config\n            \n        # Try legacy format with prefix\n        prefix = f\"plugins.{plugin_id}.\"\n        prefixed_configs = {}\n        try:\n            if hasattr(panel.config_manager, 'get_all') and callable(panel.config_manager.get_all):\n                all_config = panel.config_manager.get_all()\n            elif hasattr(panel.config_manager, 'config'):\n                all_config = panel.config_manager.config\n            else:\n                all_config = {}\n                \n            for key, value in all_config.items():\n                if key.startswith(prefix):\n                    config_key = key[len(prefix):]\n                    prefixed_configs[config_key] = value\n                    \n            if prefixed_configs:\n                if hasattr(panel, 'log') and panel.log:\n                    panel.log(f\"[PluginPanel] Found legacy configuration with prefix: {prefix}\")\n                return prefixed_configs\n                \n            # Try direct plugin_id entry\n            direct_config = panel.config_manager.get(plugin_id, None)\n            if isinstance(direct_config, dict):\n                if hasattr(panel, 'log') and panel.log:\n                    panel.log(f\"[PluginPanel] Found direct configuration under key: {plugin_id}\")\n                return direct_config\n        except Exception as e:\n            if hasattr(panel, 'log') and panel.log:\n                panel.log(f\"[PluginPanel] Error getting config: {e}\")\n    \n    # Try to get default config from plugin instance\n    plugin_instance = panel.plugin_manager.get_plugin_instance(plugin_id)\n    if plugin_instance:\n        if hasattr(plugin_instance, \"get_default_config\") and callable(plugin_instance.get_default_config):\n            try:\n                default_config = plugin_instance.get_default_config()\n                if default_config:\n                    if hasattr(panel, 'log') and panel.log:\n                        panel.log(f\"[PluginPanel] Using default config from plugin\")\n                    return default_config\n            except Exception as e:\n                if hasattr(panel, 'log') and panel.log:\n                    panel.log(f\"[PluginPanel] Error getting default config: {e}\")\n    \n    return config\n\ndef get_plugin_schema(panel, plugin_id):\n    \"\"\"Get schema for a plugin from multiple sources\"\"\"\n    schema = {}\n    \n    # Try to get from plugin instance\n    plugin_instance = panel.plugin_manager.get_plugin_instance(plugin_id)\n    if plugin_instance:\n        # Check for get_config_schema method\n        if hasattr(plugin_instance, \"get_config_schema\") and callable(plugin_instance.get_config_schema):\n            try:\n                plugin_schema = plugin_instance.get_config_schema()\n                if plugin_schema:\n                    if hasattr(panel, 'log') and panel.log:\n                        panel.log(f\"[PluginPanel] Found schema via get_config_schema() method\")\n                    return plugin_schema\n            except Exception as e:\n                if hasattr(panel, 'log') and panel.log:\n                    panel.log(f\"[PluginPanel] Error calling get_config_schema(): {e}\")\n        \n        # Check for CONFIG_SCHEMA attribute\n        if hasattr(plugin_instance, \"CONFIG_SCHEMA\"):\n            try:\n                plugin_schema = plugin_instance.CONFIG_SCHEMA\n                if plugin_schema:\n                    if hasattr(panel, 'log') and panel.log:\n                        panel.log(f\"[PluginPanel] Found schema via CONFIG_SCHEMA attribute\")\n                    return plugin_schema\n            except Exception as e:\n                if hasattr(panel, 'log') and panel.log:\n                    panel.log(f\"[PluginPanel] Error accessing CONFIG_SCHEMA: {e}\")\n    \n    # Try to infer schema from existing configuration\n    config = get_plugin_config(panel, plugin_id)\n    if config:\n        inferred_schema = {}\n        for key, value in config.items():\n            field_type = \"string\"\n            if isinstance(value, bool):\n                field_type = \"boolean\"\n            elif isinstance(value, int):\n                field_type = \"integer\"\n            elif isinstance(value, float):\n                field_type = \"float\"\n            \n            inferred_schema[key] = {\n                \"label\": key.replace('_', ' ').title(),\n                \"type\": field_type,\n                \"default\": value,\n                \"description\": f\"Configuration value for {key}\"\n            }\n        \n        if inferred_schema:\n            if hasattr(panel, 'log') and panel.log:\n                panel.log(f\"[PluginPanel] Created inferred schema from existing configuration\")\n            return inferred_schema\n    \n    return schema\n\ndef create_settings_ui(panel, schema, config):\n    \"\"\"Create settings UI based on schema\"\"\"\n    import tkinter as tk\n    import tkinter.ttk as ttk\n    \n    # Create widgets for config options\n    row = 0\n    for field_name, field_info in schema.items():\n        field_label = field_info.get(\"label\", field_name)\n        field_type = field_info.get(\"type\", \"string\")\n        field_default = field_info.get(\"default\", \"\")\n        field_desc = field_info.get(\"description\", \"\")\n        field_options = field_info.get(\"options\", [])\n        field_value = config.get(field_name, field_default)\n        \n        # Create label\n        label = ttk.Label(panel.settings_content, text=f\"{field_label}:\")\n        label.grid(row=row, column=0, sticky=tk.W, padx=5, pady=5)\n        \n        # Create widget based on type\n        widget = None\n        \n        if field_type == \"boolean\":\n            var = tk.BooleanVar(value=field_value)\n            widget = ttk.Checkbutton(panel.settings_content, variable=var)\n            panel.config_widgets[field_name] = var\n        \n        elif field_type == \"choice\" and field_options:\n            var = tk.StringVar(value=field_value)\n            widget = ttk.Combobox(panel.settings_content, textvariable=var, values=field_options, state=\"readonly\")\n            panel.config_widgets[field_name] = var\n        \n        elif field_type == \"integer\":\n            var = tk.IntVar(value=int(field_value) if field_value not in (None, \"\") else 0)\n            min_val = field_info.get(\"min\", 0)\n            max_val = field_info.get(\"max\", 1000000)\n            widget = ttk.Spinbox(panel.settings_content, from_=min_val, to=max_val, textvariable=var, width=10)\n            panel.config_widgets[field_name] = var\n        \n        elif field_type == \"float\":\n            var = tk.DoubleVar(value=float(field_value) if field_value not in (None, \"\") else 0.0)\n            min_val = field_info.get(\"min\", 0.0)\n            max_val = field_info.get(\"max\", 1000000.0)\n            increment = field_info.get(\"increment\", 0.1)\n            widget = ttk.Spinbox(panel.settings_content, from_=min_val, to=max_val, increment=increment, textvariable=var, width=10)\n            panel.config_widgets[field_name] = var\n        \n        else:  # Default to string\n            var = tk.StringVar(value=str(field_value) if field_value is not None else \"\")\n            widget = ttk.Entry(panel.settings_content, textvariable=var, width=40)\n            panel.config_widgets[field_name] = var\n        \n        widget.grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)\n        \n        # Add tooltip/description if provided\n        if field_desc:\n            help_label = ttk.Label(panel.settings_content, text=\"\u2139\ufe0f\", cursor=\"question_arrow\")\n            help_label.grid(row=row, column=2, padx=5, pady=5)\n            \n            # Create tooltip\n            create_tooltip(help_label, field_desc)\n        \n        row += 1\n\ndef create_tooltip(widget, text):\n    \"\"\"Create a tooltip for a widget\"\"\"\n    import tkinter as tk\n    import tkinter.ttk as ttk\n    \n    tooltip = None\n    \n    def show_tooltip(event):\n        nonlocal tooltip\n        x, y, _, _ = widget.bbox(\"insert\")\n        x += widget.winfo_rootx() + 25\n        y += widget.winfo_rooty() + 25\n        \n        # Create toplevel window\n        tooltip = tk.Toplevel(widget)\n        tooltip.wm_overrideredirect(True)\n        tooltip.wm_geometry(f\"+{x}+{y}\")\n        \n        # Create tooltip label\n        label = ttk.Label(tooltip, text=text, background=\"#ffffe0\", relief=tk.SOLID, borderwidth=1, \n                         wraplength=300, justify=tk.LEFT)\n        label.pack(padx=5, pady=5)\n        \n    def hide_tooltip(event):\n        nonlocal tooltip\n        if tooltip:\n            tooltip.destroy()\n            tooltip = None\n            \n    widget.bind(\"<Enter>\", show_tooltip)\n    widget.bind(\"<Leave>\", hide_tooltip)\n",
  "D:\\AI\\IrintAI Assistant\\core\\settings_manager.py": "\"\"\"\nSettings Manager - Centralized management of application settings with observer pattern,\nsettings migration, and settings synchronization\n\"\"\"\nimport os\nimport json\nfrom typing import Dict, List, Any, Callable, Optional\nimport threading\n\nclass SettingsManager:\n    \"\"\"\n    Centralized settings manager with observer pattern to ensure settings consistency\n    throughout the application. This helps prevent duplicate or conflicting settings\n    controls across different UI panels.\n    \"\"\"\n    \n    def __init__(self, config_manager, logger: Optional[Callable] = None):\n        \"\"\"\n        Initialize the settings manager\n        \n        Args:\n            config_manager: ConfigManager instance\n            logger: Optional logging function\n        \"\"\"\n        self.config_manager = config_manager\n        self.log = logger or print\n        self.observers = {}\n        self.lock = threading.RLock()  # Use RLock for thread safety\n        \n    def register_observer(self, setting_key: str, observer: Callable):\n        \"\"\"\n        Register an observer for a specific setting\n        \n        Args:\n            setting_key: The setting key to observe\n            observer: Callback function to be called when setting changes\n        \"\"\"\n        with self.lock:\n            if setting_key not in self.observers:\n                self.observers[setting_key] = []\n            \n            if observer not in self.observers[setting_key]:\n                self.observers[setting_key].append(observer)\n                \n    def unregister_observer(self, setting_key: str, observer: Callable):\n        \"\"\"\n        Unregister an observer for a specific setting\n        \n        Args:\n            setting_key: The setting key being observed\n            observer: Callback function to remove\n        \"\"\"\n        with self.lock:\n            if setting_key in self.observers and observer in self.observers[setting_key]:\n                self.observers[setting_key].remove(observer)\n                \n    def update_setting(self, setting_key: str, value: Any):\n        \"\"\"\n        Update a setting and notify all observers\n        \n        Args:\n            setting_key: The setting key to update\n            value: The new value for the setting\n        \"\"\"\n        with self.lock:\n            # Update the setting in the config manager\n            self.config_manager.set(setting_key, value)\n            \n            # Notify all observers for this setting\n            if setting_key in self.observers:\n                for observer in self.observers[setting_key]:\n                    try:\n                        observer(value)\n                    except Exception as e:\n                        self.log(f\"[Settings] Error notifying observer for {setting_key}: {e}\")\n                        \n            # Special case for patterns where settings have both specific and general observers\n            parts = setting_key.split('.')\n            if len(parts) > 1:\n                pattern = '.'.join(parts[:-1]) + '.*'\n                if pattern in self.observers:\n                    for observer in self.observers[pattern]:\n                        try:\n                            observer(setting_key, value)\n                        except Exception as e:\n                            self.log(f\"[Settings] Error notifying pattern observer for {setting_key}: {e}\")\n    \n    def get_setting(self, setting_key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a setting value\n        \n        Args:\n            setting_key: The setting key to retrieve\n            default: Default value if setting not found\n            \n        Returns:\n            The setting value or default if not found\n        \"\"\"\n        return self.config_manager.get(setting_key, default)\n        \n    def batch_update(self, settings: Dict[str, Any]):\n        \"\"\"\n        Update multiple settings at once\n        \n        Args:\n            settings: Dictionary of setting keys and values\n        \"\"\"\n        with self.lock:\n            # First update all settings\n            for key, value in settings.items():\n                self.config_manager.set(key, value)\n                \n            # Then notify all observers\n            for key, value in settings.items():\n                if key in self.observers:\n                    for observer in self.observers[key]:\n                        try:\n                            observer(value)\n                        except Exception as e:\n                            self.log(f\"[Settings] Error notifying observer for {key}: {e}\")\n    \n    def migrate_legacy_settings(self, core_system):\n        \"\"\"\n        Migrate settings from the old fragmented structure to the new unified settings structure\n        \n        Args:\n            core_system: Dictionary containing core system components\n            \n        Returns:\n            int: Number of migrated settings\n        \"\"\"\n        self.log(\"[Settings] Starting settings migration...\")\n        \n        config_manager = core_system.get(\"config_manager\")\n        if not config_manager:\n            self.log(\"[Settings] Error: Config manager not found in core system\")\n            return 0\n        \n        # Get the old config\n        old_config = config_manager.config\n        \n        # Mapping of old settings paths to new paths\n        migration_map = {\n            # Memory settings\n            \"memory_mode\": \"memory.mode\",\n            \"memory_embedding_model\": \"memory.embedding_model\",\n            \"pdf_ocr_enabled\": \"memory.pdf.ocr_enabled\",\n            \n            # Model settings\n            \"default_model\": \"model.default\",\n            \"model_temperature\": \"model.temperature\",\n            \"use_8bit\": \"model.use_8bit\",\n            \"use_gpu\": \"model.use_gpu\",\n            \n            # UI settings\n            \"ui_theme\": \"ui.theme\",\n            \n            # Plugin settings\n            \"plugin_auto_start\": \"plugins.auto_start\",\n            \"plugin_directory\": \"plugins.directory\",\n            \"plugin_sandbox\": \"plugins.sandbox\",\n            \n            # System settings\n            \"system_autosave\": \"system.autosave\",\n            \"monitoring_interval\": \"system.monitoring_interval\",\n            \n            # Logging settings\n            \"log_level\": \"logging.level\",\n            \"log_retention_days\": \"logging.retention_days\"\n        }\n        \n        # Track migrated settings\n        migrated = 0\n        \n        # Migrate each setting if it exists in the old config\n        for old_key, new_key in migration_map.items():\n            if old_key in old_config:\n                self.update_setting(new_key, old_config[old_key])\n                migrated += 1\n                \n        # Migrate plugin-specific settings\n        if \"plugins\" in old_config and isinstance(old_config[\"plugins\"], dict):\n            for plugin_id, plugin_settings in old_config[\"plugins\"].items():\n                # Skip internal plugin management settings\n                if plugin_id in [\"auto_start\", \"directory\", \"sandbox\"]:\n                    continue\n                    \n                if isinstance(plugin_settings, dict):\n                    # Create a new plugin settings key\n                    plugin_key = f\"plugins.{plugin_id}\"\n                    self.update_setting(plugin_key, plugin_settings)\n                    migrated += 1\n                    \n        self.log(f\"[Settings] Migration complete: {migrated} settings migrated to new structure\")\n        \n        # Settings are already saved by settings_manager.update_setting\n        # No need for explicit save call\n        \n        return migrated\n\n    def setup_settings_synchronization(self, core_system):\n        \"\"\"\n        Set up observers to synchronize settings between components\n        \n        Args:\n            core_system: Dictionary containing core system components\n            \n        Returns:\n            bool: True if synchronization was set up successfully, False otherwise\n        \"\"\"\n        self.log(\"[Settings] Setting up settings synchronization...\")\n        \n        chat_engine = core_system.get(\"chat_engine\")\n        memory_system = core_system.get(\"memory_system\")\n        \n        if not chat_engine:\n            self.log(\"[Settings] Error: Chat engine not found in core system\")\n            return False\n        \n        # Set up memory mode synchronization\n        def on_memory_mode_change(value):\n            if value == \"off\":\n                chat_engine.set_memory_mode(enabled=False)\n            elif value == \"manual\":\n                chat_engine.set_memory_mode(enabled=True, auto=False, background=False)\n            elif value == \"auto\":\n                chat_engine.set_memory_mode(enabled=True, auto=True, background=False)\n            elif value == \"background\":\n                chat_engine.set_memory_mode(enabled=True, auto=True, background=True)\n                \n            self.log(f\"[Memory Mode] Set to: {value.capitalize()}\")\n        \n        # Register the observer for memory mode changes\n        self.register_observer(\"memory.mode\", on_memory_mode_change)\n        \n        # Set up system prompt synchronization\n        def on_system_prompt_change(value):\n            chat_engine.set_system_prompt(value)\n        \n        # Register the observer for system prompt changes\n        self.register_observer(\"chat.system_prompt\", on_system_prompt_change)\n        \n        # Initialize with current settings\n        current_mode = self.get_setting(\"memory.mode\", \"off\")\n        on_memory_mode_change(current_mode)\n        \n        current_prompt = self.get_setting(\"chat.system_prompt\", \n                                          \"You are Irintai, a helpful and knowledgeable assistant.\")\n        on_system_prompt_change(current_prompt)\n        \n        self.log(\"[Settings] Settings synchronization set up successfully\")\n        return True\n",
  "D:\\AI\\IrintAI Assistant\\diagnostics\\diagnostics_integration.py": "\"\"\"\nEnhanced Diagnostics Integration Module\n\nThis module integrates the enhanced diagnostics functionality with the rest of the system,\nparticularly with the settings manager.\n\"\"\"\n\nimport os\nimport sys\nimport importlib\nimport logging\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\ndef integrate_with_settings_manager(settings_manager):\n    \"\"\"\n    Integrate enhanced diagnostics with the settings manager\n    \n    Args:\n        settings_manager: The settings manager instance\n        \n    Returns:\n        bool: True if integration was successful, False otherwise\n    \"\"\"\n    logger.info(\"Integrating enhanced diagnostics with settings manager...\")\n    \n    try:\n        # Register diagnostic settings\n        settings_manager.update_setting(\"diagnostics.enabled\", True)\n        settings_manager.update_setting(\"diagnostics.log_level\", \"INFO\")\n        settings_manager.update_setting(\"diagnostics.auto_fix\", False)\n        settings_manager.update_setting(\"diagnostics.track_memory\", True)\n        \n        # Setup diagnostic observers\n        def on_log_level_change(value):\n            logging.getLogger(\"diagnostics\").setLevel(value)\n            logger.info(f\"Diagnostic log level changed to {value}\")\n        \n        # Register the observer for log level changes\n        settings_manager.register_observer(\"diagnostics.log_level\", on_log_level_change)\n        \n        # Initialize with current setting\n        current_level = settings_manager.get_setting(\"diagnostics.log_level\", \"INFO\")\n        log_level = getattr(logging, current_level, logging.INFO)\n        logging.getLogger(\"diagnostics\").setLevel(log_level)\n        \n        logger.info(\"Enhanced diagnostics successfully integrated with settings manager\")\n        return True\n    except Exception as e:\n        logger.error(f\"Failed to integrate enhanced diagnostics with settings manager: {e}\")\n        return False\n\ndef setup_runtime_patching():\n    \"\"\"\n    Set up runtime patching utilities if they don't exist\n    \n    Returns:\n        tuple: (patch_plugin_manager, ensure_method_exists) functions or None if not available\n    \"\"\"\n    try:\n        # First try to import from utils\n        from runtime_patching import patch_plugin_manager, ensure_method_exists\n        logger.info(\"Using runtime patching utilities from utils.runtime_patching\")\n        return (patch_plugin_manager, ensure_method_exists)\n    except ImportError:\n        logger.warning(\"utils.runtime_patching not available, creating local implementation\")\n        \n        # Create local implementation if import fails\n        def ensure_attribute_exists(obj, attribute_name, default_value=None):\n            \"\"\"Ensure attribute exists on object\"\"\"\n            if not hasattr(obj, attribute_name):\n                setattr(obj, attribute_name, default_value)\n                logger.warning(f\"Added missing attribute '{attribute_name}' to {obj.__class__.__name__}\")\n        \n        def ensure_method_exists(obj, method_name, default_impl=None):\n            \"\"\"Ensure method exists on object\"\"\"\n            if not hasattr(obj, method_name):\n                if default_impl is None:\n                    def stub_method(*args, **kwargs):\n                        class_name = obj.__class__.__name__\n                        logger.warning(f\"Called missing method '{method_name}' on {class_name}\")\n                        return None\n                    \n                    default_impl = stub_method\n                \n                setattr(obj, method_name, default_impl.__get__(obj, obj.__class__))\n                logger.warning(f\"Added missing method '{method_name}' to {obj.__class__.__name__}\")\n        \n        def patch_plugin_manager(plugin_manager):\n            \"\"\"Patch plugin manager with required methods\"\"\"\n            required_methods = [\n                \"set_error_handler\",\n                \"discover_plugins\",\n                \"load_plugin\", \n                \"activate_plugin\", \n                \"deactivate_plugin\",\n                \"unload_plugin\",\n                \"unload_all_plugins\",\n                \"auto_load_plugins\",\n                \"get_plugin_metadata\",\n                \"get_all_plugins\",\n                \"reload_plugin\"\n            ]\n            \n            for method in required_methods:\n                ensure_method_exists(plugin_manager, method)\n            \n            ensure_attribute_exists(plugin_manager, \"plugins\", {})\n            ensure_attribute_exists(plugin_manager, \"plugin_statuses\", {})\n            ensure_attribute_exists(plugin_manager, \"plugin_dir\", \"plugins\")\n            ensure_attribute_exists(plugin_manager, \"config_dir\", \"data/plugins\")\n            \n            return plugin_manager\n            \n        return (patch_plugin_manager, ensure_method_exists)\n"
}